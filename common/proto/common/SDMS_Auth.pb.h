// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SDMS_Auth.proto
// Protobuf C++ Version: 4.25.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_SDMS_5fAuth_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_SDMS_5fAuth_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "SDMS.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_SDMS_5fAuth_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_SDMS_5fAuth_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_SDMS_5fAuth_2eproto;
namespace SDMS {
namespace Auth {
class ACLDataReply;
struct ACLDataReplyDefaultTypeInternal;
extern ACLDataReplyDefaultTypeInternal _ACLDataReply_default_instance_;
class ACLSharedListItemsRequest;
struct ACLSharedListItemsRequestDefaultTypeInternal;
extern ACLSharedListItemsRequestDefaultTypeInternal _ACLSharedListItemsRequest_default_instance_;
class ACLSharedListRequest;
struct ACLSharedListRequestDefaultTypeInternal;
extern ACLSharedListRequestDefaultTypeInternal _ACLSharedListRequest_default_instance_;
class ACLUpdateRequest;
struct ACLUpdateRequestDefaultTypeInternal;
extern ACLUpdateRequestDefaultTypeInternal _ACLUpdateRequest_default_instance_;
class ACLViewRequest;
struct ACLViewRequestDefaultTypeInternal;
extern ACLViewRequestDefaultTypeInternal _ACLViewRequest_default_instance_;
class CheckPermsReply;
struct CheckPermsReplyDefaultTypeInternal;
extern CheckPermsReplyDefaultTypeInternal _CheckPermsReply_default_instance_;
class CheckPermsRequest;
struct CheckPermsRequestDefaultTypeInternal;
extern CheckPermsRequestDefaultTypeInternal _CheckPermsRequest_default_instance_;
class CollCreateRequest;
struct CollCreateRequestDefaultTypeInternal;
extern CollCreateRequestDefaultTypeInternal _CollCreateRequest_default_instance_;
class CollDataReply;
struct CollDataReplyDefaultTypeInternal;
extern CollDataReplyDefaultTypeInternal _CollDataReply_default_instance_;
class CollDeleteRequest;
struct CollDeleteRequestDefaultTypeInternal;
extern CollDeleteRequestDefaultTypeInternal _CollDeleteRequest_default_instance_;
class CollGetOffsetReply;
struct CollGetOffsetReplyDefaultTypeInternal;
extern CollGetOffsetReplyDefaultTypeInternal _CollGetOffsetReply_default_instance_;
class CollGetOffsetRequest;
struct CollGetOffsetRequestDefaultTypeInternal;
extern CollGetOffsetRequestDefaultTypeInternal _CollGetOffsetRequest_default_instance_;
class CollGetParentsRequest;
struct CollGetParentsRequestDefaultTypeInternal;
extern CollGetParentsRequestDefaultTypeInternal _CollGetParentsRequest_default_instance_;
class CollListPublishedRequest;
struct CollListPublishedRequestDefaultTypeInternal;
extern CollListPublishedRequestDefaultTypeInternal _CollListPublishedRequest_default_instance_;
class CollMoveRequest;
struct CollMoveRequestDefaultTypeInternal;
extern CollMoveRequestDefaultTypeInternal _CollMoveRequest_default_instance_;
class CollPathReply;
struct CollPathReplyDefaultTypeInternal;
extern CollPathReplyDefaultTypeInternal _CollPathReply_default_instance_;
class CollReadRequest;
struct CollReadRequestDefaultTypeInternal;
extern CollReadRequestDefaultTypeInternal _CollReadRequest_default_instance_;
class CollUpdateRequest;
struct CollUpdateRequestDefaultTypeInternal;
extern CollUpdateRequestDefaultTypeInternal _CollUpdateRequest_default_instance_;
class CollViewRequest;
struct CollViewRequestDefaultTypeInternal;
extern CollViewRequestDefaultTypeInternal _CollViewRequest_default_instance_;
class CollWriteRequest;
struct CollWriteRequestDefaultTypeInternal;
extern CollWriteRequestDefaultTypeInternal _CollWriteRequest_default_instance_;
class DataDeleteRequest;
struct DataDeleteRequestDefaultTypeInternal;
extern DataDeleteRequestDefaultTypeInternal _DataDeleteRequest_default_instance_;
class DataGetReply;
struct DataGetReplyDefaultTypeInternal;
extern DataGetReplyDefaultTypeInternal _DataGetReply_default_instance_;
class DataGetRequest;
struct DataGetRequestDefaultTypeInternal;
extern DataGetRequestDefaultTypeInternal _DataGetRequest_default_instance_;
class DataPathReply;
struct DataPathReplyDefaultTypeInternal;
extern DataPathReplyDefaultTypeInternal _DataPathReply_default_instance_;
class DataPathRequest;
struct DataPathRequestDefaultTypeInternal;
extern DataPathRequestDefaultTypeInternal _DataPathRequest_default_instance_;
class DataPutReply;
struct DataPutReplyDefaultTypeInternal;
extern DataPutReplyDefaultTypeInternal _DataPutReply_default_instance_;
class DataPutRequest;
struct DataPutRequestDefaultTypeInternal;
extern DataPutRequestDefaultTypeInternal _DataPutRequest_default_instance_;
class GenerateCredentialsReply;
struct GenerateCredentialsReplyDefaultTypeInternal;
extern GenerateCredentialsReplyDefaultTypeInternal _GenerateCredentialsReply_default_instance_;
class GenerateCredentialsRequest;
struct GenerateCredentialsRequestDefaultTypeInternal;
extern GenerateCredentialsRequestDefaultTypeInternal _GenerateCredentialsRequest_default_instance_;
class GetPermsReply;
struct GetPermsReplyDefaultTypeInternal;
extern GetPermsReplyDefaultTypeInternal _GetPermsReply_default_instance_;
class GetPermsRequest;
struct GetPermsRequestDefaultTypeInternal;
extern GetPermsRequestDefaultTypeInternal _GetPermsRequest_default_instance_;
class GroupCreateRequest;
struct GroupCreateRequestDefaultTypeInternal;
extern GroupCreateRequestDefaultTypeInternal _GroupCreateRequest_default_instance_;
class GroupDataReply;
struct GroupDataReplyDefaultTypeInternal;
extern GroupDataReplyDefaultTypeInternal _GroupDataReply_default_instance_;
class GroupDeleteRequest;
struct GroupDeleteRequestDefaultTypeInternal;
extern GroupDeleteRequestDefaultTypeInternal _GroupDeleteRequest_default_instance_;
class GroupListRequest;
struct GroupListRequestDefaultTypeInternal;
extern GroupListRequestDefaultTypeInternal _GroupListRequest_default_instance_;
class GroupUpdateRequest;
struct GroupUpdateRequestDefaultTypeInternal;
extern GroupUpdateRequestDefaultTypeInternal _GroupUpdateRequest_default_instance_;
class GroupViewRequest;
struct GroupViewRequestDefaultTypeInternal;
extern GroupViewRequestDefaultTypeInternal _GroupViewRequest_default_instance_;
class ListingReply;
struct ListingReplyDefaultTypeInternal;
extern ListingReplyDefaultTypeInternal _ListingReply_default_instance_;
class MetadataValidateReply;
struct MetadataValidateReplyDefaultTypeInternal;
extern MetadataValidateReplyDefaultTypeInternal _MetadataValidateReply_default_instance_;
class MetadataValidateRequest;
struct MetadataValidateRequestDefaultTypeInternal;
extern MetadataValidateRequestDefaultTypeInternal _MetadataValidateRequest_default_instance_;
class NoteCommentEditRequest;
struct NoteCommentEditRequestDefaultTypeInternal;
extern NoteCommentEditRequestDefaultTypeInternal _NoteCommentEditRequest_default_instance_;
class NoteCreateRequest;
struct NoteCreateRequestDefaultTypeInternal;
extern NoteCreateRequestDefaultTypeInternal _NoteCreateRequest_default_instance_;
class NoteDataReply;
struct NoteDataReplyDefaultTypeInternal;
extern NoteDataReplyDefaultTypeInternal _NoteDataReply_default_instance_;
class NoteListBySubjectRequest;
struct NoteListBySubjectRequestDefaultTypeInternal;
extern NoteListBySubjectRequestDefaultTypeInternal _NoteListBySubjectRequest_default_instance_;
class NoteUpdateRequest;
struct NoteUpdateRequestDefaultTypeInternal;
extern NoteUpdateRequestDefaultTypeInternal _NoteUpdateRequest_default_instance_;
class NoteViewRequest;
struct NoteViewRequestDefaultTypeInternal;
extern NoteViewRequestDefaultTypeInternal _NoteViewRequest_default_instance_;
class ProjectCreateRequest;
struct ProjectCreateRequestDefaultTypeInternal;
extern ProjectCreateRequestDefaultTypeInternal _ProjectCreateRequest_default_instance_;
class ProjectDataReply;
struct ProjectDataReplyDefaultTypeInternal;
extern ProjectDataReplyDefaultTypeInternal _ProjectDataReply_default_instance_;
class ProjectDeleteRequest;
struct ProjectDeleteRequestDefaultTypeInternal;
extern ProjectDeleteRequestDefaultTypeInternal _ProjectDeleteRequest_default_instance_;
class ProjectGetRoleReply;
struct ProjectGetRoleReplyDefaultTypeInternal;
extern ProjectGetRoleReplyDefaultTypeInternal _ProjectGetRoleReply_default_instance_;
class ProjectGetRoleRequest;
struct ProjectGetRoleRequestDefaultTypeInternal;
extern ProjectGetRoleRequestDefaultTypeInternal _ProjectGetRoleRequest_default_instance_;
class ProjectListRequest;
struct ProjectListRequestDefaultTypeInternal;
extern ProjectListRequestDefaultTypeInternal _ProjectListRequest_default_instance_;
class ProjectSearchRequest;
struct ProjectSearchRequestDefaultTypeInternal;
extern ProjectSearchRequestDefaultTypeInternal _ProjectSearchRequest_default_instance_;
class ProjectUpdateRequest;
struct ProjectUpdateRequestDefaultTypeInternal;
extern ProjectUpdateRequestDefaultTypeInternal _ProjectUpdateRequest_default_instance_;
class ProjectViewRequest;
struct ProjectViewRequestDefaultTypeInternal;
extern ProjectViewRequestDefaultTypeInternal _ProjectViewRequest_default_instance_;
class QueryCreateRequest;
struct QueryCreateRequestDefaultTypeInternal;
extern QueryCreateRequestDefaultTypeInternal _QueryCreateRequest_default_instance_;
class QueryDataReply;
struct QueryDataReplyDefaultTypeInternal;
extern QueryDataReplyDefaultTypeInternal _QueryDataReply_default_instance_;
class QueryDeleteRequest;
struct QueryDeleteRequestDefaultTypeInternal;
extern QueryDeleteRequestDefaultTypeInternal _QueryDeleteRequest_default_instance_;
class QueryExecRequest;
struct QueryExecRequestDefaultTypeInternal;
extern QueryExecRequestDefaultTypeInternal _QueryExecRequest_default_instance_;
class QueryListRequest;
struct QueryListRequestDefaultTypeInternal;
extern QueryListRequestDefaultTypeInternal _QueryListRequest_default_instance_;
class QueryUpdateRequest;
struct QueryUpdateRequestDefaultTypeInternal;
extern QueryUpdateRequestDefaultTypeInternal _QueryUpdateRequest_default_instance_;
class QueryViewRequest;
struct QueryViewRequestDefaultTypeInternal;
extern QueryViewRequestDefaultTypeInternal _QueryViewRequest_default_instance_;
class RecordAllocChangeReply;
struct RecordAllocChangeReplyDefaultTypeInternal;
extern RecordAllocChangeReplyDefaultTypeInternal _RecordAllocChangeReply_default_instance_;
class RecordAllocChangeRequest;
struct RecordAllocChangeRequestDefaultTypeInternal;
extern RecordAllocChangeRequestDefaultTypeInternal _RecordAllocChangeRequest_default_instance_;
class RecordCreateBatchRequest;
struct RecordCreateBatchRequestDefaultTypeInternal;
extern RecordCreateBatchRequestDefaultTypeInternal _RecordCreateBatchRequest_default_instance_;
class RecordCreateRequest;
struct RecordCreateRequestDefaultTypeInternal;
extern RecordCreateRequestDefaultTypeInternal _RecordCreateRequest_default_instance_;
class RecordDataReply;
struct RecordDataReplyDefaultTypeInternal;
extern RecordDataReplyDefaultTypeInternal _RecordDataReply_default_instance_;
class RecordDeleteRequest;
struct RecordDeleteRequestDefaultTypeInternal;
extern RecordDeleteRequestDefaultTypeInternal _RecordDeleteRequest_default_instance_;
class RecordExportReply;
struct RecordExportReplyDefaultTypeInternal;
extern RecordExportReplyDefaultTypeInternal _RecordExportReply_default_instance_;
class RecordExportRequest;
struct RecordExportRequestDefaultTypeInternal;
extern RecordExportRequestDefaultTypeInternal _RecordExportRequest_default_instance_;
class RecordGetDependencyGraphRequest;
struct RecordGetDependencyGraphRequestDefaultTypeInternal;
extern RecordGetDependencyGraphRequestDefaultTypeInternal _RecordGetDependencyGraphRequest_default_instance_;
class RecordListByAllocRequest;
struct RecordListByAllocRequestDefaultTypeInternal;
extern RecordListByAllocRequestDefaultTypeInternal _RecordListByAllocRequest_default_instance_;
class RecordLockRequest;
struct RecordLockRequestDefaultTypeInternal;
extern RecordLockRequestDefaultTypeInternal _RecordLockRequest_default_instance_;
class RecordOwnerChangeReply;
struct RecordOwnerChangeReplyDefaultTypeInternal;
extern RecordOwnerChangeReplyDefaultTypeInternal _RecordOwnerChangeReply_default_instance_;
class RecordOwnerChangeRequest;
struct RecordOwnerChangeRequestDefaultTypeInternal;
extern RecordOwnerChangeRequestDefaultTypeInternal _RecordOwnerChangeRequest_default_instance_;
class RecordUpdateBatchRequest;
struct RecordUpdateBatchRequestDefaultTypeInternal;
extern RecordUpdateBatchRequestDefaultTypeInternal _RecordUpdateBatchRequest_default_instance_;
class RecordUpdateRequest;
struct RecordUpdateRequestDefaultTypeInternal;
extern RecordUpdateRequestDefaultTypeInternal _RecordUpdateRequest_default_instance_;
class RecordViewRequest;
struct RecordViewRequestDefaultTypeInternal;
extern RecordViewRequestDefaultTypeInternal _RecordViewRequest_default_instance_;
class RepoAllocationCreateRequest;
struct RepoAllocationCreateRequestDefaultTypeInternal;
extern RepoAllocationCreateRequestDefaultTypeInternal _RepoAllocationCreateRequest_default_instance_;
class RepoAllocationDeleteRequest;
struct RepoAllocationDeleteRequestDefaultTypeInternal;
extern RepoAllocationDeleteRequestDefaultTypeInternal _RepoAllocationDeleteRequest_default_instance_;
class RepoAllocationSetDefaultRequest;
struct RepoAllocationSetDefaultRequestDefaultTypeInternal;
extern RepoAllocationSetDefaultRequestDefaultTypeInternal _RepoAllocationSetDefaultRequest_default_instance_;
class RepoAllocationSetRequest;
struct RepoAllocationSetRequestDefaultTypeInternal;
extern RepoAllocationSetRequestDefaultTypeInternal _RepoAllocationSetRequest_default_instance_;
class RepoAllocationStatsReply;
struct RepoAllocationStatsReplyDefaultTypeInternal;
extern RepoAllocationStatsReplyDefaultTypeInternal _RepoAllocationStatsReply_default_instance_;
class RepoAllocationStatsRequest;
struct RepoAllocationStatsRequestDefaultTypeInternal;
extern RepoAllocationStatsRequestDefaultTypeInternal _RepoAllocationStatsRequest_default_instance_;
class RepoAllocationsReply;
struct RepoAllocationsReplyDefaultTypeInternal;
extern RepoAllocationsReplyDefaultTypeInternal _RepoAllocationsReply_default_instance_;
class RepoAuthzRequest;
struct RepoAuthzRequestDefaultTypeInternal;
extern RepoAuthzRequestDefaultTypeInternal _RepoAuthzRequest_default_instance_;
class RepoCalcSizeReply;
struct RepoCalcSizeReplyDefaultTypeInternal;
extern RepoCalcSizeReplyDefaultTypeInternal _RepoCalcSizeReply_default_instance_;
class RepoCalcSizeRequest;
struct RepoCalcSizeRequestDefaultTypeInternal;
extern RepoCalcSizeRequestDefaultTypeInternal _RepoCalcSizeRequest_default_instance_;
class RepoCreateRequest;
struct RepoCreateRequestDefaultTypeInternal;
extern RepoCreateRequestDefaultTypeInternal _RepoCreateRequest_default_instance_;
class RepoDataDeleteRequest;
struct RepoDataDeleteRequestDefaultTypeInternal;
extern RepoDataDeleteRequestDefaultTypeInternal _RepoDataDeleteRequest_default_instance_;
class RepoDataGetSizeRequest;
struct RepoDataGetSizeRequestDefaultTypeInternal;
extern RepoDataGetSizeRequestDefaultTypeInternal _RepoDataGetSizeRequest_default_instance_;
class RepoDataReply;
struct RepoDataReplyDefaultTypeInternal;
extern RepoDataReplyDefaultTypeInternal _RepoDataReply_default_instance_;
class RepoDataSizeReply;
struct RepoDataSizeReplyDefaultTypeInternal;
extern RepoDataSizeReplyDefaultTypeInternal _RepoDataSizeReply_default_instance_;
class RepoDeleteRequest;
struct RepoDeleteRequestDefaultTypeInternal;
extern RepoDeleteRequestDefaultTypeInternal _RepoDeleteRequest_default_instance_;
class RepoListAllocationsRequest;
struct RepoListAllocationsRequestDefaultTypeInternal;
extern RepoListAllocationsRequestDefaultTypeInternal _RepoListAllocationsRequest_default_instance_;
class RepoListObjectAllocationsRequest;
struct RepoListObjectAllocationsRequestDefaultTypeInternal;
extern RepoListObjectAllocationsRequestDefaultTypeInternal _RepoListObjectAllocationsRequest_default_instance_;
class RepoListRequest;
struct RepoListRequestDefaultTypeInternal;
extern RepoListRequestDefaultTypeInternal _RepoListRequest_default_instance_;
class RepoListSubjectAllocationsRequest;
struct RepoListSubjectAllocationsRequestDefaultTypeInternal;
extern RepoListSubjectAllocationsRequestDefaultTypeInternal _RepoListSubjectAllocationsRequest_default_instance_;
class RepoPathCreateRequest;
struct RepoPathCreateRequestDefaultTypeInternal;
extern RepoPathCreateRequestDefaultTypeInternal _RepoPathCreateRequest_default_instance_;
class RepoPathDeleteRequest;
struct RepoPathDeleteRequestDefaultTypeInternal;
extern RepoPathDeleteRequestDefaultTypeInternal _RepoPathDeleteRequest_default_instance_;
class RepoUpdateRequest;
struct RepoUpdateRequestDefaultTypeInternal;
extern RepoUpdateRequestDefaultTypeInternal _RepoUpdateRequest_default_instance_;
class RepoViewAllocationRequest;
struct RepoViewAllocationRequestDefaultTypeInternal;
extern RepoViewAllocationRequestDefaultTypeInternal _RepoViewAllocationRequest_default_instance_;
class RepoViewRequest;
struct RepoViewRequestDefaultTypeInternal;
extern RepoViewRequestDefaultTypeInternal _RepoViewRequest_default_instance_;
class RevokeCredentialsRequest;
struct RevokeCredentialsRequestDefaultTypeInternal;
extern RevokeCredentialsRequestDefaultTypeInternal _RevokeCredentialsRequest_default_instance_;
class SchemaCreateRequest;
struct SchemaCreateRequestDefaultTypeInternal;
extern SchemaCreateRequestDefaultTypeInternal _SchemaCreateRequest_default_instance_;
class SchemaDataReply;
struct SchemaDataReplyDefaultTypeInternal;
extern SchemaDataReplyDefaultTypeInternal _SchemaDataReply_default_instance_;
class SchemaDeleteRequest;
struct SchemaDeleteRequestDefaultTypeInternal;
extern SchemaDeleteRequestDefaultTypeInternal _SchemaDeleteRequest_default_instance_;
class SchemaReviseRequest;
struct SchemaReviseRequestDefaultTypeInternal;
extern SchemaReviseRequestDefaultTypeInternal _SchemaReviseRequest_default_instance_;
class SchemaSearchRequest;
struct SchemaSearchRequestDefaultTypeInternal;
extern SchemaSearchRequestDefaultTypeInternal _SchemaSearchRequest_default_instance_;
class SchemaUpdateRequest;
struct SchemaUpdateRequestDefaultTypeInternal;
extern SchemaUpdateRequestDefaultTypeInternal _SchemaUpdateRequest_default_instance_;
class SchemaViewRequest;
struct SchemaViewRequestDefaultTypeInternal;
extern SchemaViewRequestDefaultTypeInternal _SchemaViewRequest_default_instance_;
class SearchRequest;
struct SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
class TagDataReply;
struct TagDataReplyDefaultTypeInternal;
extern TagDataReplyDefaultTypeInternal _TagDataReply_default_instance_;
class TagListByCountRequest;
struct TagListByCountRequestDefaultTypeInternal;
extern TagListByCountRequestDefaultTypeInternal _TagListByCountRequest_default_instance_;
class TagSearchRequest;
struct TagSearchRequestDefaultTypeInternal;
extern TagSearchRequestDefaultTypeInternal _TagSearchRequest_default_instance_;
class TaskDataReply;
struct TaskDataReplyDefaultTypeInternal;
extern TaskDataReplyDefaultTypeInternal _TaskDataReply_default_instance_;
class TaskListRequest;
struct TaskListRequestDefaultTypeInternal;
extern TaskListRequestDefaultTypeInternal _TaskListRequest_default_instance_;
class TaskViewRequest;
struct TaskViewRequestDefaultTypeInternal;
extern TaskViewRequestDefaultTypeInternal _TaskViewRequest_default_instance_;
class TopicDataReply;
struct TopicDataReplyDefaultTypeInternal;
extern TopicDataReplyDefaultTypeInternal _TopicDataReply_default_instance_;
class TopicListTopicsRequest;
struct TopicListTopicsRequestDefaultTypeInternal;
extern TopicListTopicsRequestDefaultTypeInternal _TopicListTopicsRequest_default_instance_;
class TopicSearchRequest;
struct TopicSearchRequestDefaultTypeInternal;
extern TopicSearchRequestDefaultTypeInternal _TopicSearchRequest_default_instance_;
class TopicViewRequest;
struct TopicViewRequestDefaultTypeInternal;
extern TopicViewRequestDefaultTypeInternal _TopicViewRequest_default_instance_;
class UserAccessTokenReply;
struct UserAccessTokenReplyDefaultTypeInternal;
extern UserAccessTokenReplyDefaultTypeInternal _UserAccessTokenReply_default_instance_;
class UserCreateRequest;
struct UserCreateRequestDefaultTypeInternal;
extern UserCreateRequestDefaultTypeInternal _UserCreateRequest_default_instance_;
class UserDataReply;
struct UserDataReplyDefaultTypeInternal;
extern UserDataReplyDefaultTypeInternal _UserDataReply_default_instance_;
class UserFindByNameUIDRequest;
struct UserFindByNameUIDRequestDefaultTypeInternal;
extern UserFindByNameUIDRequestDefaultTypeInternal _UserFindByNameUIDRequest_default_instance_;
class UserFindByUUIDsRequest;
struct UserFindByUUIDsRequestDefaultTypeInternal;
extern UserFindByUUIDsRequestDefaultTypeInternal _UserFindByUUIDsRequest_default_instance_;
class UserGetAccessTokenRequest;
struct UserGetAccessTokenRequestDefaultTypeInternal;
extern UserGetAccessTokenRequestDefaultTypeInternal _UserGetAccessTokenRequest_default_instance_;
class UserGetRecentEPReply;
struct UserGetRecentEPReplyDefaultTypeInternal;
extern UserGetRecentEPReplyDefaultTypeInternal _UserGetRecentEPReply_default_instance_;
class UserGetRecentEPRequest;
struct UserGetRecentEPRequestDefaultTypeInternal;
extern UserGetRecentEPRequestDefaultTypeInternal _UserGetRecentEPRequest_default_instance_;
class UserListAllRequest;
struct UserListAllRequestDefaultTypeInternal;
extern UserListAllRequestDefaultTypeInternal _UserListAllRequest_default_instance_;
class UserListCollabRequest;
struct UserListCollabRequestDefaultTypeInternal;
extern UserListCollabRequestDefaultTypeInternal _UserListCollabRequest_default_instance_;
class UserSetAccessTokenRequest;
struct UserSetAccessTokenRequestDefaultTypeInternal;
extern UserSetAccessTokenRequestDefaultTypeInternal _UserSetAccessTokenRequest_default_instance_;
class UserSetRecentEPRequest;
struct UserSetRecentEPRequestDefaultTypeInternal;
extern UserSetRecentEPRequestDefaultTypeInternal _UserSetRecentEPRequest_default_instance_;
class UserUpdateRequest;
struct UserUpdateRequestDefaultTypeInternal;
extern UserUpdateRequestDefaultTypeInternal _UserUpdateRequest_default_instance_;
class UserViewRequest;
struct UserViewRequestDefaultTypeInternal;
extern UserViewRequestDefaultTypeInternal _UserViewRequest_default_instance_;
}  // namespace Auth
}  // namespace SDMS
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace SDMS {
namespace Auth {
enum Protocol : int {
  ID = 2,
};

bool Protocol_IsValid(int value);
extern const uint32_t Protocol_internal_data_[];
constexpr Protocol Protocol_MIN = static_cast<Protocol>(2);
constexpr Protocol Protocol_MAX = static_cast<Protocol>(2);
constexpr int Protocol_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Protocol_descriptor();
template <typename T>
const std::string& Protocol_Name(T value) {
  static_assert(std::is_same<T, Protocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Protocol_Name().");
  return Protocol_Name(static_cast<Protocol>(value));
}
template <>
inline const std::string& Protocol_Name(Protocol value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Protocol_descriptor,
                                                 2, 2>(
      static_cast<int>(value));
}
inline bool Protocol_Parse(absl::string_view name, Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Protocol>(
      Protocol_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UserViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserViewRequest) */ {
 public:
  inline UserViewRequest() : UserViewRequest(nullptr) {}
  ~UserViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserViewRequest(const UserViewRequest& from)
      : UserViewRequest(nullptr, from) {}
  UserViewRequest(UserViewRequest&& from) noexcept
    : UserViewRequest() {
    *this = ::std::move(from);
  }

  inline UserViewRequest& operator=(const UserViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserViewRequest& operator=(UserViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserViewRequest* internal_default_instance() {
    return reinterpret_cast<const UserViewRequest*>(
               &_UserViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserViewRequest& a, UserViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserViewRequest& from) {
    UserViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserViewRequest";
  }
  protected:
  explicit UserViewRequest(::google::protobuf::Arena* arena);
  UserViewRequest(::google::protobuf::Arena* arena, const UserViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kDetailsFieldNumber = 2,
  };
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // optional bool details = 2;
  bool has_details() const;
  void clear_details() ;
  bool details() const;
  void set_details(bool value);

  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    bool details_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserUpdateRequest) */ {
 public:
  inline UserUpdateRequest() : UserUpdateRequest(nullptr) {}
  ~UserUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserUpdateRequest(const UserUpdateRequest& from)
      : UserUpdateRequest(nullptr, from) {}
  UserUpdateRequest(UserUpdateRequest&& from) noexcept
    : UserUpdateRequest() {
    *this = ::std::move(from);
  }

  inline UserUpdateRequest& operator=(const UserUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserUpdateRequest& operator=(UserUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UserUpdateRequest*>(
               &_UserUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UserUpdateRequest& a, UserUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserUpdateRequest& from) {
    UserUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserUpdateRequest";
  }
  protected:
  explicit UserUpdateRequest(::google::protobuf::Arena* arena);
  UserUpdateRequest(::google::protobuf::Arena* arena, const UserUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kEmailFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kOptionsFieldNumber = 4,
  };
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // optional string email = 2;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // optional string password = 3;
  bool has_password() const;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // optional string options = 4;
  bool has_options() const;
  void clear_options() ;
  const std::string& options() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_options(Arg_&& arg, Args_... args);
  std::string* mutable_options();
  PROTOBUF_NODISCARD std::string* release_options();
  void set_allocated_options(std::string* value);

  private:
  const std::string& _internal_options() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_options(
      const std::string& value);
  std::string* _internal_mutable_options();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr options_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserSetRecentEPRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserSetRecentEPRequest) */ {
 public:
  inline UserSetRecentEPRequest() : UserSetRecentEPRequest(nullptr) {}
  ~UserSetRecentEPRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSetRecentEPRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserSetRecentEPRequest(const UserSetRecentEPRequest& from)
      : UserSetRecentEPRequest(nullptr, from) {}
  UserSetRecentEPRequest(UserSetRecentEPRequest&& from) noexcept
    : UserSetRecentEPRequest() {
    *this = ::std::move(from);
  }

  inline UserSetRecentEPRequest& operator=(const UserSetRecentEPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSetRecentEPRequest& operator=(UserSetRecentEPRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSetRecentEPRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSetRecentEPRequest* internal_default_instance() {
    return reinterpret_cast<const UserSetRecentEPRequest*>(
               &_UserSetRecentEPRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UserSetRecentEPRequest& a, UserSetRecentEPRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSetRecentEPRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSetRecentEPRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSetRecentEPRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSetRecentEPRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSetRecentEPRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSetRecentEPRequest& from) {
    UserSetRecentEPRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserSetRecentEPRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserSetRecentEPRequest";
  }
  protected:
  explicit UserSetRecentEPRequest(::google::protobuf::Arena* arena);
  UserSetRecentEPRequest(::google::protobuf::Arena* arena, const UserSetRecentEPRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpFieldNumber = 1,
  };
  // repeated string ep = 1;
  int ep_size() const;
  private:
  int _internal_ep_size() const;

  public:
  void clear_ep() ;
  const std::string& ep(int index) const;
  std::string* mutable_ep(int index);
  void set_ep(int index, const std::string& value);
  void set_ep(int index, std::string&& value);
  void set_ep(int index, const char* value);
  void set_ep(int index, const char* value, std::size_t size);
  void set_ep(int index, absl::string_view value);
  std::string* add_ep();
  void add_ep(const std::string& value);
  void add_ep(std::string&& value);
  void add_ep(const char* value);
  void add_ep(const char* value, std::size_t size);
  void add_ep(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& ep() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_ep();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_ep() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_ep();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserSetRecentEPRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> ep_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserSetAccessTokenRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserSetAccessTokenRequest) */ {
 public:
  inline UserSetAccessTokenRequest() : UserSetAccessTokenRequest(nullptr) {}
  ~UserSetAccessTokenRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSetAccessTokenRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserSetAccessTokenRequest(const UserSetAccessTokenRequest& from)
      : UserSetAccessTokenRequest(nullptr, from) {}
  UserSetAccessTokenRequest(UserSetAccessTokenRequest&& from) noexcept
    : UserSetAccessTokenRequest() {
    *this = ::std::move(from);
  }

  inline UserSetAccessTokenRequest& operator=(const UserSetAccessTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSetAccessTokenRequest& operator=(UserSetAccessTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSetAccessTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSetAccessTokenRequest* internal_default_instance() {
    return reinterpret_cast<const UserSetAccessTokenRequest*>(
               &_UserSetAccessTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserSetAccessTokenRequest& a, UserSetAccessTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSetAccessTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSetAccessTokenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSetAccessTokenRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSetAccessTokenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSetAccessTokenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSetAccessTokenRequest& from) {
    UserSetAccessTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserSetAccessTokenRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserSetAccessTokenRequest";
  }
  protected:
  explicit UserSetAccessTokenRequest(::google::protobuf::Arena* arena);
  UserSetAccessTokenRequest(::google::protobuf::Arena* arena, const UserSetAccessTokenRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessFieldNumber = 1,
    kRefreshFieldNumber = 3,
    kExpiresInFieldNumber = 2,
  };
  // required string access = 1;
  bool has_access() const;
  void clear_access() ;
  const std::string& access() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access(Arg_&& arg, Args_... args);
  std::string* mutable_access();
  PROTOBUF_NODISCARD std::string* release_access();
  void set_allocated_access(std::string* value);

  private:
  const std::string& _internal_access() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access(
      const std::string& value);
  std::string* _internal_mutable_access();

  public:
  // required string refresh = 3;
  bool has_refresh() const;
  void clear_refresh() ;
  const std::string& refresh() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_refresh(Arg_&& arg, Args_... args);
  std::string* mutable_refresh();
  PROTOBUF_NODISCARD std::string* release_refresh();
  void set_allocated_refresh(std::string* value);

  private:
  const std::string& _internal_refresh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh(
      const std::string& value);
  std::string* _internal_mutable_refresh();

  public:
  // required uint32 expires_in = 2;
  bool has_expires_in() const;
  void clear_expires_in() ;
  ::uint32_t expires_in() const;
  void set_expires_in(::uint32_t value);

  private:
  ::uint32_t _internal_expires_in() const;
  void _internal_set_expires_in(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserSetAccessTokenRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr access_;
    ::google::protobuf::internal::ArenaStringPtr refresh_;
    ::uint32_t expires_in_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserListCollabRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserListCollabRequest) */ {
 public:
  inline UserListCollabRequest() : UserListCollabRequest(nullptr) {}
  ~UserListCollabRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserListCollabRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserListCollabRequest(const UserListCollabRequest& from)
      : UserListCollabRequest(nullptr, from) {}
  UserListCollabRequest(UserListCollabRequest&& from) noexcept
    : UserListCollabRequest() {
    *this = ::std::move(from);
  }

  inline UserListCollabRequest& operator=(const UserListCollabRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListCollabRequest& operator=(UserListCollabRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserListCollabRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListCollabRequest* internal_default_instance() {
    return reinterpret_cast<const UserListCollabRequest*>(
               &_UserListCollabRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UserListCollabRequest& a, UserListCollabRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListCollabRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListCollabRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserListCollabRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserListCollabRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserListCollabRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserListCollabRequest& from) {
    UserListCollabRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserListCollabRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserListCollabRequest";
  }
  protected:
  explicit UserListCollabRequest(::google::protobuf::Arena* arena);
  UserListCollabRequest(::google::protobuf::Arena* arena, const UserListCollabRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional uint32 offset = 1;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserListCollabRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserListAllRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserListAllRequest) */ {
 public:
  inline UserListAllRequest() : UserListAllRequest(nullptr) {}
  ~UserListAllRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserListAllRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserListAllRequest(const UserListAllRequest& from)
      : UserListAllRequest(nullptr, from) {}
  UserListAllRequest(UserListAllRequest&& from) noexcept
    : UserListAllRequest() {
    *this = ::std::move(from);
  }

  inline UserListAllRequest& operator=(const UserListAllRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListAllRequest& operator=(UserListAllRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserListAllRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListAllRequest* internal_default_instance() {
    return reinterpret_cast<const UserListAllRequest*>(
               &_UserListAllRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UserListAllRequest& a, UserListAllRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListAllRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListAllRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserListAllRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserListAllRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserListAllRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserListAllRequest& from) {
    UserListAllRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserListAllRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserListAllRequest";
  }
  protected:
  explicit UserListAllRequest(::google::protobuf::Arena* arena);
  UserListAllRequest(::google::protobuf::Arena* arena, const UserListAllRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional uint32 offset = 1;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserListAllRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserGetRecentEPRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserGetRecentEPRequest) */ {
 public:
  inline UserGetRecentEPRequest() : UserGetRecentEPRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserGetRecentEPRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserGetRecentEPRequest(const UserGetRecentEPRequest& from)
      : UserGetRecentEPRequest(nullptr, from) {}
  UserGetRecentEPRequest(UserGetRecentEPRequest&& from) noexcept
    : UserGetRecentEPRequest() {
    *this = ::std::move(from);
  }

  inline UserGetRecentEPRequest& operator=(const UserGetRecentEPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserGetRecentEPRequest& operator=(UserGetRecentEPRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserGetRecentEPRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserGetRecentEPRequest* internal_default_instance() {
    return reinterpret_cast<const UserGetRecentEPRequest*>(
               &_UserGetRecentEPRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UserGetRecentEPRequest& a, UserGetRecentEPRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserGetRecentEPRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserGetRecentEPRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserGetRecentEPRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserGetRecentEPRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UserGetRecentEPRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UserGetRecentEPRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserGetRecentEPRequest";
  }
  protected:
  explicit UserGetRecentEPRequest(::google::protobuf::Arena* arena);
  UserGetRecentEPRequest(::google::protobuf::Arena* arena, const UserGetRecentEPRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserGetRecentEPRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserGetRecentEPReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserGetRecentEPReply) */ {
 public:
  inline UserGetRecentEPReply() : UserGetRecentEPReply(nullptr) {}
  ~UserGetRecentEPReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserGetRecentEPReply(::google::protobuf::internal::ConstantInitialized);

  inline UserGetRecentEPReply(const UserGetRecentEPReply& from)
      : UserGetRecentEPReply(nullptr, from) {}
  UserGetRecentEPReply(UserGetRecentEPReply&& from) noexcept
    : UserGetRecentEPReply() {
    *this = ::std::move(from);
  }

  inline UserGetRecentEPReply& operator=(const UserGetRecentEPReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserGetRecentEPReply& operator=(UserGetRecentEPReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserGetRecentEPReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserGetRecentEPReply* internal_default_instance() {
    return reinterpret_cast<const UserGetRecentEPReply*>(
               &_UserGetRecentEPReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UserGetRecentEPReply& a, UserGetRecentEPReply& b) {
    a.Swap(&b);
  }
  inline void Swap(UserGetRecentEPReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserGetRecentEPReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserGetRecentEPReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserGetRecentEPReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserGetRecentEPReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserGetRecentEPReply& from) {
    UserGetRecentEPReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserGetRecentEPReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserGetRecentEPReply";
  }
  protected:
  explicit UserGetRecentEPReply(::google::protobuf::Arena* arena);
  UserGetRecentEPReply(::google::protobuf::Arena* arena, const UserGetRecentEPReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpFieldNumber = 1,
  };
  // repeated string ep = 1;
  int ep_size() const;
  private:
  int _internal_ep_size() const;

  public:
  void clear_ep() ;
  const std::string& ep(int index) const;
  std::string* mutable_ep(int index);
  void set_ep(int index, const std::string& value);
  void set_ep(int index, std::string&& value);
  void set_ep(int index, const char* value);
  void set_ep(int index, const char* value, std::size_t size);
  void set_ep(int index, absl::string_view value);
  std::string* add_ep();
  void add_ep(const std::string& value);
  void add_ep(std::string&& value);
  void add_ep(const char* value);
  void add_ep(const char* value, std::size_t size);
  void add_ep(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& ep() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_ep();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_ep() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_ep();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserGetRecentEPReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> ep_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserGetAccessTokenRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserGetAccessTokenRequest) */ {
 public:
  inline UserGetAccessTokenRequest() : UserGetAccessTokenRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserGetAccessTokenRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserGetAccessTokenRequest(const UserGetAccessTokenRequest& from)
      : UserGetAccessTokenRequest(nullptr, from) {}
  UserGetAccessTokenRequest(UserGetAccessTokenRequest&& from) noexcept
    : UserGetAccessTokenRequest() {
    *this = ::std::move(from);
  }

  inline UserGetAccessTokenRequest& operator=(const UserGetAccessTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserGetAccessTokenRequest& operator=(UserGetAccessTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserGetAccessTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserGetAccessTokenRequest* internal_default_instance() {
    return reinterpret_cast<const UserGetAccessTokenRequest*>(
               &_UserGetAccessTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserGetAccessTokenRequest& a, UserGetAccessTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserGetAccessTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserGetAccessTokenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserGetAccessTokenRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserGetAccessTokenRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UserGetAccessTokenRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UserGetAccessTokenRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserGetAccessTokenRequest";
  }
  protected:
  explicit UserGetAccessTokenRequest(::google::protobuf::Arena* arena);
  UserGetAccessTokenRequest(::google::protobuf::Arena* arena, const UserGetAccessTokenRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserGetAccessTokenRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserFindByUUIDsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserFindByUUIDsRequest) */ {
 public:
  inline UserFindByUUIDsRequest() : UserFindByUUIDsRequest(nullptr) {}
  ~UserFindByUUIDsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserFindByUUIDsRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserFindByUUIDsRequest(const UserFindByUUIDsRequest& from)
      : UserFindByUUIDsRequest(nullptr, from) {}
  UserFindByUUIDsRequest(UserFindByUUIDsRequest&& from) noexcept
    : UserFindByUUIDsRequest() {
    *this = ::std::move(from);
  }

  inline UserFindByUUIDsRequest& operator=(const UserFindByUUIDsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserFindByUUIDsRequest& operator=(UserFindByUUIDsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserFindByUUIDsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserFindByUUIDsRequest* internal_default_instance() {
    return reinterpret_cast<const UserFindByUUIDsRequest*>(
               &_UserFindByUUIDsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UserFindByUUIDsRequest& a, UserFindByUUIDsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserFindByUUIDsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserFindByUUIDsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserFindByUUIDsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserFindByUUIDsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserFindByUUIDsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserFindByUUIDsRequest& from) {
    UserFindByUUIDsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserFindByUUIDsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserFindByUUIDsRequest";
  }
  protected:
  explicit UserFindByUUIDsRequest(::google::protobuf::Arena* arena);
  UserFindByUUIDsRequest(::google::protobuf::Arena* arena, const UserFindByUUIDsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
  };
  // repeated string uuid = 1;
  int uuid_size() const;
  private:
  int _internal_uuid_size() const;

  public:
  void clear_uuid() ;
  const std::string& uuid(int index) const;
  std::string* mutable_uuid(int index);
  void set_uuid(int index, const std::string& value);
  void set_uuid(int index, std::string&& value);
  void set_uuid(int index, const char* value);
  void set_uuid(int index, const char* value, std::size_t size);
  void set_uuid(int index, absl::string_view value);
  std::string* add_uuid();
  void add_uuid(const std::string& value);
  void add_uuid(std::string&& value);
  void add_uuid(const char* value);
  void add_uuid(const char* value, std::size_t size);
  void add_uuid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& uuid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_uuid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_uuid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_uuid();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserFindByUUIDsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> uuid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserFindByNameUIDRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserFindByNameUIDRequest) */ {
 public:
  inline UserFindByNameUIDRequest() : UserFindByNameUIDRequest(nullptr) {}
  ~UserFindByNameUIDRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserFindByNameUIDRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserFindByNameUIDRequest(const UserFindByNameUIDRequest& from)
      : UserFindByNameUIDRequest(nullptr, from) {}
  UserFindByNameUIDRequest(UserFindByNameUIDRequest&& from) noexcept
    : UserFindByNameUIDRequest() {
    *this = ::std::move(from);
  }

  inline UserFindByNameUIDRequest& operator=(const UserFindByNameUIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserFindByNameUIDRequest& operator=(UserFindByNameUIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserFindByNameUIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserFindByNameUIDRequest* internal_default_instance() {
    return reinterpret_cast<const UserFindByNameUIDRequest*>(
               &_UserFindByNameUIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UserFindByNameUIDRequest& a, UserFindByNameUIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserFindByNameUIDRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserFindByNameUIDRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserFindByNameUIDRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserFindByNameUIDRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserFindByNameUIDRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserFindByNameUIDRequest& from) {
    UserFindByNameUIDRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserFindByNameUIDRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserFindByNameUIDRequest";
  }
  protected:
  explicit UserFindByNameUIDRequest(::google::protobuf::Arena* arena);
  UserFindByNameUIDRequest(::google::protobuf::Arena* arena, const UserFindByNameUIDRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameUidFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // required string name_uid = 1;
  bool has_name_uid() const;
  void clear_name_uid() ;
  const std::string& name_uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name_uid(Arg_&& arg, Args_... args);
  std::string* mutable_name_uid();
  PROTOBUF_NODISCARD std::string* release_name_uid();
  void set_allocated_name_uid(std::string* value);

  private:
  const std::string& _internal_name_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_uid(
      const std::string& value);
  std::string* _internal_mutable_name_uid();

  public:
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserFindByNameUIDRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_uid_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserCreateRequest) */ {
 public:
  inline UserCreateRequest() : UserCreateRequest(nullptr) {}
  ~UserCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserCreateRequest(const UserCreateRequest& from)
      : UserCreateRequest(nullptr, from) {}
  UserCreateRequest(UserCreateRequest&& from) noexcept
    : UserCreateRequest() {
    *this = ::std::move(from);
  }

  inline UserCreateRequest& operator=(const UserCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserCreateRequest& operator=(UserCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserCreateRequest* internal_default_instance() {
    return reinterpret_cast<const UserCreateRequest*>(
               &_UserCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UserCreateRequest& a, UserCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserCreateRequest& from) {
    UserCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserCreateRequest";
  }
  protected:
  explicit UserCreateRequest(::google::protobuf::Arena* arena);
  UserCreateRequest(::google::protobuf::Arena* arena, const UserCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 5,
    kUidFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kNameFieldNumber = 3,
    kEmailFieldNumber = 4,
    kOptionsFieldNumber = 6,
    kSecretFieldNumber = 7,
  };
  // repeated string uuid = 5;
  int uuid_size() const;
  private:
  int _internal_uuid_size() const;

  public:
  void clear_uuid() ;
  const std::string& uuid(int index) const;
  std::string* mutable_uuid(int index);
  void set_uuid(int index, const std::string& value);
  void set_uuid(int index, std::string&& value);
  void set_uuid(int index, const char* value);
  void set_uuid(int index, const char* value, std::size_t size);
  void set_uuid(int index, absl::string_view value);
  std::string* add_uuid();
  void add_uuid(const std::string& value);
  void add_uuid(std::string&& value);
  void add_uuid(const char* value);
  void add_uuid(const char* value, std::size_t size);
  void add_uuid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& uuid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_uuid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_uuid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_uuid();

  public:
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // optional string password = 2;
  bool has_password() const;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // required string name = 3;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required string email = 4;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // optional string options = 6;
  bool has_options() const;
  void clear_options() ;
  const std::string& options() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_options(Arg_&& arg, Args_... args);
  std::string* mutable_options();
  PROTOBUF_NODISCARD std::string* release_options();
  void set_allocated_options(std::string* value);

  private:
  const std::string& _internal_options() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_options(
      const std::string& value);
  std::string* _internal_mutable_options();

  public:
  // required string secret = 7;
  bool has_secret() const;
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> uuid_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr options_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserAccessTokenReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserAccessTokenReply) */ {
 public:
  inline UserAccessTokenReply() : UserAccessTokenReply(nullptr) {}
  ~UserAccessTokenReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserAccessTokenReply(::google::protobuf::internal::ConstantInitialized);

  inline UserAccessTokenReply(const UserAccessTokenReply& from)
      : UserAccessTokenReply(nullptr, from) {}
  UserAccessTokenReply(UserAccessTokenReply&& from) noexcept
    : UserAccessTokenReply() {
    *this = ::std::move(from);
  }

  inline UserAccessTokenReply& operator=(const UserAccessTokenReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAccessTokenReply& operator=(UserAccessTokenReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAccessTokenReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAccessTokenReply* internal_default_instance() {
    return reinterpret_cast<const UserAccessTokenReply*>(
               &_UserAccessTokenReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserAccessTokenReply& a, UserAccessTokenReply& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAccessTokenReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAccessTokenReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAccessTokenReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAccessTokenReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserAccessTokenReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserAccessTokenReply& from) {
    UserAccessTokenReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserAccessTokenReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserAccessTokenReply";
  }
  protected:
  explicit UserAccessTokenReply(::google::protobuf::Arena* arena);
  UserAccessTokenReply(::google::protobuf::Arena* arena, const UserAccessTokenReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessFieldNumber = 1,
    kExpiresInFieldNumber = 2,
  };
  // required string access = 1;
  bool has_access() const;
  void clear_access() ;
  const std::string& access() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access(Arg_&& arg, Args_... args);
  std::string* mutable_access();
  PROTOBUF_NODISCARD std::string* release_access();
  void set_allocated_access(std::string* value);

  private:
  const std::string& _internal_access() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access(
      const std::string& value);
  std::string* _internal_mutable_access();

  public:
  // required uint32 expires_in = 2;
  bool has_expires_in() const;
  void clear_expires_in() ;
  ::uint32_t expires_in() const;
  void set_expires_in(::uint32_t value);

  private:
  ::uint32_t _internal_expires_in() const;
  void _internal_set_expires_in(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserAccessTokenReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr access_;
    ::uint32_t expires_in_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TopicViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TopicViewRequest) */ {
 public:
  inline TopicViewRequest() : TopicViewRequest(nullptr) {}
  ~TopicViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TopicViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline TopicViewRequest(const TopicViewRequest& from)
      : TopicViewRequest(nullptr, from) {}
  TopicViewRequest(TopicViewRequest&& from) noexcept
    : TopicViewRequest() {
    *this = ::std::move(from);
  }

  inline TopicViewRequest& operator=(const TopicViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicViewRequest& operator=(TopicViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicViewRequest* internal_default_instance() {
    return reinterpret_cast<const TopicViewRequest*>(
               &_TopicViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(TopicViewRequest& a, TopicViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopicViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopicViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TopicViewRequest& from) {
    TopicViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopicViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TopicViewRequest";
  }
  protected:
  explicit TopicViewRequest(::google::protobuf::Arena* arena);
  TopicViewRequest(::google::protobuf::Arena* arena, const TopicViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TopicViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TopicSearchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TopicSearchRequest) */ {
 public:
  inline TopicSearchRequest() : TopicSearchRequest(nullptr) {}
  ~TopicSearchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TopicSearchRequest(::google::protobuf::internal::ConstantInitialized);

  inline TopicSearchRequest(const TopicSearchRequest& from)
      : TopicSearchRequest(nullptr, from) {}
  TopicSearchRequest(TopicSearchRequest&& from) noexcept
    : TopicSearchRequest() {
    *this = ::std::move(from);
  }

  inline TopicSearchRequest& operator=(const TopicSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicSearchRequest& operator=(TopicSearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicSearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicSearchRequest* internal_default_instance() {
    return reinterpret_cast<const TopicSearchRequest*>(
               &_TopicSearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(TopicSearchRequest& a, TopicSearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicSearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicSearchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicSearchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopicSearchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopicSearchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TopicSearchRequest& from) {
    TopicSearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopicSearchRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TopicSearchRequest";
  }
  protected:
  explicit TopicSearchRequest(::google::protobuf::Arena* arena);
  TopicSearchRequest(::google::protobuf::Arena* arena, const TopicSearchRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhraseFieldNumber = 1,
  };
  // optional string phrase = 1;
  bool has_phrase() const;
  void clear_phrase() ;
  const std::string& phrase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phrase(Arg_&& arg, Args_... args);
  std::string* mutable_phrase();
  PROTOBUF_NODISCARD std::string* release_phrase();
  void set_allocated_phrase(std::string* value);

  private:
  const std::string& _internal_phrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phrase(
      const std::string& value);
  std::string* _internal_mutable_phrase();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TopicSearchRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phrase_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TopicListTopicsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TopicListTopicsRequest) */ {
 public:
  inline TopicListTopicsRequest() : TopicListTopicsRequest(nullptr) {}
  ~TopicListTopicsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TopicListTopicsRequest(::google::protobuf::internal::ConstantInitialized);

  inline TopicListTopicsRequest(const TopicListTopicsRequest& from)
      : TopicListTopicsRequest(nullptr, from) {}
  TopicListTopicsRequest(TopicListTopicsRequest&& from) noexcept
    : TopicListTopicsRequest() {
    *this = ::std::move(from);
  }

  inline TopicListTopicsRequest& operator=(const TopicListTopicsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicListTopicsRequest& operator=(TopicListTopicsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicListTopicsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicListTopicsRequest* internal_default_instance() {
    return reinterpret_cast<const TopicListTopicsRequest*>(
               &_TopicListTopicsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(TopicListTopicsRequest& a, TopicListTopicsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicListTopicsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicListTopicsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicListTopicsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopicListTopicsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopicListTopicsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TopicListTopicsRequest& from) {
    TopicListTopicsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopicListTopicsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TopicListTopicsRequest";
  }
  protected:
  explicit TopicListTopicsRequest(::google::protobuf::Arena* arena);
  TopicListTopicsRequest(::google::protobuf::Arena* arena, const TopicListTopicsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicIdFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // optional string topic_id = 1;
  bool has_topic_id() const;
  void clear_topic_id() ;
  const std::string& topic_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic_id(Arg_&& arg, Args_... args);
  std::string* mutable_topic_id();
  PROTOBUF_NODISCARD std::string* release_topic_id();
  void set_allocated_topic_id(std::string* value);

  private:
  const std::string& _internal_topic_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic_id(
      const std::string& value);
  std::string* _internal_mutable_topic_id();

  public:
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TopicListTopicsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr topic_id_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TaskViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TaskViewRequest) */ {
 public:
  inline TaskViewRequest() : TaskViewRequest(nullptr) {}
  ~TaskViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline TaskViewRequest(const TaskViewRequest& from)
      : TaskViewRequest(nullptr, from) {}
  TaskViewRequest(TaskViewRequest&& from) noexcept
    : TaskViewRequest() {
    *this = ::std::move(from);
  }

  inline TaskViewRequest& operator=(const TaskViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskViewRequest& operator=(TaskViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskViewRequest* internal_default_instance() {
    return reinterpret_cast<const TaskViewRequest*>(
               &_TaskViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(TaskViewRequest& a, TaskViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TaskViewRequest& from) {
    TaskViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TaskViewRequest";
  }
  protected:
  explicit TaskViewRequest(::google::protobuf::Arena* arena);
  TaskViewRequest(::google::protobuf::Arena* arena, const TaskViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
  };
  // required string task_id = 1;
  bool has_task_id() const;
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TaskViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TaskListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TaskListRequest) */ {
 public:
  inline TaskListRequest() : TaskListRequest(nullptr) {}
  ~TaskListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskListRequest(::google::protobuf::internal::ConstantInitialized);

  inline TaskListRequest(const TaskListRequest& from)
      : TaskListRequest(nullptr, from) {}
  TaskListRequest(TaskListRequest&& from) noexcept
    : TaskListRequest() {
    *this = ::std::move(from);
  }

  inline TaskListRequest& operator=(const TaskListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskListRequest& operator=(TaskListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskListRequest* internal_default_instance() {
    return reinterpret_cast<const TaskListRequest*>(
               &_TaskListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(TaskListRequest& a, TaskListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskListRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskListRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskListRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TaskListRequest& from) {
    TaskListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskListRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TaskListRequest";
  }
  protected:
  explicit TaskListRequest(::google::protobuf::Arena* arena);
  TaskListRequest(::google::protobuf::Arena* arena, const TaskListRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 4,
    kSinceFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kOffsetFieldNumber = 5,
    kCountFieldNumber = 6,
  };
  // repeated .SDMS.TaskStatus status = 4;
  int status_size() const;
  private:
  int _internal_status_size() const;

  public:
  void clear_status() ;
  public:
  ::SDMS::TaskStatus status(int index) const;
  void set_status(int index, ::SDMS::TaskStatus value);
  void add_status(::SDMS::TaskStatus value);
  const ::google::protobuf::RepeatedField<int>& status() const;
  ::google::protobuf::RepeatedField<int>* mutable_status();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_status() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_status();

  public:
  // optional uint32 since = 1;
  bool has_since() const;
  void clear_since() ;
  ::uint32_t since() const;
  void set_since(::uint32_t value);

  private:
  ::uint32_t _internal_since() const;
  void _internal_set_since(::uint32_t value);

  public:
  // optional uint32 from = 2;
  bool has_from() const;
  void clear_from() ;
  ::uint32_t from() const;
  void set_from(::uint32_t value);

  private:
  ::uint32_t _internal_from() const;
  void _internal_set_from(::uint32_t value);

  public:
  // optional uint32 to = 3;
  bool has_to() const;
  void clear_to() ;
  ::uint32_t to() const;
  void set_to(::uint32_t value);

  private:
  ::uint32_t _internal_to() const;
  void _internal_set_to(::uint32_t value);

  public:
  // optional uint32 offset = 5;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 6;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TaskListRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> status_;
    ::uint32_t since_;
    ::uint32_t from_;
    ::uint32_t to_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TagSearchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TagSearchRequest) */ {
 public:
  inline TagSearchRequest() : TagSearchRequest(nullptr) {}
  ~TagSearchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TagSearchRequest(::google::protobuf::internal::ConstantInitialized);

  inline TagSearchRequest(const TagSearchRequest& from)
      : TagSearchRequest(nullptr, from) {}
  TagSearchRequest(TagSearchRequest&& from) noexcept
    : TagSearchRequest() {
    *this = ::std::move(from);
  }

  inline TagSearchRequest& operator=(const TagSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagSearchRequest& operator=(TagSearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagSearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagSearchRequest* internal_default_instance() {
    return reinterpret_cast<const TagSearchRequest*>(
               &_TagSearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(TagSearchRequest& a, TagSearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TagSearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagSearchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagSearchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagSearchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TagSearchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TagSearchRequest& from) {
    TagSearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TagSearchRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TagSearchRequest";
  }
  protected:
  explicit TagSearchRequest(::google::protobuf::Arena* arena);
  TagSearchRequest(::google::protobuf::Arena* arena, const TagSearchRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TagSearchRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TagListByCountRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TagListByCountRequest) */ {
 public:
  inline TagListByCountRequest() : TagListByCountRequest(nullptr) {}
  ~TagListByCountRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TagListByCountRequest(::google::protobuf::internal::ConstantInitialized);

  inline TagListByCountRequest(const TagListByCountRequest& from)
      : TagListByCountRequest(nullptr, from) {}
  TagListByCountRequest(TagListByCountRequest&& from) noexcept
    : TagListByCountRequest() {
    *this = ::std::move(from);
  }

  inline TagListByCountRequest& operator=(const TagListByCountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagListByCountRequest& operator=(TagListByCountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagListByCountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagListByCountRequest* internal_default_instance() {
    return reinterpret_cast<const TagListByCountRequest*>(
               &_TagListByCountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(TagListByCountRequest& a, TagListByCountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TagListByCountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagListByCountRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagListByCountRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagListByCountRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TagListByCountRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TagListByCountRequest& from) {
    TagListByCountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TagListByCountRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TagListByCountRequest";
  }
  protected:
  explicit TagListByCountRequest(::google::protobuf::Arena* arena);
  TagListByCountRequest(::google::protobuf::Arena* arena, const TagListByCountRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional uint32 offset = 1;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TagListByCountRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class SearchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.SearchRequest) */ {
 public:
  inline SearchRequest() : SearchRequest(nullptr) {}
  ~SearchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SearchRequest(::google::protobuf::internal::ConstantInitialized);

  inline SearchRequest(const SearchRequest& from)
      : SearchRequest(nullptr, from) {}
  SearchRequest(SearchRequest&& from) noexcept
    : SearchRequest() {
    *this = ::std::move(from);
  }

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
               &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(SearchRequest& a, SearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SearchRequest& from) {
    SearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SearchRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.SearchRequest";
  }
  protected:
  explicit SearchRequest(::google::protobuf::Arena* arena);
  SearchRequest(::google::protobuf::Arena* arena, const SearchRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 5,
    kCatTagsFieldNumber = 6,
    kCollFieldNumber = 11,
    kIdFieldNumber = 3,
    kTextFieldNumber = 4,
    kOwnerFieldNumber = 9,
    kCreatorFieldNumber = 10,
    kSchIdFieldNumber = 12,
    kMetaFieldNumber = 13,
    kModeFieldNumber = 1,
    kFromFieldNumber = 7,
    kToFieldNumber = 8,
    kPublishedFieldNumber = 2,
    kMetaErrFieldNumber = 14,
    kSortRevFieldNumber = 16,
    kSortFieldNumber = 15,
    kOffsetFieldNumber = 17,
    kCountFieldNumber = 18,
  };
  // repeated string tags = 5;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // repeated string cat_tags = 6;
  int cat_tags_size() const;
  private:
  int _internal_cat_tags_size() const;

  public:
  void clear_cat_tags() ;
  const std::string& cat_tags(int index) const;
  std::string* mutable_cat_tags(int index);
  void set_cat_tags(int index, const std::string& value);
  void set_cat_tags(int index, std::string&& value);
  void set_cat_tags(int index, const char* value);
  void set_cat_tags(int index, const char* value, std::size_t size);
  void set_cat_tags(int index, absl::string_view value);
  std::string* add_cat_tags();
  void add_cat_tags(const std::string& value);
  void add_cat_tags(std::string&& value);
  void add_cat_tags(const char* value);
  void add_cat_tags(const char* value, std::size_t size);
  void add_cat_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& cat_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cat_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cat_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cat_tags();

  public:
  // repeated string coll = 11;
  int coll_size() const;
  private:
  int _internal_coll_size() const;

  public:
  void clear_coll() ;
  const std::string& coll(int index) const;
  std::string* mutable_coll(int index);
  void set_coll(int index, const std::string& value);
  void set_coll(int index, std::string&& value);
  void set_coll(int index, const char* value);
  void set_coll(int index, const char* value, std::size_t size);
  void set_coll(int index, absl::string_view value);
  std::string* add_coll();
  void add_coll(const std::string& value);
  void add_coll(std::string&& value);
  void add_coll(const char* value);
  void add_coll(const char* value, std::size_t size);
  void add_coll(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& coll() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_coll();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_coll() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_coll();

  public:
  // optional string id = 3;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string text = 4;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // optional string owner = 9;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* value);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // optional string creator = 10;
  bool has_creator() const;
  void clear_creator() ;
  const std::string& creator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* value);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // optional string sch_id = 12;
  bool has_sch_id() const;
  void clear_sch_id() ;
  const std::string& sch_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sch_id(Arg_&& arg, Args_... args);
  std::string* mutable_sch_id();
  PROTOBUF_NODISCARD std::string* release_sch_id();
  void set_allocated_sch_id(std::string* value);

  private:
  const std::string& _internal_sch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sch_id(
      const std::string& value);
  std::string* _internal_mutable_sch_id();

  public:
  // optional string meta = 13;
  bool has_meta() const;
  void clear_meta() ;
  const std::string& meta() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_meta(Arg_&& arg, Args_... args);
  std::string* mutable_meta();
  PROTOBUF_NODISCARD std::string* release_meta();
  void set_allocated_meta(std::string* value);

  private:
  const std::string& _internal_meta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meta(
      const std::string& value);
  std::string* _internal_mutable_meta();

  public:
  // required .SDMS.SearchMode mode = 1;
  bool has_mode() const;
  void clear_mode() ;
  ::SDMS::SearchMode mode() const;
  void set_mode(::SDMS::SearchMode value);

  private:
  ::SDMS::SearchMode _internal_mode() const;
  void _internal_set_mode(::SDMS::SearchMode value);

  public:
  // optional uint32 from = 7;
  bool has_from() const;
  void clear_from() ;
  ::uint32_t from() const;
  void set_from(::uint32_t value);

  private:
  ::uint32_t _internal_from() const;
  void _internal_set_from(::uint32_t value);

  public:
  // optional uint32 to = 8;
  bool has_to() const;
  void clear_to() ;
  ::uint32_t to() const;
  void set_to(::uint32_t value);

  private:
  ::uint32_t _internal_to() const;
  void _internal_set_to(::uint32_t value);

  public:
  // optional bool published = 2;
  bool has_published() const;
  void clear_published() ;
  bool published() const;
  void set_published(bool value);

  private:
  bool _internal_published() const;
  void _internal_set_published(bool value);

  public:
  // optional bool meta_err = 14;
  bool has_meta_err() const;
  void clear_meta_err() ;
  bool meta_err() const;
  void set_meta_err(bool value);

  private:
  bool _internal_meta_err() const;
  void _internal_set_meta_err(bool value);

  public:
  // optional bool sort_rev = 16;
  bool has_sort_rev() const;
  void clear_sort_rev() ;
  bool sort_rev() const;
  void set_sort_rev(bool value);

  private:
  bool _internal_sort_rev() const;
  void _internal_set_sort_rev(bool value);

  public:
  // optional .SDMS.SortOption sort = 15;
  bool has_sort() const;
  void clear_sort() ;
  ::SDMS::SortOption sort() const;
  void set_sort(::SDMS::SortOption value);

  private:
  ::SDMS::SortOption _internal_sort() const;
  void _internal_set_sort(::SDMS::SortOption value);

  public:
  // optional uint32 offset = 17;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 18;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.SearchRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 18, 2,
      92, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::RepeatedPtrField<std::string> cat_tags_;
    ::google::protobuf::RepeatedPtrField<std::string> coll_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    ::google::protobuf::internal::ArenaStringPtr creator_;
    ::google::protobuf::internal::ArenaStringPtr sch_id_;
    ::google::protobuf::internal::ArenaStringPtr meta_;
    int mode_;
    ::uint32_t from_;
    ::uint32_t to_;
    bool published_;
    bool meta_err_;
    bool sort_rev_;
    int sort_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class SchemaViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.SchemaViewRequest) */ {
 public:
  inline SchemaViewRequest() : SchemaViewRequest(nullptr) {}
  ~SchemaViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline SchemaViewRequest(const SchemaViewRequest& from)
      : SchemaViewRequest(nullptr, from) {}
  SchemaViewRequest(SchemaViewRequest&& from) noexcept
    : SchemaViewRequest() {
    *this = ::std::move(from);
  }

  inline SchemaViewRequest& operator=(const SchemaViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaViewRequest& operator=(SchemaViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaViewRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaViewRequest*>(
               &_SchemaViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(SchemaViewRequest& a, SchemaViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SchemaViewRequest& from) {
    SchemaViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SchemaViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.SchemaViewRequest";
  }
  protected:
  explicit SchemaViewRequest(::google::protobuf::Arena* arena);
  SchemaViewRequest(::google::protobuf::Arena* arena, const SchemaViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResolveFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional bool resolve = 2;
  bool has_resolve() const;
  void clear_resolve() ;
  bool resolve() const;
  void set_resolve(bool value);

  private:
  bool _internal_resolve() const;
  void _internal_set_resolve(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.SchemaViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    bool resolve_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class SchemaUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.SchemaUpdateRequest) */ {
 public:
  inline SchemaUpdateRequest() : SchemaUpdateRequest(nullptr) {}
  ~SchemaUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline SchemaUpdateRequest(const SchemaUpdateRequest& from)
      : SchemaUpdateRequest(nullptr, from) {}
  SchemaUpdateRequest(SchemaUpdateRequest&& from) noexcept
    : SchemaUpdateRequest() {
    *this = ::std::move(from);
  }

  inline SchemaUpdateRequest& operator=(const SchemaUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaUpdateRequest& operator=(SchemaUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaUpdateRequest*>(
               &_SchemaUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(SchemaUpdateRequest& a, SchemaUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SchemaUpdateRequest& from) {
    SchemaUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SchemaUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.SchemaUpdateRequest";
  }
  protected:
  explicit SchemaUpdateRequest(::google::protobuf::Arena* arena);
  SchemaUpdateRequest(::google::protobuf::Arena* arena, const SchemaUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIdNewFieldNumber = 2,
    kDescFieldNumber = 3,
    kDefFieldNumber = 6,
    kPubFieldNumber = 4,
    kSysFieldNumber = 5,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string id_new = 2;
  bool has_id_new() const;
  void clear_id_new() ;
  const std::string& id_new() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id_new(Arg_&& arg, Args_... args);
  std::string* mutable_id_new();
  PROTOBUF_NODISCARD std::string* release_id_new();
  void set_allocated_id_new(std::string* value);

  private:
  const std::string& _internal_id_new() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_new(
      const std::string& value);
  std::string* _internal_mutable_id_new();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string def = 6;
  bool has_def() const;
  void clear_def() ;
  const std::string& def() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_def(Arg_&& arg, Args_... args);
  std::string* mutable_def();
  PROTOBUF_NODISCARD std::string* release_def();
  void set_allocated_def(std::string* value);

  private:
  const std::string& _internal_def() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_def(
      const std::string& value);
  std::string* _internal_mutable_def();

  public:
  // optional bool pub = 4;
  bool has_pub() const;
  void clear_pub() ;
  bool pub() const;
  void set_pub(bool value);

  private:
  bool _internal_pub() const;
  void _internal_set_pub(bool value);

  public:
  // optional bool sys = 5;
  bool has_sys() const;
  void clear_sys() ;
  bool sys() const;
  void set_sys(bool value);

  private:
  bool _internal_sys() const;
  void _internal_set_sys(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.SchemaUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr id_new_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr def_;
    bool pub_;
    bool sys_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class SchemaSearchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.SchemaSearchRequest) */ {
 public:
  inline SchemaSearchRequest() : SchemaSearchRequest(nullptr) {}
  ~SchemaSearchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaSearchRequest(::google::protobuf::internal::ConstantInitialized);

  inline SchemaSearchRequest(const SchemaSearchRequest& from)
      : SchemaSearchRequest(nullptr, from) {}
  SchemaSearchRequest(SchemaSearchRequest&& from) noexcept
    : SchemaSearchRequest() {
    *this = ::std::move(from);
  }

  inline SchemaSearchRequest& operator=(const SchemaSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaSearchRequest& operator=(SchemaSearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaSearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaSearchRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaSearchRequest*>(
               &_SchemaSearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(SchemaSearchRequest& a, SchemaSearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaSearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaSearchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaSearchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaSearchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaSearchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SchemaSearchRequest& from) {
    SchemaSearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SchemaSearchRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.SchemaSearchRequest";
  }
  protected:
  explicit SchemaSearchRequest(::google::protobuf::Arena* arena);
  SchemaSearchRequest(::google::protobuf::Arena* arena, const SchemaSearchRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTextFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kSortFieldNumber = 4,
    kSortRevFieldNumber = 5,
    kOffsetFieldNumber = 6,
    kCountFieldNumber = 7,
  };
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string text = 2;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // optional string owner = 3;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* value);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // optional .SDMS.SortOption sort = 4;
  bool has_sort() const;
  void clear_sort() ;
  ::SDMS::SortOption sort() const;
  void set_sort(::SDMS::SortOption value);

  private:
  ::SDMS::SortOption _internal_sort() const;
  void _internal_set_sort(::SDMS::SortOption value);

  public:
  // optional bool sort_rev = 5;
  bool has_sort_rev() const;
  void clear_sort_rev() ;
  bool sort_rev() const;
  void set_sort_rev(bool value);

  private:
  bool _internal_sort_rev() const;
  void _internal_set_sort_rev(bool value);

  public:
  // optional uint32 offset = 6;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 7;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.SchemaSearchRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    int sort_;
    bool sort_rev_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class SchemaReviseRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.SchemaReviseRequest) */ {
 public:
  inline SchemaReviseRequest() : SchemaReviseRequest(nullptr) {}
  ~SchemaReviseRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaReviseRequest(::google::protobuf::internal::ConstantInitialized);

  inline SchemaReviseRequest(const SchemaReviseRequest& from)
      : SchemaReviseRequest(nullptr, from) {}
  SchemaReviseRequest(SchemaReviseRequest&& from) noexcept
    : SchemaReviseRequest() {
    *this = ::std::move(from);
  }

  inline SchemaReviseRequest& operator=(const SchemaReviseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaReviseRequest& operator=(SchemaReviseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaReviseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaReviseRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaReviseRequest*>(
               &_SchemaReviseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(SchemaReviseRequest& a, SchemaReviseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaReviseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaReviseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaReviseRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaReviseRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaReviseRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SchemaReviseRequest& from) {
    SchemaReviseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SchemaReviseRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.SchemaReviseRequest";
  }
  protected:
  explicit SchemaReviseRequest(::google::protobuf::Arena* arena);
  SchemaReviseRequest(::google::protobuf::Arena* arena, const SchemaReviseRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDescFieldNumber = 2,
    kDefFieldNumber = 5,
    kPubFieldNumber = 3,
    kSysFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string desc = 2;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string def = 5;
  bool has_def() const;
  void clear_def() ;
  const std::string& def() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_def(Arg_&& arg, Args_... args);
  std::string* mutable_def();
  PROTOBUF_NODISCARD std::string* release_def();
  void set_allocated_def(std::string* value);

  private:
  const std::string& _internal_def() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_def(
      const std::string& value);
  std::string* _internal_mutable_def();

  public:
  // optional bool pub = 3;
  bool has_pub() const;
  void clear_pub() ;
  bool pub() const;
  void set_pub(bool value);

  private:
  bool _internal_pub() const;
  void _internal_set_pub(bool value);

  public:
  // optional bool sys = 4;
  bool has_sys() const;
  void clear_sys() ;
  bool sys() const;
  void set_sys(bool value);

  private:
  bool _internal_sys() const;
  void _internal_set_sys(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.SchemaReviseRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr def_;
    bool pub_;
    bool sys_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class SchemaDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.SchemaDeleteRequest) */ {
 public:
  inline SchemaDeleteRequest() : SchemaDeleteRequest(nullptr) {}
  ~SchemaDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline SchemaDeleteRequest(const SchemaDeleteRequest& from)
      : SchemaDeleteRequest(nullptr, from) {}
  SchemaDeleteRequest(SchemaDeleteRequest&& from) noexcept
    : SchemaDeleteRequest() {
    *this = ::std::move(from);
  }

  inline SchemaDeleteRequest& operator=(const SchemaDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaDeleteRequest& operator=(SchemaDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaDeleteRequest*>(
               &_SchemaDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(SchemaDeleteRequest& a, SchemaDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SchemaDeleteRequest& from) {
    SchemaDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SchemaDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.SchemaDeleteRequest";
  }
  protected:
  explicit SchemaDeleteRequest(::google::protobuf::Arena* arena);
  SchemaDeleteRequest(::google::protobuf::Arena* arena, const SchemaDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.SchemaDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class SchemaCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.SchemaCreateRequest) */ {
 public:
  inline SchemaCreateRequest() : SchemaCreateRequest(nullptr) {}
  ~SchemaCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline SchemaCreateRequest(const SchemaCreateRequest& from)
      : SchemaCreateRequest(nullptr, from) {}
  SchemaCreateRequest(SchemaCreateRequest&& from) noexcept
    : SchemaCreateRequest() {
    *this = ::std::move(from);
  }

  inline SchemaCreateRequest& operator=(const SchemaCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaCreateRequest& operator=(SchemaCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaCreateRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaCreateRequest*>(
               &_SchemaCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(SchemaCreateRequest& a, SchemaCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SchemaCreateRequest& from) {
    SchemaCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SchemaCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.SchemaCreateRequest";
  }
  protected:
  explicit SchemaCreateRequest(::google::protobuf::Arena* arena);
  SchemaCreateRequest(::google::protobuf::Arena* arena, const SchemaCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDescFieldNumber = 2,
    kDefFieldNumber = 5,
    kPubFieldNumber = 3,
    kSysFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string desc = 2;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // required string def = 5;
  bool has_def() const;
  void clear_def() ;
  const std::string& def() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_def(Arg_&& arg, Args_... args);
  std::string* mutable_def();
  PROTOBUF_NODISCARD std::string* release_def();
  void set_allocated_def(std::string* value);

  private:
  const std::string& _internal_def() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_def(
      const std::string& value);
  std::string* _internal_mutable_def();

  public:
  // required bool pub = 3;
  bool has_pub() const;
  void clear_pub() ;
  bool pub() const;
  void set_pub(bool value);

  private:
  bool _internal_pub() const;
  void _internal_set_pub(bool value);

  public:
  // required bool sys = 4;
  bool has_sys() const;
  void clear_sys() ;
  bool sys() const;
  void set_sys(bool value);

  private:
  bool _internal_sys() const;
  void _internal_set_sys(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.SchemaCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr def_;
    bool pub_;
    bool sys_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RevokeCredentialsRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:SDMS.Auth.RevokeCredentialsRequest) */ {
 public:
  inline RevokeCredentialsRequest() : RevokeCredentialsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RevokeCredentialsRequest(::google::protobuf::internal::ConstantInitialized);

  inline RevokeCredentialsRequest(const RevokeCredentialsRequest& from)
      : RevokeCredentialsRequest(nullptr, from) {}
  RevokeCredentialsRequest(RevokeCredentialsRequest&& from) noexcept
    : RevokeCredentialsRequest() {
    *this = ::std::move(from);
  }

  inline RevokeCredentialsRequest& operator=(const RevokeCredentialsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokeCredentialsRequest& operator=(RevokeCredentialsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevokeCredentialsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevokeCredentialsRequest* internal_default_instance() {
    return reinterpret_cast<const RevokeCredentialsRequest*>(
               &_RevokeCredentialsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RevokeCredentialsRequest& a, RevokeCredentialsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokeCredentialsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevokeCredentialsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevokeCredentialsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevokeCredentialsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RevokeCredentialsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RevokeCredentialsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RevokeCredentialsRequest";
  }
  protected:
  explicit RevokeCredentialsRequest(::google::protobuf::Arena* arena);
  RevokeCredentialsRequest(::google::protobuf::Arena* arena, const RevokeCredentialsRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SDMS.Auth.RevokeCredentialsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoViewRequest) */ {
 public:
  inline RepoViewRequest() : RepoViewRequest(nullptr) {}
  ~RepoViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoViewRequest(const RepoViewRequest& from)
      : RepoViewRequest(nullptr, from) {}
  RepoViewRequest(RepoViewRequest&& from) noexcept
    : RepoViewRequest() {
    *this = ::std::move(from);
  }

  inline RepoViewRequest& operator=(const RepoViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoViewRequest& operator=(RepoViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoViewRequest* internal_default_instance() {
    return reinterpret_cast<const RepoViewRequest*>(
               &_RepoViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(RepoViewRequest& a, RepoViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoViewRequest& from) {
    RepoViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoViewRequest";
  }
  protected:
  explicit RepoViewRequest(::google::protobuf::Arena* arena);
  RepoViewRequest(::google::protobuf::Arena* arena, const RepoViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoViewAllocationRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoViewAllocationRequest) */ {
 public:
  inline RepoViewAllocationRequest() : RepoViewAllocationRequest(nullptr) {}
  ~RepoViewAllocationRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoViewAllocationRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoViewAllocationRequest(const RepoViewAllocationRequest& from)
      : RepoViewAllocationRequest(nullptr, from) {}
  RepoViewAllocationRequest(RepoViewAllocationRequest&& from) noexcept
    : RepoViewAllocationRequest() {
    *this = ::std::move(from);
  }

  inline RepoViewAllocationRequest& operator=(const RepoViewAllocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoViewAllocationRequest& operator=(RepoViewAllocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoViewAllocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoViewAllocationRequest* internal_default_instance() {
    return reinterpret_cast<const RepoViewAllocationRequest*>(
               &_RepoViewAllocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(RepoViewAllocationRequest& a, RepoViewAllocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoViewAllocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoViewAllocationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoViewAllocationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoViewAllocationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoViewAllocationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoViewAllocationRequest& from) {
    RepoViewAllocationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoViewAllocationRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoViewAllocationRequest";
  }
  protected:
  explicit RepoViewAllocationRequest(::google::protobuf::Arena* arena);
  RepoViewAllocationRequest(::google::protobuf::Arena* arena, const RepoViewAllocationRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kSubjectFieldNumber = 2,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // required string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoViewAllocationRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoUpdateRequest) */ {
 public:
  inline RepoUpdateRequest() : RepoUpdateRequest(nullptr) {}
  ~RepoUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoUpdateRequest(const RepoUpdateRequest& from)
      : RepoUpdateRequest(nullptr, from) {}
  RepoUpdateRequest(RepoUpdateRequest&& from) noexcept
    : RepoUpdateRequest() {
    *this = ::std::move(from);
  }

  inline RepoUpdateRequest& operator=(const RepoUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoUpdateRequest& operator=(RepoUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const RepoUpdateRequest*>(
               &_RepoUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(RepoUpdateRequest& a, RepoUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoUpdateRequest& from) {
    RepoUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoUpdateRequest";
  }
  protected:
  explicit RepoUpdateRequest(::google::protobuf::Arena* arena);
  RepoUpdateRequest(::google::protobuf::Arena* arena, const RepoUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminFieldNumber = 12,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 3,
    kDomainFieldNumber = 5,
    kPathFieldNumber = 6,
    kExpPathFieldNumber = 7,
    kAddressFieldNumber = 8,
    kEndpointFieldNumber = 9,
    kPubKeyFieldNumber = 10,
    kCapacityFieldNumber = 11,
  };
  // repeated string admin = 12;
  int admin_size() const;
  private:
  int _internal_admin_size() const;

  public:
  void clear_admin() ;
  const std::string& admin(int index) const;
  std::string* mutable_admin(int index);
  void set_admin(int index, const std::string& value);
  void set_admin(int index, std::string&& value);
  void set_admin(int index, const char* value);
  void set_admin(int index, const char* value, std::size_t size);
  void set_admin(int index, absl::string_view value);
  std::string* add_admin();
  void add_admin(const std::string& value);
  void add_admin(std::string&& value);
  void add_admin(const char* value);
  void add_admin(const char* value, std::size_t size);
  void add_admin(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_admin();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_admin();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string domain = 5;
  bool has_domain() const;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // optional string path = 6;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional string exp_path = 7;
  bool has_exp_path() const;
  void clear_exp_path() ;
  const std::string& exp_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_exp_path(Arg_&& arg, Args_... args);
  std::string* mutable_exp_path();
  PROTOBUF_NODISCARD std::string* release_exp_path();
  void set_allocated_exp_path(std::string* value);

  private:
  const std::string& _internal_exp_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exp_path(
      const std::string& value);
  std::string* _internal_mutable_exp_path();

  public:
  // optional string address = 8;
  bool has_address() const;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // optional string endpoint = 9;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const std::string& endpoint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* value);

  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(
      const std::string& value);
  std::string* _internal_mutable_endpoint();

  public:
  // optional string pub_key = 10;
  bool has_pub_key() const;
  void clear_pub_key() ;
  const std::string& pub_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pub_key(Arg_&& arg, Args_... args);
  std::string* mutable_pub_key();
  PROTOBUF_NODISCARD std::string* release_pub_key();
  void set_allocated_pub_key(std::string* value);

  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(
      const std::string& value);
  std::string* _internal_mutable_pub_key();

  public:
  // optional uint64 capacity = 11;
  bool has_capacity() const;
  void clear_capacity() ;
  ::uint64_t capacity() const;
  void set_capacity(::uint64_t value);

  private:
  ::uint64_t _internal_capacity() const;
  void _internal_set_capacity(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      100, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> admin_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr exp_path_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr endpoint_;
    ::google::protobuf::internal::ArenaStringPtr pub_key_;
    ::uint64_t capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoPathDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoPathDeleteRequest) */ {
 public:
  inline RepoPathDeleteRequest() : RepoPathDeleteRequest(nullptr) {}
  ~RepoPathDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoPathDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoPathDeleteRequest(const RepoPathDeleteRequest& from)
      : RepoPathDeleteRequest(nullptr, from) {}
  RepoPathDeleteRequest(RepoPathDeleteRequest&& from) noexcept
    : RepoPathDeleteRequest() {
    *this = ::std::move(from);
  }

  inline RepoPathDeleteRequest& operator=(const RepoPathDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoPathDeleteRequest& operator=(RepoPathDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoPathDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoPathDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const RepoPathDeleteRequest*>(
               &_RepoPathDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(RepoPathDeleteRequest& a, RepoPathDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoPathDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoPathDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoPathDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoPathDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoPathDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoPathDeleteRequest& from) {
    RepoPathDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoPathDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoPathDeleteRequest";
  }
  protected:
  explicit RepoPathDeleteRequest(::google::protobuf::Arena* arena);
  RepoPathDeleteRequest(::google::protobuf::Arena* arena, const RepoPathDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // required string path = 1;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoPathDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoPathCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoPathCreateRequest) */ {
 public:
  inline RepoPathCreateRequest() : RepoPathCreateRequest(nullptr) {}
  ~RepoPathCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoPathCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoPathCreateRequest(const RepoPathCreateRequest& from)
      : RepoPathCreateRequest(nullptr, from) {}
  RepoPathCreateRequest(RepoPathCreateRequest&& from) noexcept
    : RepoPathCreateRequest() {
    *this = ::std::move(from);
  }

  inline RepoPathCreateRequest& operator=(const RepoPathCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoPathCreateRequest& operator=(RepoPathCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoPathCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoPathCreateRequest* internal_default_instance() {
    return reinterpret_cast<const RepoPathCreateRequest*>(
               &_RepoPathCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(RepoPathCreateRequest& a, RepoPathCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoPathCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoPathCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoPathCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoPathCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoPathCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoPathCreateRequest& from) {
    RepoPathCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoPathCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoPathCreateRequest";
  }
  protected:
  explicit RepoPathCreateRequest(::google::protobuf::Arena* arena);
  RepoPathCreateRequest(::google::protobuf::Arena* arena, const RepoPathCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // required string path = 1;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoPathCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoListSubjectAllocationsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoListSubjectAllocationsRequest) */ {
 public:
  inline RepoListSubjectAllocationsRequest() : RepoListSubjectAllocationsRequest(nullptr) {}
  ~RepoListSubjectAllocationsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoListSubjectAllocationsRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoListSubjectAllocationsRequest(const RepoListSubjectAllocationsRequest& from)
      : RepoListSubjectAllocationsRequest(nullptr, from) {}
  RepoListSubjectAllocationsRequest(RepoListSubjectAllocationsRequest&& from) noexcept
    : RepoListSubjectAllocationsRequest() {
    *this = ::std::move(from);
  }

  inline RepoListSubjectAllocationsRequest& operator=(const RepoListSubjectAllocationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoListSubjectAllocationsRequest& operator=(RepoListSubjectAllocationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoListSubjectAllocationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoListSubjectAllocationsRequest* internal_default_instance() {
    return reinterpret_cast<const RepoListSubjectAllocationsRequest*>(
               &_RepoListSubjectAllocationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(RepoListSubjectAllocationsRequest& a, RepoListSubjectAllocationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoListSubjectAllocationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoListSubjectAllocationsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoListSubjectAllocationsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoListSubjectAllocationsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoListSubjectAllocationsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoListSubjectAllocationsRequest& from) {
    RepoListSubjectAllocationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoListSubjectAllocationsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoListSubjectAllocationsRequest";
  }
  protected:
  explicit RepoListSubjectAllocationsRequest(::google::protobuf::Arena* arena);
  RepoListSubjectAllocationsRequest(::google::protobuf::Arena* arena, const RepoListSubjectAllocationsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
    kStatsFieldNumber = 2,
  };
  // optional string subject = 1;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // optional bool stats = 2;
  bool has_stats() const;
  void clear_stats() ;
  bool stats() const;
  void set_stats(bool value);

  private:
  bool _internal_stats() const;
  void _internal_set_stats(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoListSubjectAllocationsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    bool stats_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoListRequest) */ {
 public:
  inline RepoListRequest() : RepoListRequest(nullptr) {}
  ~RepoListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoListRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoListRequest(const RepoListRequest& from)
      : RepoListRequest(nullptr, from) {}
  RepoListRequest(RepoListRequest&& from) noexcept
    : RepoListRequest() {
    *this = ::std::move(from);
  }

  inline RepoListRequest& operator=(const RepoListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoListRequest& operator=(RepoListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoListRequest* internal_default_instance() {
    return reinterpret_cast<const RepoListRequest*>(
               &_RepoListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(RepoListRequest& a, RepoListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoListRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoListRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoListRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoListRequest& from) {
    RepoListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoListRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoListRequest";
  }
  protected:
  explicit RepoListRequest(::google::protobuf::Arena* arena);
  RepoListRequest(::google::protobuf::Arena* arena, const RepoListRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 1,
    kAllFieldNumber = 2,
  };
  // optional bool details = 1;
  bool has_details() const;
  void clear_details() ;
  bool details() const;
  void set_details(bool value);

  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);

  public:
  // optional bool all = 2;
  bool has_all() const;
  void clear_all() ;
  bool all() const;
  void set_all(bool value);

  private:
  bool _internal_all() const;
  void _internal_set_all(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoListRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool details_;
    bool all_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoListObjectAllocationsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoListObjectAllocationsRequest) */ {
 public:
  inline RepoListObjectAllocationsRequest() : RepoListObjectAllocationsRequest(nullptr) {}
  ~RepoListObjectAllocationsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoListObjectAllocationsRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoListObjectAllocationsRequest(const RepoListObjectAllocationsRequest& from)
      : RepoListObjectAllocationsRequest(nullptr, from) {}
  RepoListObjectAllocationsRequest(RepoListObjectAllocationsRequest&& from) noexcept
    : RepoListObjectAllocationsRequest() {
    *this = ::std::move(from);
  }

  inline RepoListObjectAllocationsRequest& operator=(const RepoListObjectAllocationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoListObjectAllocationsRequest& operator=(RepoListObjectAllocationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoListObjectAllocationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoListObjectAllocationsRequest* internal_default_instance() {
    return reinterpret_cast<const RepoListObjectAllocationsRequest*>(
               &_RepoListObjectAllocationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(RepoListObjectAllocationsRequest& a, RepoListObjectAllocationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoListObjectAllocationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoListObjectAllocationsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoListObjectAllocationsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoListObjectAllocationsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoListObjectAllocationsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoListObjectAllocationsRequest& from) {
    RepoListObjectAllocationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoListObjectAllocationsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoListObjectAllocationsRequest";
  }
  protected:
  explicit RepoListObjectAllocationsRequest(::google::protobuf::Arena* arena);
  RepoListObjectAllocationsRequest(::google::protobuf::Arena* arena, const RepoListObjectAllocationsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoListObjectAllocationsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoListAllocationsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoListAllocationsRequest) */ {
 public:
  inline RepoListAllocationsRequest() : RepoListAllocationsRequest(nullptr) {}
  ~RepoListAllocationsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoListAllocationsRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoListAllocationsRequest(const RepoListAllocationsRequest& from)
      : RepoListAllocationsRequest(nullptr, from) {}
  RepoListAllocationsRequest(RepoListAllocationsRequest&& from) noexcept
    : RepoListAllocationsRequest() {
    *this = ::std::move(from);
  }

  inline RepoListAllocationsRequest& operator=(const RepoListAllocationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoListAllocationsRequest& operator=(RepoListAllocationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoListAllocationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoListAllocationsRequest* internal_default_instance() {
    return reinterpret_cast<const RepoListAllocationsRequest*>(
               &_RepoListAllocationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(RepoListAllocationsRequest& a, RepoListAllocationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoListAllocationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoListAllocationsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoListAllocationsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoListAllocationsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoListAllocationsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoListAllocationsRequest& from) {
    RepoListAllocationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoListAllocationsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoListAllocationsRequest";
  }
  protected:
  explicit RepoListAllocationsRequest(::google::protobuf::Arena* arena);
  RepoListAllocationsRequest(::google::protobuf::Arena* arena, const RepoListAllocationsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoListAllocationsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoDeleteRequest) */ {
 public:
  inline RepoDeleteRequest() : RepoDeleteRequest(nullptr) {}
  ~RepoDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoDeleteRequest(const RepoDeleteRequest& from)
      : RepoDeleteRequest(nullptr, from) {}
  RepoDeleteRequest(RepoDeleteRequest&& from) noexcept
    : RepoDeleteRequest() {
    *this = ::std::move(from);
  }

  inline RepoDeleteRequest& operator=(const RepoDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoDeleteRequest& operator=(RepoDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const RepoDeleteRequest*>(
               &_RepoDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(RepoDeleteRequest& a, RepoDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoDeleteRequest& from) {
    RepoDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoDeleteRequest";
  }
  protected:
  explicit RepoDeleteRequest(::google::protobuf::Arena* arena);
  RepoDeleteRequest(::google::protobuf::Arena* arena, const RepoDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoCreateRequest) */ {
 public:
  inline RepoCreateRequest() : RepoCreateRequest(nullptr) {}
  ~RepoCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoCreateRequest(const RepoCreateRequest& from)
      : RepoCreateRequest(nullptr, from) {}
  RepoCreateRequest(RepoCreateRequest&& from) noexcept
    : RepoCreateRequest() {
    *this = ::std::move(from);
  }

  inline RepoCreateRequest& operator=(const RepoCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoCreateRequest& operator=(RepoCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoCreateRequest* internal_default_instance() {
    return reinterpret_cast<const RepoCreateRequest*>(
               &_RepoCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(RepoCreateRequest& a, RepoCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoCreateRequest& from) {
    RepoCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoCreateRequest";
  }
  protected:
  explicit RepoCreateRequest(::google::protobuf::Arena* arena);
  RepoCreateRequest(::google::protobuf::Arena* arena, const RepoCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminFieldNumber = 12,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 3,
    kDomainFieldNumber = 5,
    kPathFieldNumber = 6,
    kExpPathFieldNumber = 7,
    kAddressFieldNumber = 8,
    kEndpointFieldNumber = 9,
    kPubKeyFieldNumber = 10,
    kCapacityFieldNumber = 11,
  };
  // repeated string admin = 12;
  int admin_size() const;
  private:
  int _internal_admin_size() const;

  public:
  void clear_admin() ;
  const std::string& admin(int index) const;
  std::string* mutable_admin(int index);
  void set_admin(int index, const std::string& value);
  void set_admin(int index, std::string&& value);
  void set_admin(int index, const char* value);
  void set_admin(int index, const char* value, std::size_t size);
  void set_admin(int index, absl::string_view value);
  std::string* add_admin();
  void add_admin(const std::string& value);
  void add_admin(std::string&& value);
  void add_admin(const char* value);
  void add_admin(const char* value, std::size_t size);
  void add_admin(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_admin();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_admin();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string domain = 5;
  bool has_domain() const;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // required string path = 6;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional string exp_path = 7;
  bool has_exp_path() const;
  void clear_exp_path() ;
  const std::string& exp_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_exp_path(Arg_&& arg, Args_... args);
  std::string* mutable_exp_path();
  PROTOBUF_NODISCARD std::string* release_exp_path();
  void set_allocated_exp_path(std::string* value);

  private:
  const std::string& _internal_exp_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exp_path(
      const std::string& value);
  std::string* _internal_mutable_exp_path();

  public:
  // required string address = 8;
  bool has_address() const;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // required string endpoint = 9;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const std::string& endpoint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* value);

  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(
      const std::string& value);
  std::string* _internal_mutable_endpoint();

  public:
  // required string pub_key = 10;
  bool has_pub_key() const;
  void clear_pub_key() ;
  const std::string& pub_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pub_key(Arg_&& arg, Args_... args);
  std::string* mutable_pub_key();
  PROTOBUF_NODISCARD std::string* release_pub_key();
  void set_allocated_pub_key(std::string* value);

  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(
      const std::string& value);
  std::string* _internal_mutable_pub_key();

  public:
  // required uint64 capacity = 11;
  bool has_capacity() const;
  void clear_capacity() ;
  ::uint64_t capacity() const;
  void set_capacity(::uint64_t value);

  private:
  ::uint64_t _internal_capacity() const;
  void _internal_set_capacity(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      100, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> admin_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr exp_path_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr endpoint_;
    ::google::protobuf::internal::ArenaStringPtr pub_key_;
    ::uint64_t capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoCalcSizeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoCalcSizeRequest) */ {
 public:
  inline RepoCalcSizeRequest() : RepoCalcSizeRequest(nullptr) {}
  ~RepoCalcSizeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoCalcSizeRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoCalcSizeRequest(const RepoCalcSizeRequest& from)
      : RepoCalcSizeRequest(nullptr, from) {}
  RepoCalcSizeRequest(RepoCalcSizeRequest&& from) noexcept
    : RepoCalcSizeRequest() {
    *this = ::std::move(from);
  }

  inline RepoCalcSizeRequest& operator=(const RepoCalcSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoCalcSizeRequest& operator=(RepoCalcSizeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoCalcSizeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoCalcSizeRequest* internal_default_instance() {
    return reinterpret_cast<const RepoCalcSizeRequest*>(
               &_RepoCalcSizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(RepoCalcSizeRequest& a, RepoCalcSizeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoCalcSizeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoCalcSizeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoCalcSizeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoCalcSizeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoCalcSizeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoCalcSizeRequest& from) {
    RepoCalcSizeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoCalcSizeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoCalcSizeRequest";
  }
  protected:
  explicit RepoCalcSizeRequest(::google::protobuf::Arena* arena);
  RepoCalcSizeRequest(::google::protobuf::Arena* arena, const RepoCalcSizeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 2,
    kRecurseFieldNumber = 1,
  };
  // repeated string item = 2;
  int item_size() const;
  private:
  int _internal_item_size() const;

  public:
  void clear_item() ;
  const std::string& item(int index) const;
  std::string* mutable_item(int index);
  void set_item(int index, const std::string& value);
  void set_item(int index, std::string&& value);
  void set_item(int index, const char* value);
  void set_item(int index, const char* value, std::size_t size);
  void set_item(int index, absl::string_view value);
  std::string* add_item();
  void add_item(const std::string& value);
  void add_item(std::string&& value);
  void add_item(const char* value);
  void add_item(const char* value, std::size_t size);
  void add_item(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& item() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_item();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_item() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_item();

  public:
  // required bool recurse = 1;
  bool has_recurse() const;
  void clear_recurse() ;
  bool recurse() const;
  void set_recurse(bool value);

  private:
  bool _internal_recurse() const;
  void _internal_set_recurse(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoCalcSizeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> item_;
    bool recurse_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoAuthzRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoAuthzRequest) */ {
 public:
  inline RepoAuthzRequest() : RepoAuthzRequest(nullptr) {}
  ~RepoAuthzRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoAuthzRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoAuthzRequest(const RepoAuthzRequest& from)
      : RepoAuthzRequest(nullptr, from) {}
  RepoAuthzRequest(RepoAuthzRequest&& from) noexcept
    : RepoAuthzRequest() {
    *this = ::std::move(from);
  }

  inline RepoAuthzRequest& operator=(const RepoAuthzRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoAuthzRequest& operator=(RepoAuthzRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoAuthzRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoAuthzRequest* internal_default_instance() {
    return reinterpret_cast<const RepoAuthzRequest*>(
               &_RepoAuthzRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(RepoAuthzRequest& a, RepoAuthzRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoAuthzRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoAuthzRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoAuthzRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoAuthzRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoAuthzRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoAuthzRequest& from) {
    RepoAuthzRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoAuthzRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoAuthzRequest";
  }
  protected:
  explicit RepoAuthzRequest(::google::protobuf::Arena* arena);
  RepoAuthzRequest(::google::protobuf::Arena* arena, const RepoAuthzRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kClientFieldNumber = 2,
    kFileFieldNumber = 3,
    kActionFieldNumber = 4,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // required string client = 2;
  bool has_client() const;
  void clear_client() ;
  const std::string& client() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client(Arg_&& arg, Args_... args);
  std::string* mutable_client();
  PROTOBUF_NODISCARD std::string* release_client();
  void set_allocated_client(std::string* value);

  private:
  const std::string& _internal_client() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client(
      const std::string& value);
  std::string* _internal_mutable_client();

  public:
  // required string file = 3;
  bool has_file() const;
  void clear_file() ;
  const std::string& file() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file(Arg_&& arg, Args_... args);
  std::string* mutable_file();
  PROTOBUF_NODISCARD std::string* release_file();
  void set_allocated_file(std::string* value);

  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(
      const std::string& value);
  std::string* _internal_mutable_file();

  public:
  // required string action = 4;
  bool has_action() const;
  void clear_action() ;
  const std::string& action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* value);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoAuthzRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr client_;
    ::google::protobuf::internal::ArenaStringPtr file_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoAllocationStatsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoAllocationStatsRequest) */ {
 public:
  inline RepoAllocationStatsRequest() : RepoAllocationStatsRequest(nullptr) {}
  ~RepoAllocationStatsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoAllocationStatsRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoAllocationStatsRequest(const RepoAllocationStatsRequest& from)
      : RepoAllocationStatsRequest(nullptr, from) {}
  RepoAllocationStatsRequest(RepoAllocationStatsRequest&& from) noexcept
    : RepoAllocationStatsRequest() {
    *this = ::std::move(from);
  }

  inline RepoAllocationStatsRequest& operator=(const RepoAllocationStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoAllocationStatsRequest& operator=(RepoAllocationStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoAllocationStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoAllocationStatsRequest* internal_default_instance() {
    return reinterpret_cast<const RepoAllocationStatsRequest*>(
               &_RepoAllocationStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(RepoAllocationStatsRequest& a, RepoAllocationStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoAllocationStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoAllocationStatsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoAllocationStatsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoAllocationStatsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoAllocationStatsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoAllocationStatsRequest& from) {
    RepoAllocationStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoAllocationStatsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoAllocationStatsRequest";
  }
  protected:
  explicit RepoAllocationStatsRequest(::google::protobuf::Arena* arena);
  RepoAllocationStatsRequest(::google::protobuf::Arena* arena, const RepoAllocationStatsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kSubjectFieldNumber = 2,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // optional string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoAllocationStatsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoAllocationSetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoAllocationSetRequest) */ {
 public:
  inline RepoAllocationSetRequest() : RepoAllocationSetRequest(nullptr) {}
  ~RepoAllocationSetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoAllocationSetRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoAllocationSetRequest(const RepoAllocationSetRequest& from)
      : RepoAllocationSetRequest(nullptr, from) {}
  RepoAllocationSetRequest(RepoAllocationSetRequest&& from) noexcept
    : RepoAllocationSetRequest() {
    *this = ::std::move(from);
  }

  inline RepoAllocationSetRequest& operator=(const RepoAllocationSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoAllocationSetRequest& operator=(RepoAllocationSetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoAllocationSetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoAllocationSetRequest* internal_default_instance() {
    return reinterpret_cast<const RepoAllocationSetRequest*>(
               &_RepoAllocationSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(RepoAllocationSetRequest& a, RepoAllocationSetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoAllocationSetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoAllocationSetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoAllocationSetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoAllocationSetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoAllocationSetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoAllocationSetRequest& from) {
    RepoAllocationSetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoAllocationSetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoAllocationSetRequest";
  }
  protected:
  explicit RepoAllocationSetRequest(::google::protobuf::Arena* arena);
  RepoAllocationSetRequest(::google::protobuf::Arena* arena, const RepoAllocationSetRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kSubjectFieldNumber = 2,
    kDataLimitFieldNumber = 3,
    kRecLimitFieldNumber = 4,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // required string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // required uint64 data_limit = 3;
  bool has_data_limit() const;
  void clear_data_limit() ;
  ::uint64_t data_limit() const;
  void set_data_limit(::uint64_t value);

  private:
  ::uint64_t _internal_data_limit() const;
  void _internal_set_data_limit(::uint64_t value);

  public:
  // required uint32 rec_limit = 4;
  bool has_rec_limit() const;
  void clear_rec_limit() ;
  ::uint32_t rec_limit() const;
  void set_rec_limit(::uint32_t value);

  private:
  ::uint32_t _internal_rec_limit() const;
  void _internal_set_rec_limit(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoAllocationSetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    ::uint64_t data_limit_;
    ::uint32_t rec_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoAllocationSetDefaultRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoAllocationSetDefaultRequest) */ {
 public:
  inline RepoAllocationSetDefaultRequest() : RepoAllocationSetDefaultRequest(nullptr) {}
  ~RepoAllocationSetDefaultRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoAllocationSetDefaultRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoAllocationSetDefaultRequest(const RepoAllocationSetDefaultRequest& from)
      : RepoAllocationSetDefaultRequest(nullptr, from) {}
  RepoAllocationSetDefaultRequest(RepoAllocationSetDefaultRequest&& from) noexcept
    : RepoAllocationSetDefaultRequest() {
    *this = ::std::move(from);
  }

  inline RepoAllocationSetDefaultRequest& operator=(const RepoAllocationSetDefaultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoAllocationSetDefaultRequest& operator=(RepoAllocationSetDefaultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoAllocationSetDefaultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoAllocationSetDefaultRequest* internal_default_instance() {
    return reinterpret_cast<const RepoAllocationSetDefaultRequest*>(
               &_RepoAllocationSetDefaultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(RepoAllocationSetDefaultRequest& a, RepoAllocationSetDefaultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoAllocationSetDefaultRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoAllocationSetDefaultRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoAllocationSetDefaultRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoAllocationSetDefaultRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoAllocationSetDefaultRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoAllocationSetDefaultRequest& from) {
    RepoAllocationSetDefaultRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoAllocationSetDefaultRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoAllocationSetDefaultRequest";
  }
  protected:
  explicit RepoAllocationSetDefaultRequest(::google::protobuf::Arena* arena);
  RepoAllocationSetDefaultRequest(::google::protobuf::Arena* arena, const RepoAllocationSetDefaultRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kSubjectFieldNumber = 2,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // optional string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoAllocationSetDefaultRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoAllocationDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoAllocationDeleteRequest) */ {
 public:
  inline RepoAllocationDeleteRequest() : RepoAllocationDeleteRequest(nullptr) {}
  ~RepoAllocationDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoAllocationDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoAllocationDeleteRequest(const RepoAllocationDeleteRequest& from)
      : RepoAllocationDeleteRequest(nullptr, from) {}
  RepoAllocationDeleteRequest(RepoAllocationDeleteRequest&& from) noexcept
    : RepoAllocationDeleteRequest() {
    *this = ::std::move(from);
  }

  inline RepoAllocationDeleteRequest& operator=(const RepoAllocationDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoAllocationDeleteRequest& operator=(RepoAllocationDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoAllocationDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoAllocationDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const RepoAllocationDeleteRequest*>(
               &_RepoAllocationDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(RepoAllocationDeleteRequest& a, RepoAllocationDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoAllocationDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoAllocationDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoAllocationDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoAllocationDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoAllocationDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoAllocationDeleteRequest& from) {
    RepoAllocationDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoAllocationDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoAllocationDeleteRequest";
  }
  protected:
  explicit RepoAllocationDeleteRequest(::google::protobuf::Arena* arena);
  RepoAllocationDeleteRequest(::google::protobuf::Arena* arena, const RepoAllocationDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kSubjectFieldNumber = 2,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // required string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoAllocationDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoAllocationCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoAllocationCreateRequest) */ {
 public:
  inline RepoAllocationCreateRequest() : RepoAllocationCreateRequest(nullptr) {}
  ~RepoAllocationCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoAllocationCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoAllocationCreateRequest(const RepoAllocationCreateRequest& from)
      : RepoAllocationCreateRequest(nullptr, from) {}
  RepoAllocationCreateRequest(RepoAllocationCreateRequest&& from) noexcept
    : RepoAllocationCreateRequest() {
    *this = ::std::move(from);
  }

  inline RepoAllocationCreateRequest& operator=(const RepoAllocationCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoAllocationCreateRequest& operator=(RepoAllocationCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoAllocationCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoAllocationCreateRequest* internal_default_instance() {
    return reinterpret_cast<const RepoAllocationCreateRequest*>(
               &_RepoAllocationCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(RepoAllocationCreateRequest& a, RepoAllocationCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoAllocationCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoAllocationCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoAllocationCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoAllocationCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoAllocationCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoAllocationCreateRequest& from) {
    RepoAllocationCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoAllocationCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoAllocationCreateRequest";
  }
  protected:
  explicit RepoAllocationCreateRequest(::google::protobuf::Arena* arena);
  RepoAllocationCreateRequest(::google::protobuf::Arena* arena, const RepoAllocationCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kSubjectFieldNumber = 2,
    kDataLimitFieldNumber = 3,
    kRecLimitFieldNumber = 4,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // required string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // required uint64 data_limit = 3;
  bool has_data_limit() const;
  void clear_data_limit() ;
  ::uint64_t data_limit() const;
  void set_data_limit(::uint64_t value);

  private:
  ::uint64_t _internal_data_limit() const;
  void _internal_set_data_limit(::uint64_t value);

  public:
  // required uint32 rec_limit = 4;
  bool has_rec_limit() const;
  void clear_rec_limit() ;
  ::uint32_t rec_limit() const;
  void set_rec_limit(::uint32_t value);

  private:
  ::uint32_t _internal_rec_limit() const;
  void _internal_set_rec_limit(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoAllocationCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    ::uint64_t data_limit_;
    ::uint32_t rec_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordViewRequest) */ {
 public:
  inline RecordViewRequest() : RecordViewRequest(nullptr) {}
  ~RecordViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordViewRequest(const RecordViewRequest& from)
      : RecordViewRequest(nullptr, from) {}
  RecordViewRequest(RecordViewRequest&& from) noexcept
    : RecordViewRequest() {
    *this = ::std::move(from);
  }

  inline RecordViewRequest& operator=(const RecordViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordViewRequest& operator=(RecordViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordViewRequest* internal_default_instance() {
    return reinterpret_cast<const RecordViewRequest*>(
               &_RecordViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RecordViewRequest& a, RecordViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordViewRequest& from) {
    RecordViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordViewRequest";
  }
  protected:
  explicit RecordViewRequest(::google::protobuf::Arena* arena);
  RecordViewRequest(::google::protobuf::Arena* arena, const RecordViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDetailsFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional bool details = 2;
  bool has_details() const;
  void clear_details() ;
  bool details() const;
  void set_details(bool value);

  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    bool details_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordUpdateBatchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordUpdateBatchRequest) */ {
 public:
  inline RecordUpdateBatchRequest() : RecordUpdateBatchRequest(nullptr) {}
  ~RecordUpdateBatchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordUpdateBatchRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordUpdateBatchRequest(const RecordUpdateBatchRequest& from)
      : RecordUpdateBatchRequest(nullptr, from) {}
  RecordUpdateBatchRequest(RecordUpdateBatchRequest&& from) noexcept
    : RecordUpdateBatchRequest() {
    *this = ::std::move(from);
  }

  inline RecordUpdateBatchRequest& operator=(const RecordUpdateBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordUpdateBatchRequest& operator=(RecordUpdateBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordUpdateBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordUpdateBatchRequest* internal_default_instance() {
    return reinterpret_cast<const RecordUpdateBatchRequest*>(
               &_RecordUpdateBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RecordUpdateBatchRequest& a, RecordUpdateBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordUpdateBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordUpdateBatchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordUpdateBatchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordUpdateBatchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordUpdateBatchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordUpdateBatchRequest& from) {
    RecordUpdateBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordUpdateBatchRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordUpdateBatchRequest";
  }
  protected:
  explicit RecordUpdateBatchRequest(::google::protobuf::Arena* arena);
  RecordUpdateBatchRequest(::google::protobuf::Arena* arena, const RecordUpdateBatchRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 1,
  };
  // required string records = 1;
  bool has_records() const;
  void clear_records() ;
  const std::string& records() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_records(Arg_&& arg, Args_... args);
  std::string* mutable_records();
  PROTOBUF_NODISCARD std::string* release_records();
  void set_allocated_records(std::string* value);

  private:
  const std::string& _internal_records() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_records(
      const std::string& value);
  std::string* _internal_mutable_records();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordUpdateBatchRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr records_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordOwnerChangeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordOwnerChangeRequest) */ {
 public:
  inline RecordOwnerChangeRequest() : RecordOwnerChangeRequest(nullptr) {}
  ~RecordOwnerChangeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordOwnerChangeRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordOwnerChangeRequest(const RecordOwnerChangeRequest& from)
      : RecordOwnerChangeRequest(nullptr, from) {}
  RecordOwnerChangeRequest(RecordOwnerChangeRequest&& from) noexcept
    : RecordOwnerChangeRequest() {
    *this = ::std::move(from);
  }

  inline RecordOwnerChangeRequest& operator=(const RecordOwnerChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordOwnerChangeRequest& operator=(RecordOwnerChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordOwnerChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordOwnerChangeRequest* internal_default_instance() {
    return reinterpret_cast<const RecordOwnerChangeRequest*>(
               &_RecordOwnerChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(RecordOwnerChangeRequest& a, RecordOwnerChangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordOwnerChangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordOwnerChangeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordOwnerChangeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordOwnerChangeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordOwnerChangeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordOwnerChangeRequest& from) {
    RecordOwnerChangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordOwnerChangeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordOwnerChangeRequest";
  }
  protected:
  explicit RecordOwnerChangeRequest(::google::protobuf::Arena* arena);
  RecordOwnerChangeRequest(::google::protobuf::Arena* arena, const RecordOwnerChangeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCollIdFieldNumber = 2,
    kRepoIdFieldNumber = 3,
    kProjIdFieldNumber = 4,
    kCheckFieldNumber = 5,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // required string coll_id = 2;
  bool has_coll_id() const;
  void clear_coll_id() ;
  const std::string& coll_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_coll_id(Arg_&& arg, Args_... args);
  std::string* mutable_coll_id();
  PROTOBUF_NODISCARD std::string* release_coll_id();
  void set_allocated_coll_id(std::string* value);

  private:
  const std::string& _internal_coll_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coll_id(
      const std::string& value);
  std::string* _internal_mutable_coll_id();

  public:
  // optional string repo_id = 3;
  bool has_repo_id() const;
  void clear_repo_id() ;
  const std::string& repo_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo_id(Arg_&& arg, Args_... args);
  std::string* mutable_repo_id();
  PROTOBUF_NODISCARD std::string* release_repo_id();
  void set_allocated_repo_id(std::string* value);

  private:
  const std::string& _internal_repo_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo_id(
      const std::string& value);
  std::string* _internal_mutable_repo_id();

  public:
  // optional string proj_id = 4;
  bool has_proj_id() const;
  void clear_proj_id() ;
  const std::string& proj_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proj_id(Arg_&& arg, Args_... args);
  std::string* mutable_proj_id();
  PROTOBUF_NODISCARD std::string* release_proj_id();
  void set_allocated_proj_id(std::string* value);

  private:
  const std::string& _internal_proj_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proj_id(
      const std::string& value);
  std::string* _internal_mutable_proj_id();

  public:
  // optional bool check = 5;
  bool has_check() const;
  void clear_check() ;
  bool check() const;
  void set_check(bool value);

  private:
  bool _internal_check() const;
  void _internal_set_check(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordOwnerChangeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    ::google::protobuf::internal::ArenaStringPtr coll_id_;
    ::google::protobuf::internal::ArenaStringPtr repo_id_;
    ::google::protobuf::internal::ArenaStringPtr proj_id_;
    bool check_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordLockRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordLockRequest) */ {
 public:
  inline RecordLockRequest() : RecordLockRequest(nullptr) {}
  ~RecordLockRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordLockRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordLockRequest(const RecordLockRequest& from)
      : RecordLockRequest(nullptr, from) {}
  RecordLockRequest(RecordLockRequest&& from) noexcept
    : RecordLockRequest() {
    *this = ::std::move(from);
  }

  inline RecordLockRequest& operator=(const RecordLockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordLockRequest& operator=(RecordLockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordLockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordLockRequest* internal_default_instance() {
    return reinterpret_cast<const RecordLockRequest*>(
               &_RecordLockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RecordLockRequest& a, RecordLockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordLockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordLockRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordLockRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordLockRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordLockRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordLockRequest& from) {
    RecordLockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordLockRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordLockRequest";
  }
  protected:
  explicit RecordLockRequest(::google::protobuf::Arena* arena);
  RecordLockRequest(::google::protobuf::Arena* arena, const RecordLockRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLockFieldNumber = 2,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // required bool lock = 2;
  bool has_lock() const;
  void clear_lock() ;
  bool lock() const;
  void set_lock(bool value);

  private:
  bool _internal_lock() const;
  void _internal_set_lock(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordLockRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    bool lock_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordListByAllocRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordListByAllocRequest) */ {
 public:
  inline RecordListByAllocRequest() : RecordListByAllocRequest(nullptr) {}
  ~RecordListByAllocRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordListByAllocRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordListByAllocRequest(const RecordListByAllocRequest& from)
      : RecordListByAllocRequest(nullptr, from) {}
  RecordListByAllocRequest(RecordListByAllocRequest&& from) noexcept
    : RecordListByAllocRequest() {
    *this = ::std::move(from);
  }

  inline RecordListByAllocRequest& operator=(const RecordListByAllocRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordListByAllocRequest& operator=(RecordListByAllocRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordListByAllocRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordListByAllocRequest* internal_default_instance() {
    return reinterpret_cast<const RecordListByAllocRequest*>(
               &_RecordListByAllocRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RecordListByAllocRequest& a, RecordListByAllocRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordListByAllocRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordListByAllocRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordListByAllocRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordListByAllocRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordListByAllocRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordListByAllocRequest& from) {
    RecordListByAllocRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordListByAllocRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordListByAllocRequest";
  }
  protected:
  explicit RecordListByAllocRequest(::google::protobuf::Arena* arena);
  RecordListByAllocRequest(::google::protobuf::Arena* arena, const RecordListByAllocRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kSubjectFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // optional string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // optional uint32 offset = 3;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 4;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordListByAllocRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordGetDependencyGraphRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordGetDependencyGraphRequest) */ {
 public:
  inline RecordGetDependencyGraphRequest() : RecordGetDependencyGraphRequest(nullptr) {}
  ~RecordGetDependencyGraphRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordGetDependencyGraphRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordGetDependencyGraphRequest(const RecordGetDependencyGraphRequest& from)
      : RecordGetDependencyGraphRequest(nullptr, from) {}
  RecordGetDependencyGraphRequest(RecordGetDependencyGraphRequest&& from) noexcept
    : RecordGetDependencyGraphRequest() {
    *this = ::std::move(from);
  }

  inline RecordGetDependencyGraphRequest& operator=(const RecordGetDependencyGraphRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordGetDependencyGraphRequest& operator=(RecordGetDependencyGraphRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordGetDependencyGraphRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordGetDependencyGraphRequest* internal_default_instance() {
    return reinterpret_cast<const RecordGetDependencyGraphRequest*>(
               &_RecordGetDependencyGraphRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RecordGetDependencyGraphRequest& a, RecordGetDependencyGraphRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordGetDependencyGraphRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordGetDependencyGraphRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordGetDependencyGraphRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordGetDependencyGraphRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordGetDependencyGraphRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordGetDependencyGraphRequest& from) {
    RecordGetDependencyGraphRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordGetDependencyGraphRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordGetDependencyGraphRequest";
  }
  protected:
  explicit RecordGetDependencyGraphRequest(::google::protobuf::Arena* arena);
  RecordGetDependencyGraphRequest(::google::protobuf::Arena* arena, const RecordGetDependencyGraphRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordGetDependencyGraphRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordExportRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordExportRequest) */ {
 public:
  inline RecordExportRequest() : RecordExportRequest(nullptr) {}
  ~RecordExportRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordExportRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordExportRequest(const RecordExportRequest& from)
      : RecordExportRequest(nullptr, from) {}
  RecordExportRequest(RecordExportRequest&& from) noexcept
    : RecordExportRequest() {
    *this = ::std::move(from);
  }

  inline RecordExportRequest& operator=(const RecordExportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordExportRequest& operator=(RecordExportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordExportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordExportRequest* internal_default_instance() {
    return reinterpret_cast<const RecordExportRequest*>(
               &_RecordExportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RecordExportRequest& a, RecordExportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordExportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordExportRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordExportRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordExportRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordExportRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordExportRequest& from) {
    RecordExportRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordExportRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordExportRequest";
  }
  protected:
  explicit RecordExportRequest(::google::protobuf::Arena* arena);
  RecordExportRequest(::google::protobuf::Arena* arena, const RecordExportRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordExportRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordExportReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordExportReply) */ {
 public:
  inline RecordExportReply() : RecordExportReply(nullptr) {}
  ~RecordExportReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordExportReply(::google::protobuf::internal::ConstantInitialized);

  inline RecordExportReply(const RecordExportReply& from)
      : RecordExportReply(nullptr, from) {}
  RecordExportReply(RecordExportReply&& from) noexcept
    : RecordExportReply() {
    *this = ::std::move(from);
  }

  inline RecordExportReply& operator=(const RecordExportReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordExportReply& operator=(RecordExportReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordExportReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordExportReply* internal_default_instance() {
    return reinterpret_cast<const RecordExportReply*>(
               &_RecordExportReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RecordExportReply& a, RecordExportReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordExportReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordExportReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordExportReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordExportReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordExportReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordExportReply& from) {
    RecordExportReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordExportReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordExportReply";
  }
  protected:
  explicit RecordExportReply(::google::protobuf::Arena* arena);
  RecordExportReply(::google::protobuf::Arena* arena, const RecordExportReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 1,
  };
  // repeated string record = 1;
  int record_size() const;
  private:
  int _internal_record_size() const;

  public:
  void clear_record() ;
  const std::string& record(int index) const;
  std::string* mutable_record(int index);
  void set_record(int index, const std::string& value);
  void set_record(int index, std::string&& value);
  void set_record(int index, const char* value);
  void set_record(int index, const char* value, std::size_t size);
  void set_record(int index, absl::string_view value);
  std::string* add_record();
  void add_record(const std::string& value);
  void add_record(std::string&& value);
  void add_record(const char* value);
  void add_record(const char* value, std::size_t size);
  void add_record(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& record() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_record();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_record() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_record();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordExportReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> record_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordDeleteRequest) */ {
 public:
  inline RecordDeleteRequest() : RecordDeleteRequest(nullptr) {}
  ~RecordDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordDeleteRequest(const RecordDeleteRequest& from)
      : RecordDeleteRequest(nullptr, from) {}
  RecordDeleteRequest(RecordDeleteRequest&& from) noexcept
    : RecordDeleteRequest() {
    *this = ::std::move(from);
  }

  inline RecordDeleteRequest& operator=(const RecordDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDeleteRequest& operator=(RecordDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const RecordDeleteRequest*>(
               &_RecordDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RecordDeleteRequest& a, RecordDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordDeleteRequest& from) {
    RecordDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordDeleteRequest";
  }
  protected:
  explicit RecordDeleteRequest(::google::protobuf::Arena* arena);
  RecordDeleteRequest(::google::protobuf::Arena* arena, const RecordDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordCreateBatchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordCreateBatchRequest) */ {
 public:
  inline RecordCreateBatchRequest() : RecordCreateBatchRequest(nullptr) {}
  ~RecordCreateBatchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordCreateBatchRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordCreateBatchRequest(const RecordCreateBatchRequest& from)
      : RecordCreateBatchRequest(nullptr, from) {}
  RecordCreateBatchRequest(RecordCreateBatchRequest&& from) noexcept
    : RecordCreateBatchRequest() {
    *this = ::std::move(from);
  }

  inline RecordCreateBatchRequest& operator=(const RecordCreateBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordCreateBatchRequest& operator=(RecordCreateBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordCreateBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordCreateBatchRequest* internal_default_instance() {
    return reinterpret_cast<const RecordCreateBatchRequest*>(
               &_RecordCreateBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RecordCreateBatchRequest& a, RecordCreateBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordCreateBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordCreateBatchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordCreateBatchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordCreateBatchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordCreateBatchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordCreateBatchRequest& from) {
    RecordCreateBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordCreateBatchRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordCreateBatchRequest";
  }
  protected:
  explicit RecordCreateBatchRequest(::google::protobuf::Arena* arena);
  RecordCreateBatchRequest(::google::protobuf::Arena* arena, const RecordCreateBatchRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 1,
  };
  // required string records = 1;
  bool has_records() const;
  void clear_records() ;
  const std::string& records() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_records(Arg_&& arg, Args_... args);
  std::string* mutable_records();
  PROTOBUF_NODISCARD std::string* release_records();
  void set_allocated_records(std::string* value);

  private:
  const std::string& _internal_records() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_records(
      const std::string& value);
  std::string* _internal_mutable_records();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordCreateBatchRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr records_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordAllocChangeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordAllocChangeRequest) */ {
 public:
  inline RecordAllocChangeRequest() : RecordAllocChangeRequest(nullptr) {}
  ~RecordAllocChangeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordAllocChangeRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordAllocChangeRequest(const RecordAllocChangeRequest& from)
      : RecordAllocChangeRequest(nullptr, from) {}
  RecordAllocChangeRequest(RecordAllocChangeRequest&& from) noexcept
    : RecordAllocChangeRequest() {
    *this = ::std::move(from);
  }

  inline RecordAllocChangeRequest& operator=(const RecordAllocChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordAllocChangeRequest& operator=(RecordAllocChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordAllocChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordAllocChangeRequest* internal_default_instance() {
    return reinterpret_cast<const RecordAllocChangeRequest*>(
               &_RecordAllocChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(RecordAllocChangeRequest& a, RecordAllocChangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordAllocChangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordAllocChangeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordAllocChangeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordAllocChangeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordAllocChangeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordAllocChangeRequest& from) {
    RecordAllocChangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordAllocChangeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordAllocChangeRequest";
  }
  protected:
  explicit RecordAllocChangeRequest(::google::protobuf::Arena* arena);
  RecordAllocChangeRequest(::google::protobuf::Arena* arena, const RecordAllocChangeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRepoIdFieldNumber = 2,
    kProjIdFieldNumber = 3,
    kCheckFieldNumber = 4,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // required string repo_id = 2;
  bool has_repo_id() const;
  void clear_repo_id() ;
  const std::string& repo_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo_id(Arg_&& arg, Args_... args);
  std::string* mutable_repo_id();
  PROTOBUF_NODISCARD std::string* release_repo_id();
  void set_allocated_repo_id(std::string* value);

  private:
  const std::string& _internal_repo_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo_id(
      const std::string& value);
  std::string* _internal_mutable_repo_id();

  public:
  // optional string proj_id = 3;
  bool has_proj_id() const;
  void clear_proj_id() ;
  const std::string& proj_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proj_id(Arg_&& arg, Args_... args);
  std::string* mutable_proj_id();
  PROTOBUF_NODISCARD std::string* release_proj_id();
  void set_allocated_proj_id(std::string* value);

  private:
  const std::string& _internal_proj_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proj_id(
      const std::string& value);
  std::string* _internal_mutable_proj_id();

  public:
  // optional bool check = 4;
  bool has_check() const;
  void clear_check() ;
  bool check() const;
  void set_check(bool value);

  private:
  bool _internal_check() const;
  void _internal_set_check(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordAllocChangeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    ::google::protobuf::internal::ArenaStringPtr repo_id_;
    ::google::protobuf::internal::ArenaStringPtr proj_id_;
    bool check_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class QueryViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.QueryViewRequest) */ {
 public:
  inline QueryViewRequest() : QueryViewRequest(nullptr) {}
  ~QueryViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline QueryViewRequest(const QueryViewRequest& from)
      : QueryViewRequest(nullptr, from) {}
  QueryViewRequest(QueryViewRequest&& from) noexcept
    : QueryViewRequest() {
    *this = ::std::move(from);
  }

  inline QueryViewRequest& operator=(const QueryViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryViewRequest& operator=(QueryViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryViewRequest* internal_default_instance() {
    return reinterpret_cast<const QueryViewRequest*>(
               &_QueryViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(QueryViewRequest& a, QueryViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryViewRequest& from) {
    QueryViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.QueryViewRequest";
  }
  protected:
  explicit QueryViewRequest(::google::protobuf::Arena* arena);
  QueryViewRequest(::google::protobuf::Arena* arena, const QueryViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.QueryViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class QueryListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.QueryListRequest) */ {
 public:
  inline QueryListRequest() : QueryListRequest(nullptr) {}
  ~QueryListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryListRequest(::google::protobuf::internal::ConstantInitialized);

  inline QueryListRequest(const QueryListRequest& from)
      : QueryListRequest(nullptr, from) {}
  QueryListRequest(QueryListRequest&& from) noexcept
    : QueryListRequest() {
    *this = ::std::move(from);
  }

  inline QueryListRequest& operator=(const QueryListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryListRequest& operator=(QueryListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryListRequest* internal_default_instance() {
    return reinterpret_cast<const QueryListRequest*>(
               &_QueryListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(QueryListRequest& a, QueryListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryListRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryListRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryListRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryListRequest& from) {
    QueryListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryListRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.QueryListRequest";
  }
  protected:
  explicit QueryListRequest(::google::protobuf::Arena* arena);
  QueryListRequest(::google::protobuf::Arena* arena, const QueryListRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional uint32 offset = 1;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.QueryListRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class QueryExecRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.QueryExecRequest) */ {
 public:
  inline QueryExecRequest() : QueryExecRequest(nullptr) {}
  ~QueryExecRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryExecRequest(::google::protobuf::internal::ConstantInitialized);

  inline QueryExecRequest(const QueryExecRequest& from)
      : QueryExecRequest(nullptr, from) {}
  QueryExecRequest(QueryExecRequest&& from) noexcept
    : QueryExecRequest() {
    *this = ::std::move(from);
  }

  inline QueryExecRequest& operator=(const QueryExecRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryExecRequest& operator=(QueryExecRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryExecRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryExecRequest* internal_default_instance() {
    return reinterpret_cast<const QueryExecRequest*>(
               &_QueryExecRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(QueryExecRequest& a, QueryExecRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryExecRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryExecRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryExecRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryExecRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryExecRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryExecRequest& from) {
    QueryExecRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryExecRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.QueryExecRequest";
  }
  protected:
  explicit QueryExecRequest(::google::protobuf::Arena* arena);
  QueryExecRequest(::google::protobuf::Arena* arena, const QueryExecRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.QueryExecRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class QueryDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.QueryDeleteRequest) */ {
 public:
  inline QueryDeleteRequest() : QueryDeleteRequest(nullptr) {}
  ~QueryDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline QueryDeleteRequest(const QueryDeleteRequest& from)
      : QueryDeleteRequest(nullptr, from) {}
  QueryDeleteRequest(QueryDeleteRequest&& from) noexcept
    : QueryDeleteRequest() {
    *this = ::std::move(from);
  }

  inline QueryDeleteRequest& operator=(const QueryDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDeleteRequest& operator=(QueryDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDeleteRequest*>(
               &_QueryDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(QueryDeleteRequest& a, QueryDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryDeleteRequest& from) {
    QueryDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.QueryDeleteRequest";
  }
  protected:
  explicit QueryDeleteRequest(::google::protobuf::Arena* arena);
  QueryDeleteRequest(::google::protobuf::Arena* arena, const QueryDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.QueryDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectViewRequest) */ {
 public:
  inline ProjectViewRequest() : ProjectViewRequest(nullptr) {}
  ~ProjectViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProjectViewRequest(const ProjectViewRequest& from)
      : ProjectViewRequest(nullptr, from) {}
  ProjectViewRequest(ProjectViewRequest&& from) noexcept
    : ProjectViewRequest() {
    *this = ::std::move(from);
  }

  inline ProjectViewRequest& operator=(const ProjectViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectViewRequest& operator=(ProjectViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectViewRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectViewRequest*>(
               &_ProjectViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(ProjectViewRequest& a, ProjectViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectViewRequest& from) {
    ProjectViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectViewRequest";
  }
  protected:
  explicit ProjectViewRequest(::google::protobuf::Arena* arena);
  ProjectViewRequest(::google::protobuf::Arena* arena, const ProjectViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectUpdateRequest) */ {
 public:
  inline ProjectUpdateRequest() : ProjectUpdateRequest(nullptr) {}
  ~ProjectUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProjectUpdateRequest(const ProjectUpdateRequest& from)
      : ProjectUpdateRequest(nullptr, from) {}
  ProjectUpdateRequest(ProjectUpdateRequest&& from) noexcept
    : ProjectUpdateRequest() {
    *this = ::std::move(from);
  }

  inline ProjectUpdateRequest& operator=(const ProjectUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectUpdateRequest& operator=(ProjectUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectUpdateRequest*>(
               &_ProjectUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ProjectUpdateRequest& a, ProjectUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectUpdateRequest& from) {
    ProjectUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectUpdateRequest";
  }
  protected:
  explicit ProjectUpdateRequest(::google::protobuf::Arena* arena);
  ProjectUpdateRequest(::google::protobuf::Arena* arena, const ProjectUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminFieldNumber = 5,
    kMemberFieldNumber = 7,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 3,
    kAdminSetFieldNumber = 4,
    kMemberSetFieldNumber = 6,
  };
  // repeated string admin = 5;
  int admin_size() const;
  private:
  int _internal_admin_size() const;

  public:
  void clear_admin() ;
  const std::string& admin(int index) const;
  std::string* mutable_admin(int index);
  void set_admin(int index, const std::string& value);
  void set_admin(int index, std::string&& value);
  void set_admin(int index, const char* value);
  void set_admin(int index, const char* value, std::size_t size);
  void set_admin(int index, absl::string_view value);
  std::string* add_admin();
  void add_admin(const std::string& value);
  void add_admin(std::string&& value);
  void add_admin(const char* value);
  void add_admin(const char* value, std::size_t size);
  void add_admin(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_admin();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_admin();

  public:
  // repeated string member = 7;
  int member_size() const;
  private:
  int _internal_member_size() const;

  public:
  void clear_member() ;
  const std::string& member(int index) const;
  std::string* mutable_member(int index);
  void set_member(int index, const std::string& value);
  void set_member(int index, std::string&& value);
  void set_member(int index, const char* value);
  void set_member(int index, const char* value, std::size_t size);
  void set_member(int index, absl::string_view value);
  std::string* add_member();
  void add_member(const std::string& value);
  void add_member(std::string&& value);
  void add_member(const char* value);
  void add_member(const char* value, std::size_t size);
  void add_member(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& member() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_member();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_member() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_member();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional bool admin_set = 4 [default = false];
  bool has_admin_set() const;
  void clear_admin_set() ;
  bool admin_set() const;
  void set_admin_set(bool value);

  private:
  bool _internal_admin_set() const;
  void _internal_set_admin_set(bool value);

  public:
  // optional bool member_set = 6 [default = false];
  bool has_member_set() const;
  void clear_member_set() ;
  bool member_set() const;
  void set_member_set(bool value);

  private:
  bool _internal_member_set() const;
  void _internal_set_member_set(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> admin_;
    ::google::protobuf::RepeatedPtrField<std::string> member_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    bool admin_set_;
    bool member_set_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectSearchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectSearchRequest) */ {
 public:
  inline ProjectSearchRequest() : ProjectSearchRequest(nullptr) {}
  ~ProjectSearchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectSearchRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProjectSearchRequest(const ProjectSearchRequest& from)
      : ProjectSearchRequest(nullptr, from) {}
  ProjectSearchRequest(ProjectSearchRequest&& from) noexcept
    : ProjectSearchRequest() {
    *this = ::std::move(from);
  }

  inline ProjectSearchRequest& operator=(const ProjectSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectSearchRequest& operator=(ProjectSearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectSearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectSearchRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectSearchRequest*>(
               &_ProjectSearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ProjectSearchRequest& a, ProjectSearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectSearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectSearchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectSearchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectSearchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectSearchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectSearchRequest& from) {
    ProjectSearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectSearchRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectSearchRequest";
  }
  protected:
  explicit ProjectSearchRequest(::google::protobuf::Arena* arena);
  ProjectSearchRequest(::google::protobuf::Arena* arena, const ProjectSearchRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScopeFieldNumber = 2,
    kTextQueryFieldNumber = 1,
  };
  // repeated string scope = 2;
  int scope_size() const;
  private:
  int _internal_scope_size() const;

  public:
  void clear_scope() ;
  const std::string& scope(int index) const;
  std::string* mutable_scope(int index);
  void set_scope(int index, const std::string& value);
  void set_scope(int index, std::string&& value);
  void set_scope(int index, const char* value);
  void set_scope(int index, const char* value, std::size_t size);
  void set_scope(int index, absl::string_view value);
  std::string* add_scope();
  void add_scope(const std::string& value);
  void add_scope(std::string&& value);
  void add_scope(const char* value);
  void add_scope(const char* value, std::size_t size);
  void add_scope(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& scope() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_scope();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_scope() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_scope();

  public:
  // required string text_query = 1;
  bool has_text_query() const;
  void clear_text_query() ;
  const std::string& text_query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_query(Arg_&& arg, Args_... args);
  std::string* mutable_text_query();
  PROTOBUF_NODISCARD std::string* release_text_query();
  void set_allocated_text_query(std::string* value);

  private:
  const std::string& _internal_text_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_query(
      const std::string& value);
  std::string* _internal_mutable_text_query();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectSearchRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> scope_;
    ::google::protobuf::internal::ArenaStringPtr text_query_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectListRequest) */ {
 public:
  inline ProjectListRequest() : ProjectListRequest(nullptr) {}
  ~ProjectListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectListRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProjectListRequest(const ProjectListRequest& from)
      : ProjectListRequest(nullptr, from) {}
  ProjectListRequest(ProjectListRequest&& from) noexcept
    : ProjectListRequest() {
    *this = ::std::move(from);
  }

  inline ProjectListRequest& operator=(const ProjectListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectListRequest& operator=(ProjectListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectListRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectListRequest*>(
               &_ProjectListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(ProjectListRequest& a, ProjectListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectListRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectListRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectListRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectListRequest& from) {
    ProjectListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectListRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectListRequest";
  }
  protected:
  explicit ProjectListRequest(::google::protobuf::Arena* arena);
  ProjectListRequest(::google::protobuf::Arena* arena, const ProjectListRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
    kAsOwnerFieldNumber = 2,
    kAsAdminFieldNumber = 3,
    kAsMemberFieldNumber = 4,
    kSortRevFieldNumber = 6,
    kSortFieldNumber = 5,
    kOffsetFieldNumber = 7,
    kCountFieldNumber = 8,
  };
  // optional string subject = 1;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // optional bool as_owner = 2;
  bool has_as_owner() const;
  void clear_as_owner() ;
  bool as_owner() const;
  void set_as_owner(bool value);

  private:
  bool _internal_as_owner() const;
  void _internal_set_as_owner(bool value);

  public:
  // optional bool as_admin = 3;
  bool has_as_admin() const;
  void clear_as_admin() ;
  bool as_admin() const;
  void set_as_admin(bool value);

  private:
  bool _internal_as_admin() const;
  void _internal_set_as_admin(bool value);

  public:
  // optional bool as_member = 4;
  bool has_as_member() const;
  void clear_as_member() ;
  bool as_member() const;
  void set_as_member(bool value);

  private:
  bool _internal_as_member() const;
  void _internal_set_as_member(bool value);

  public:
  // optional bool sort_rev = 6;
  bool has_sort_rev() const;
  void clear_sort_rev() ;
  bool sort_rev() const;
  void set_sort_rev(bool value);

  private:
  bool _internal_sort_rev() const;
  void _internal_set_sort_rev(bool value);

  public:
  // optional .SDMS.SortOption sort = 5;
  bool has_sort() const;
  void clear_sort() ;
  ::SDMS::SortOption sort() const;
  void set_sort(::SDMS::SortOption value);

  private:
  ::SDMS::SortOption _internal_sort() const;
  void _internal_set_sort(::SDMS::SortOption value);

  public:
  // optional uint32 offset = 7;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 8;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectListRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    bool as_owner_;
    bool as_admin_;
    bool as_member_;
    bool sort_rev_;
    int sort_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectGetRoleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectGetRoleRequest) */ {
 public:
  inline ProjectGetRoleRequest() : ProjectGetRoleRequest(nullptr) {}
  ~ProjectGetRoleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectGetRoleRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProjectGetRoleRequest(const ProjectGetRoleRequest& from)
      : ProjectGetRoleRequest(nullptr, from) {}
  ProjectGetRoleRequest(ProjectGetRoleRequest&& from) noexcept
    : ProjectGetRoleRequest() {
    *this = ::std::move(from);
  }

  inline ProjectGetRoleRequest& operator=(const ProjectGetRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectGetRoleRequest& operator=(ProjectGetRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectGetRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectGetRoleRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectGetRoleRequest*>(
               &_ProjectGetRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(ProjectGetRoleRequest& a, ProjectGetRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectGetRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectGetRoleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectGetRoleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectGetRoleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectGetRoleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectGetRoleRequest& from) {
    ProjectGetRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectGetRoleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectGetRoleRequest";
  }
  protected:
  explicit ProjectGetRoleRequest(::google::protobuf::Arena* arena);
  ProjectGetRoleRequest(::google::protobuf::Arena* arena, const ProjectGetRoleRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSubjectFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectGetRoleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectGetRoleReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectGetRoleReply) */ {
 public:
  inline ProjectGetRoleReply() : ProjectGetRoleReply(nullptr) {}
  ~ProjectGetRoleReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectGetRoleReply(::google::protobuf::internal::ConstantInitialized);

  inline ProjectGetRoleReply(const ProjectGetRoleReply& from)
      : ProjectGetRoleReply(nullptr, from) {}
  ProjectGetRoleReply(ProjectGetRoleReply&& from) noexcept
    : ProjectGetRoleReply() {
    *this = ::std::move(from);
  }

  inline ProjectGetRoleReply& operator=(const ProjectGetRoleReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectGetRoleReply& operator=(ProjectGetRoleReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectGetRoleReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectGetRoleReply* internal_default_instance() {
    return reinterpret_cast<const ProjectGetRoleReply*>(
               &_ProjectGetRoleReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(ProjectGetRoleReply& a, ProjectGetRoleReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectGetRoleReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectGetRoleReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectGetRoleReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectGetRoleReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectGetRoleReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectGetRoleReply& from) {
    ProjectGetRoleReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectGetRoleReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectGetRoleReply";
  }
  protected:
  explicit ProjectGetRoleReply(::google::protobuf::Arena* arena);
  ProjectGetRoleReply(::google::protobuf::Arena* arena, const ProjectGetRoleReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
  };
  // required .SDMS.ProjectRole role = 1;
  bool has_role() const;
  void clear_role() ;
  ::SDMS::ProjectRole role() const;
  void set_role(::SDMS::ProjectRole value);

  private:
  ::SDMS::ProjectRole _internal_role() const;
  void _internal_set_role(::SDMS::ProjectRole value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectGetRoleReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int role_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectDeleteRequest) */ {
 public:
  inline ProjectDeleteRequest() : ProjectDeleteRequest(nullptr) {}
  ~ProjectDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProjectDeleteRequest(const ProjectDeleteRequest& from)
      : ProjectDeleteRequest(nullptr, from) {}
  ProjectDeleteRequest(ProjectDeleteRequest&& from) noexcept
    : ProjectDeleteRequest() {
    *this = ::std::move(from);
  }

  inline ProjectDeleteRequest& operator=(const ProjectDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectDeleteRequest& operator=(ProjectDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectDeleteRequest*>(
               &_ProjectDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(ProjectDeleteRequest& a, ProjectDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectDeleteRequest& from) {
    ProjectDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectDeleteRequest";
  }
  protected:
  explicit ProjectDeleteRequest(::google::protobuf::Arena* arena);
  ProjectDeleteRequest(::google::protobuf::Arena* arena, const ProjectDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectCreateRequest) */ {
 public:
  inline ProjectCreateRequest() : ProjectCreateRequest(nullptr) {}
  ~ProjectCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProjectCreateRequest(const ProjectCreateRequest& from)
      : ProjectCreateRequest(nullptr, from) {}
  ProjectCreateRequest(ProjectCreateRequest&& from) noexcept
    : ProjectCreateRequest() {
    *this = ::std::move(from);
  }

  inline ProjectCreateRequest& operator=(const ProjectCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectCreateRequest& operator=(ProjectCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectCreateRequest* internal_default_instance() {
    return reinterpret_cast<const ProjectCreateRequest*>(
               &_ProjectCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ProjectCreateRequest& a, ProjectCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectCreateRequest& from) {
    ProjectCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectCreateRequest";
  }
  protected:
  explicit ProjectCreateRequest(::google::protobuf::Arena* arena);
  ProjectCreateRequest(::google::protobuf::Arena* arena, const ProjectCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminFieldNumber = 4,
    kMemberFieldNumber = 5,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 3,
  };
  // repeated string admin = 4;
  int admin_size() const;
  private:
  int _internal_admin_size() const;

  public:
  void clear_admin() ;
  const std::string& admin(int index) const;
  std::string* mutable_admin(int index);
  void set_admin(int index, const std::string& value);
  void set_admin(int index, std::string&& value);
  void set_admin(int index, const char* value);
  void set_admin(int index, const char* value, std::size_t size);
  void set_admin(int index, absl::string_view value);
  std::string* add_admin();
  void add_admin(const std::string& value);
  void add_admin(std::string&& value);
  void add_admin(const char* value);
  void add_admin(const char* value, std::size_t size);
  void add_admin(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_admin();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_admin();

  public:
  // repeated string member = 5;
  int member_size() const;
  private:
  int _internal_member_size() const;

  public:
  void clear_member() ;
  const std::string& member(int index) const;
  std::string* mutable_member(int index);
  void set_member(int index, const std::string& value);
  void set_member(int index, std::string&& value);
  void set_member(int index, const char* value);
  void set_member(int index, const char* value, std::size_t size);
  void set_member(int index, absl::string_view value);
  std::string* add_member();
  void add_member(const std::string& value);
  void add_member(std::string&& value);
  void add_member(const char* value);
  void add_member(const char* value, std::size_t size);
  void add_member(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& member() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_member();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_member() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_member();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> admin_;
    ::google::protobuf::RepeatedPtrField<std::string> member_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class NoteViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.NoteViewRequest) */ {
 public:
  inline NoteViewRequest() : NoteViewRequest(nullptr) {}
  ~NoteViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoteViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline NoteViewRequest(const NoteViewRequest& from)
      : NoteViewRequest(nullptr, from) {}
  NoteViewRequest(NoteViewRequest&& from) noexcept
    : NoteViewRequest() {
    *this = ::std::move(from);
  }

  inline NoteViewRequest& operator=(const NoteViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteViewRequest& operator=(NoteViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteViewRequest* internal_default_instance() {
    return reinterpret_cast<const NoteViewRequest*>(
               &_NoteViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(NoteViewRequest& a, NoteViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoteViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoteViewRequest& from) {
    NoteViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoteViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.NoteViewRequest";
  }
  protected:
  explicit NoteViewRequest(::google::protobuf::Arena* arena);
  NoteViewRequest(::google::protobuf::Arena* arena, const NoteViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.NoteViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class NoteUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.NoteUpdateRequest) */ {
 public:
  inline NoteUpdateRequest() : NoteUpdateRequest(nullptr) {}
  ~NoteUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoteUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline NoteUpdateRequest(const NoteUpdateRequest& from)
      : NoteUpdateRequest(nullptr, from) {}
  NoteUpdateRequest(NoteUpdateRequest&& from) noexcept
    : NoteUpdateRequest() {
    *this = ::std::move(from);
  }

  inline NoteUpdateRequest& operator=(const NoteUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteUpdateRequest& operator=(NoteUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const NoteUpdateRequest*>(
               &_NoteUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(NoteUpdateRequest& a, NoteUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoteUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoteUpdateRequest& from) {
    NoteUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoteUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.NoteUpdateRequest";
  }
  protected:
  explicit NoteUpdateRequest(::google::protobuf::Arena* arena);
  NoteUpdateRequest(::google::protobuf::Arena* arena, const NoteUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCommentFieldNumber = 2,
    kNewTitleFieldNumber = 5,
    kNewTypeFieldNumber = 3,
    kNewStateFieldNumber = 4,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string comment = 2;
  bool has_comment() const;
  void clear_comment() ;
  const std::string& comment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comment(Arg_&& arg, Args_... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* value);

  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(
      const std::string& value);
  std::string* _internal_mutable_comment();

  public:
  // optional string new_title = 5;
  bool has_new_title() const;
  void clear_new_title() ;
  const std::string& new_title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_title(Arg_&& arg, Args_... args);
  std::string* mutable_new_title();
  PROTOBUF_NODISCARD std::string* release_new_title();
  void set_allocated_new_title(std::string* value);

  private:
  const std::string& _internal_new_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_title(
      const std::string& value);
  std::string* _internal_mutable_new_title();

  public:
  // optional .SDMS.NoteType new_type = 3;
  bool has_new_type() const;
  void clear_new_type() ;
  ::SDMS::NoteType new_type() const;
  void set_new_type(::SDMS::NoteType value);

  private:
  ::SDMS::NoteType _internal_new_type() const;
  void _internal_set_new_type(::SDMS::NoteType value);

  public:
  // optional .SDMS.NoteState new_state = 4;
  bool has_new_state() const;
  void clear_new_state() ;
  ::SDMS::NoteState new_state() const;
  void set_new_state(::SDMS::NoteState value);

  private:
  ::SDMS::NoteState _internal_new_state() const;
  void _internal_set_new_state(::SDMS::NoteState value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.NoteUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr comment_;
    ::google::protobuf::internal::ArenaStringPtr new_title_;
    int new_type_;
    int new_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class NoteListBySubjectRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.NoteListBySubjectRequest) */ {
 public:
  inline NoteListBySubjectRequest() : NoteListBySubjectRequest(nullptr) {}
  ~NoteListBySubjectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoteListBySubjectRequest(::google::protobuf::internal::ConstantInitialized);

  inline NoteListBySubjectRequest(const NoteListBySubjectRequest& from)
      : NoteListBySubjectRequest(nullptr, from) {}
  NoteListBySubjectRequest(NoteListBySubjectRequest&& from) noexcept
    : NoteListBySubjectRequest() {
    *this = ::std::move(from);
  }

  inline NoteListBySubjectRequest& operator=(const NoteListBySubjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteListBySubjectRequest& operator=(NoteListBySubjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteListBySubjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteListBySubjectRequest* internal_default_instance() {
    return reinterpret_cast<const NoteListBySubjectRequest*>(
               &_NoteListBySubjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(NoteListBySubjectRequest& a, NoteListBySubjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteListBySubjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteListBySubjectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteListBySubjectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoteListBySubjectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteListBySubjectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoteListBySubjectRequest& from) {
    NoteListBySubjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoteListBySubjectRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.NoteListBySubjectRequest";
  }
  protected:
  explicit NoteListBySubjectRequest(::google::protobuf::Arena* arena);
  NoteListBySubjectRequest(::google::protobuf::Arena* arena, const NoteListBySubjectRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
  };
  // required string subject = 1;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.NoteListBySubjectRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class NoteCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.NoteCreateRequest) */ {
 public:
  inline NoteCreateRequest() : NoteCreateRequest(nullptr) {}
  ~NoteCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoteCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline NoteCreateRequest(const NoteCreateRequest& from)
      : NoteCreateRequest(nullptr, from) {}
  NoteCreateRequest(NoteCreateRequest&& from) noexcept
    : NoteCreateRequest() {
    *this = ::std::move(from);
  }

  inline NoteCreateRequest& operator=(const NoteCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteCreateRequest& operator=(NoteCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteCreateRequest* internal_default_instance() {
    return reinterpret_cast<const NoteCreateRequest*>(
               &_NoteCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(NoteCreateRequest& a, NoteCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoteCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoteCreateRequest& from) {
    NoteCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoteCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.NoteCreateRequest";
  }
  protected:
  explicit NoteCreateRequest(::google::protobuf::Arena* arena);
  NoteCreateRequest(::google::protobuf::Arena* arena, const NoteCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 2,
    kTitleFieldNumber = 3,
    kCommentFieldNumber = 4,
    kTypeFieldNumber = 1,
    kActivateFieldNumber = 5,
  };
  // required string subject = 2;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // required string title = 3;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // required string comment = 4;
  bool has_comment() const;
  void clear_comment() ;
  const std::string& comment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comment(Arg_&& arg, Args_... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* value);

  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(
      const std::string& value);
  std::string* _internal_mutable_comment();

  public:
  // required .SDMS.NoteType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::SDMS::NoteType type() const;
  void set_type(::SDMS::NoteType value);

  private:
  ::SDMS::NoteType _internal_type() const;
  void _internal_set_type(::SDMS::NoteType value);

  public:
  // required bool activate = 5;
  bool has_activate() const;
  void clear_activate() ;
  bool activate() const;
  void set_activate(bool value);

  private:
  bool _internal_activate() const;
  void _internal_set_activate(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.NoteCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr comment_;
    int type_;
    bool activate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class NoteCommentEditRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.NoteCommentEditRequest) */ {
 public:
  inline NoteCommentEditRequest() : NoteCommentEditRequest(nullptr) {}
  ~NoteCommentEditRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoteCommentEditRequest(::google::protobuf::internal::ConstantInitialized);

  inline NoteCommentEditRequest(const NoteCommentEditRequest& from)
      : NoteCommentEditRequest(nullptr, from) {}
  NoteCommentEditRequest(NoteCommentEditRequest&& from) noexcept
    : NoteCommentEditRequest() {
    *this = ::std::move(from);
  }

  inline NoteCommentEditRequest& operator=(const NoteCommentEditRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteCommentEditRequest& operator=(NoteCommentEditRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteCommentEditRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteCommentEditRequest* internal_default_instance() {
    return reinterpret_cast<const NoteCommentEditRequest*>(
               &_NoteCommentEditRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(NoteCommentEditRequest& a, NoteCommentEditRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteCommentEditRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteCommentEditRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteCommentEditRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoteCommentEditRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteCommentEditRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoteCommentEditRequest& from) {
    NoteCommentEditRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoteCommentEditRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.NoteCommentEditRequest";
  }
  protected:
  explicit NoteCommentEditRequest(::google::protobuf::Arena* arena);
  NoteCommentEditRequest(::google::protobuf::Arena* arena, const NoteCommentEditRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCommentFieldNumber = 3,
    kCommentIdxFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string comment = 3;
  bool has_comment() const;
  void clear_comment() ;
  const std::string& comment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comment(Arg_&& arg, Args_... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* value);

  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(
      const std::string& value);
  std::string* _internal_mutable_comment();

  public:
  // required uint32 comment_idx = 2;
  bool has_comment_idx() const;
  void clear_comment_idx() ;
  ::uint32_t comment_idx() const;
  void set_comment_idx(::uint32_t value);

  private:
  ::uint32_t _internal_comment_idx() const;
  void _internal_set_comment_idx(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.NoteCommentEditRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr comment_;
    ::uint32_t comment_idx_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class MetadataValidateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.MetadataValidateRequest) */ {
 public:
  inline MetadataValidateRequest() : MetadataValidateRequest(nullptr) {}
  ~MetadataValidateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MetadataValidateRequest(::google::protobuf::internal::ConstantInitialized);

  inline MetadataValidateRequest(const MetadataValidateRequest& from)
      : MetadataValidateRequest(nullptr, from) {}
  MetadataValidateRequest(MetadataValidateRequest&& from) noexcept
    : MetadataValidateRequest() {
    *this = ::std::move(from);
  }

  inline MetadataValidateRequest& operator=(const MetadataValidateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataValidateRequest& operator=(MetadataValidateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataValidateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataValidateRequest* internal_default_instance() {
    return reinterpret_cast<const MetadataValidateRequest*>(
               &_MetadataValidateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(MetadataValidateRequest& a, MetadataValidateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataValidateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataValidateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataValidateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataValidateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MetadataValidateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MetadataValidateRequest& from) {
    MetadataValidateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MetadataValidateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.MetadataValidateRequest";
  }
  protected:
  explicit MetadataValidateRequest(::google::protobuf::Arena* arena);
  MetadataValidateRequest(::google::protobuf::Arena* arena, const MetadataValidateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSchIdFieldNumber = 2,
  };
  // required string metadata = 1;
  bool has_metadata() const;
  void clear_metadata() ;
  const std::string& metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* value);

  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(
      const std::string& value);
  std::string* _internal_mutable_metadata();

  public:
  // required string sch_id = 2;
  bool has_sch_id() const;
  void clear_sch_id() ;
  const std::string& sch_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sch_id(Arg_&& arg, Args_... args);
  std::string* mutable_sch_id();
  PROTOBUF_NODISCARD std::string* release_sch_id();
  void set_allocated_sch_id(std::string* value);

  private:
  const std::string& _internal_sch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sch_id(
      const std::string& value);
  std::string* _internal_mutable_sch_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.MetadataValidateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr metadata_;
    ::google::protobuf::internal::ArenaStringPtr sch_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class MetadataValidateReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.MetadataValidateReply) */ {
 public:
  inline MetadataValidateReply() : MetadataValidateReply(nullptr) {}
  ~MetadataValidateReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MetadataValidateReply(::google::protobuf::internal::ConstantInitialized);

  inline MetadataValidateReply(const MetadataValidateReply& from)
      : MetadataValidateReply(nullptr, from) {}
  MetadataValidateReply(MetadataValidateReply&& from) noexcept
    : MetadataValidateReply() {
    *this = ::std::move(from);
  }

  inline MetadataValidateReply& operator=(const MetadataValidateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataValidateReply& operator=(MetadataValidateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataValidateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataValidateReply* internal_default_instance() {
    return reinterpret_cast<const MetadataValidateReply*>(
               &_MetadataValidateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(MetadataValidateReply& a, MetadataValidateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataValidateReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataValidateReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataValidateReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataValidateReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MetadataValidateReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MetadataValidateReply& from) {
    MetadataValidateReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MetadataValidateReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.MetadataValidateReply";
  }
  protected:
  explicit MetadataValidateReply(::google::protobuf::Arena* arena);
  MetadataValidateReply(::google::protobuf::Arena* arena, const MetadataValidateReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 1,
  };
  // optional string errors = 1;
  bool has_errors() const;
  void clear_errors() ;
  const std::string& errors() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errors(Arg_&& arg, Args_... args);
  std::string* mutable_errors();
  PROTOBUF_NODISCARD std::string* release_errors();
  void set_allocated_errors(std::string* value);

  private:
  const std::string& _internal_errors() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errors(
      const std::string& value);
  std::string* _internal_mutable_errors();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.MetadataValidateReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr errors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GroupViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GroupViewRequest) */ {
 public:
  inline GroupViewRequest() : GroupViewRequest(nullptr) {}
  ~GroupViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline GroupViewRequest(const GroupViewRequest& from)
      : GroupViewRequest(nullptr, from) {}
  GroupViewRequest(GroupViewRequest&& from) noexcept
    : GroupViewRequest() {
    *this = ::std::move(from);
  }

  inline GroupViewRequest& operator=(const GroupViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupViewRequest& operator=(GroupViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupViewRequest* internal_default_instance() {
    return reinterpret_cast<const GroupViewRequest*>(
               &_GroupViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(GroupViewRequest& a, GroupViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupViewRequest& from) {
    GroupViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GroupViewRequest";
  }
  protected:
  explicit GroupViewRequest(::google::protobuf::Arena* arena);
  GroupViewRequest(::google::protobuf::Arena* arena, const GroupViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kGidFieldNumber = 2,
  };
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // required string gid = 2;
  bool has_gid() const;
  void clear_gid() ;
  const std::string& gid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gid(Arg_&& arg, Args_... args);
  std::string* mutable_gid();
  PROTOBUF_NODISCARD std::string* release_gid();
  void set_allocated_gid(std::string* value);

  private:
  const std::string& _internal_gid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gid(
      const std::string& value);
  std::string* _internal_mutable_gid();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GroupViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr gid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GroupUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GroupUpdateRequest) */ {
 public:
  inline GroupUpdateRequest() : GroupUpdateRequest(nullptr) {}
  ~GroupUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline GroupUpdateRequest(const GroupUpdateRequest& from)
      : GroupUpdateRequest(nullptr, from) {}
  GroupUpdateRequest(GroupUpdateRequest&& from) noexcept
    : GroupUpdateRequest() {
    *this = ::std::move(from);
  }

  inline GroupUpdateRequest& operator=(const GroupUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupUpdateRequest& operator=(GroupUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const GroupUpdateRequest*>(
               &_GroupUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(GroupUpdateRequest& a, GroupUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupUpdateRequest& from) {
    GroupUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GroupUpdateRequest";
  }
  protected:
  explicit GroupUpdateRequest(::google::protobuf::Arena* arena);
  GroupUpdateRequest(::google::protobuf::Arena* arena, const GroupUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddUidFieldNumber = 5,
    kRemUidFieldNumber = 6,
    kUidFieldNumber = 1,
    kGidFieldNumber = 2,
    kTitleFieldNumber = 3,
    kDescFieldNumber = 4,
  };
  // repeated string add_uid = 5;
  int add_uid_size() const;
  private:
  int _internal_add_uid_size() const;

  public:
  void clear_add_uid() ;
  const std::string& add_uid(int index) const;
  std::string* mutable_add_uid(int index);
  void set_add_uid(int index, const std::string& value);
  void set_add_uid(int index, std::string&& value);
  void set_add_uid(int index, const char* value);
  void set_add_uid(int index, const char* value, std::size_t size);
  void set_add_uid(int index, absl::string_view value);
  std::string* add_add_uid();
  void add_add_uid(const std::string& value);
  void add_add_uid(std::string&& value);
  void add_add_uid(const char* value);
  void add_add_uid(const char* value, std::size_t size);
  void add_add_uid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& add_uid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_add_uid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_add_uid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_add_uid();

  public:
  // repeated string rem_uid = 6;
  int rem_uid_size() const;
  private:
  int _internal_rem_uid_size() const;

  public:
  void clear_rem_uid() ;
  const std::string& rem_uid(int index) const;
  std::string* mutable_rem_uid(int index);
  void set_rem_uid(int index, const std::string& value);
  void set_rem_uid(int index, std::string&& value);
  void set_rem_uid(int index, const char* value);
  void set_rem_uid(int index, const char* value, std::size_t size);
  void set_rem_uid(int index, absl::string_view value);
  std::string* add_rem_uid();
  void add_rem_uid(const std::string& value);
  void add_rem_uid(std::string&& value);
  void add_rem_uid(const char* value);
  void add_rem_uid(const char* value, std::size_t size);
  void add_rem_uid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& rem_uid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_rem_uid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_rem_uid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_rem_uid();

  public:
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // required string gid = 2;
  bool has_gid() const;
  void clear_gid() ;
  const std::string& gid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gid(Arg_&& arg, Args_... args);
  std::string* mutable_gid();
  PROTOBUF_NODISCARD std::string* release_gid();
  void set_allocated_gid(std::string* value);

  private:
  const std::string& _internal_gid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gid(
      const std::string& value);
  std::string* _internal_mutable_gid();

  public:
  // optional string title = 3;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 4;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GroupUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> add_uid_;
    ::google::protobuf::RepeatedPtrField<std::string> rem_uid_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr gid_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GroupListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GroupListRequest) */ {
 public:
  inline GroupListRequest() : GroupListRequest(nullptr) {}
  ~GroupListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupListRequest(::google::protobuf::internal::ConstantInitialized);

  inline GroupListRequest(const GroupListRequest& from)
      : GroupListRequest(nullptr, from) {}
  GroupListRequest(GroupListRequest&& from) noexcept
    : GroupListRequest() {
    *this = ::std::move(from);
  }

  inline GroupListRequest& operator=(const GroupListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupListRequest& operator=(GroupListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupListRequest* internal_default_instance() {
    return reinterpret_cast<const GroupListRequest*>(
               &_GroupListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(GroupListRequest& a, GroupListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupListRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupListRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupListRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupListRequest& from) {
    GroupListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupListRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GroupListRequest";
  }
  protected:
  explicit GroupListRequest(::google::protobuf::Arena* arena);
  GroupListRequest(::google::protobuf::Arena* arena, const GroupListRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GroupListRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GroupDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GroupDeleteRequest) */ {
 public:
  inline GroupDeleteRequest() : GroupDeleteRequest(nullptr) {}
  ~GroupDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline GroupDeleteRequest(const GroupDeleteRequest& from)
      : GroupDeleteRequest(nullptr, from) {}
  GroupDeleteRequest(GroupDeleteRequest&& from) noexcept
    : GroupDeleteRequest() {
    *this = ::std::move(from);
  }

  inline GroupDeleteRequest& operator=(const GroupDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupDeleteRequest& operator=(GroupDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const GroupDeleteRequest*>(
               &_GroupDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(GroupDeleteRequest& a, GroupDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupDeleteRequest& from) {
    GroupDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GroupDeleteRequest";
  }
  protected:
  explicit GroupDeleteRequest(::google::protobuf::Arena* arena);
  GroupDeleteRequest(::google::protobuf::Arena* arena, const GroupDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kGidFieldNumber = 2,
  };
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // required string gid = 2;
  bool has_gid() const;
  void clear_gid() ;
  const std::string& gid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gid(Arg_&& arg, Args_... args);
  std::string* mutable_gid();
  PROTOBUF_NODISCARD std::string* release_gid();
  void set_allocated_gid(std::string* value);

  private:
  const std::string& _internal_gid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gid(
      const std::string& value);
  std::string* _internal_mutable_gid();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GroupDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr gid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GetPermsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GetPermsRequest) */ {
 public:
  inline GetPermsRequest() : GetPermsRequest(nullptr) {}
  ~GetPermsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPermsRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetPermsRequest(const GetPermsRequest& from)
      : GetPermsRequest(nullptr, from) {}
  GetPermsRequest(GetPermsRequest&& from) noexcept
    : GetPermsRequest() {
    *this = ::std::move(from);
  }

  inline GetPermsRequest& operator=(const GetPermsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPermsRequest& operator=(GetPermsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPermsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPermsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPermsRequest*>(
               &_GetPermsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetPermsRequest& a, GetPermsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPermsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPermsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPermsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPermsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPermsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPermsRequest& from) {
    GetPermsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPermsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GetPermsRequest";
  }
  protected:
  explicit GetPermsRequest(::google::protobuf::Arena* arena);
  GetPermsRequest(::google::protobuf::Arena* arena, const GetPermsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPermsFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional uint32 perms = 2;
  bool has_perms() const;
  void clear_perms() ;
  ::uint32_t perms() const;
  void set_perms(::uint32_t value);

  private:
  ::uint32_t _internal_perms() const;
  void _internal_set_perms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GetPermsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::uint32_t perms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GetPermsReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GetPermsReply) */ {
 public:
  inline GetPermsReply() : GetPermsReply(nullptr) {}
  ~GetPermsReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPermsReply(::google::protobuf::internal::ConstantInitialized);

  inline GetPermsReply(const GetPermsReply& from)
      : GetPermsReply(nullptr, from) {}
  GetPermsReply(GetPermsReply&& from) noexcept
    : GetPermsReply() {
    *this = ::std::move(from);
  }

  inline GetPermsReply& operator=(const GetPermsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPermsReply& operator=(GetPermsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPermsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPermsReply* internal_default_instance() {
    return reinterpret_cast<const GetPermsReply*>(
               &_GetPermsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetPermsReply& a, GetPermsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPermsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPermsReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPermsReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPermsReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPermsReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPermsReply& from) {
    GetPermsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPermsReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GetPermsReply";
  }
  protected:
  explicit GetPermsReply(::google::protobuf::Arena* arena);
  GetPermsReply(::google::protobuf::Arena* arena, const GetPermsReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrantedFieldNumber = 1,
  };
  // required uint32 granted = 1;
  bool has_granted() const;
  void clear_granted() ;
  ::uint32_t granted() const;
  void set_granted(::uint32_t value);

  private:
  ::uint32_t _internal_granted() const;
  void _internal_set_granted(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GetPermsReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t granted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GenerateCredentialsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GenerateCredentialsRequest) */ {
 public:
  inline GenerateCredentialsRequest() : GenerateCredentialsRequest(nullptr) {}
  ~GenerateCredentialsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenerateCredentialsRequest(::google::protobuf::internal::ConstantInitialized);

  inline GenerateCredentialsRequest(const GenerateCredentialsRequest& from)
      : GenerateCredentialsRequest(nullptr, from) {}
  GenerateCredentialsRequest(GenerateCredentialsRequest&& from) noexcept
    : GenerateCredentialsRequest() {
    *this = ::std::move(from);
  }

  inline GenerateCredentialsRequest& operator=(const GenerateCredentialsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateCredentialsRequest& operator=(GenerateCredentialsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateCredentialsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateCredentialsRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateCredentialsRequest*>(
               &_GenerateCredentialsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GenerateCredentialsRequest& a, GenerateCredentialsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateCredentialsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateCredentialsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateCredentialsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateCredentialsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenerateCredentialsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenerateCredentialsRequest& from) {
    GenerateCredentialsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenerateCredentialsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GenerateCredentialsRequest";
  }
  protected:
  explicit GenerateCredentialsRequest(::google::protobuf::Arena* arena);
  GenerateCredentialsRequest(::google::protobuf::Arena* arena, const GenerateCredentialsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 1,
    kUidFieldNumber = 2,
  };
  // optional string domain = 1;
  bool has_domain() const;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // optional uint32 uid = 2;
  bool has_uid() const;
  void clear_uid() ;
  ::uint32_t uid() const;
  void set_uid(::uint32_t value);

  private:
  ::uint32_t _internal_uid() const;
  void _internal_set_uid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GenerateCredentialsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::uint32_t uid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GenerateCredentialsReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GenerateCredentialsReply) */ {
 public:
  inline GenerateCredentialsReply() : GenerateCredentialsReply(nullptr) {}
  ~GenerateCredentialsReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenerateCredentialsReply(::google::protobuf::internal::ConstantInitialized);

  inline GenerateCredentialsReply(const GenerateCredentialsReply& from)
      : GenerateCredentialsReply(nullptr, from) {}
  GenerateCredentialsReply(GenerateCredentialsReply&& from) noexcept
    : GenerateCredentialsReply() {
    *this = ::std::move(from);
  }

  inline GenerateCredentialsReply& operator=(const GenerateCredentialsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateCredentialsReply& operator=(GenerateCredentialsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateCredentialsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateCredentialsReply* internal_default_instance() {
    return reinterpret_cast<const GenerateCredentialsReply*>(
               &_GenerateCredentialsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GenerateCredentialsReply& a, GenerateCredentialsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateCredentialsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateCredentialsReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateCredentialsReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateCredentialsReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenerateCredentialsReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenerateCredentialsReply& from) {
    GenerateCredentialsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenerateCredentialsReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GenerateCredentialsReply";
  }
  protected:
  explicit GenerateCredentialsReply(::google::protobuf::Arena* arena);
  GenerateCredentialsReply(::google::protobuf::Arena* arena, const GenerateCredentialsReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kPrivKeyFieldNumber = 2,
  };
  // required string pub_key = 1;
  bool has_pub_key() const;
  void clear_pub_key() ;
  const std::string& pub_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pub_key(Arg_&& arg, Args_... args);
  std::string* mutable_pub_key();
  PROTOBUF_NODISCARD std::string* release_pub_key();
  void set_allocated_pub_key(std::string* value);

  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(
      const std::string& value);
  std::string* _internal_mutable_pub_key();

  public:
  // required string priv_key = 2;
  bool has_priv_key() const;
  void clear_priv_key() ;
  const std::string& priv_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_priv_key(Arg_&& arg, Args_... args);
  std::string* mutable_priv_key();
  PROTOBUF_NODISCARD std::string* release_priv_key();
  void set_allocated_priv_key(std::string* value);

  private:
  const std::string& _internal_priv_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_priv_key(
      const std::string& value);
  std::string* _internal_mutable_priv_key();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GenerateCredentialsReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr pub_key_;
    ::google::protobuf::internal::ArenaStringPtr priv_key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class DataPutRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.DataPutRequest) */ {
 public:
  inline DataPutRequest() : DataPutRequest(nullptr) {}
  ~DataPutRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataPutRequest(::google::protobuf::internal::ConstantInitialized);

  inline DataPutRequest(const DataPutRequest& from)
      : DataPutRequest(nullptr, from) {}
  DataPutRequest(DataPutRequest&& from) noexcept
    : DataPutRequest() {
    *this = ::std::move(from);
  }

  inline DataPutRequest& operator=(const DataPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPutRequest& operator=(DataPutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataPutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataPutRequest* internal_default_instance() {
    return reinterpret_cast<const DataPutRequest*>(
               &_DataPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(DataPutRequest& a, DataPutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPutRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataPutRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataPutRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataPutRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataPutRequest& from) {
    DataPutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataPutRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.DataPutRequest";
  }
  protected:
  explicit DataPutRequest(::google::protobuf::Arena* arena);
  DataPutRequest(::google::protobuf::Arena* arena, const DataPutRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
    kExtFieldNumber = 4,
    kEncryptFieldNumber = 3,
    kCheckFieldNumber = 5,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string path = 2;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional string ext = 4;
  bool has_ext() const;
  void clear_ext() ;
  const std::string& ext() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ext(Arg_&& arg, Args_... args);
  std::string* mutable_ext();
  PROTOBUF_NODISCARD std::string* release_ext();
  void set_allocated_ext(std::string* value);

  private:
  const std::string& _internal_ext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ext(
      const std::string& value);
  std::string* _internal_mutable_ext();

  public:
  // optional .SDMS.Encryption encrypt = 3;
  bool has_encrypt() const;
  void clear_encrypt() ;
  ::SDMS::Encryption encrypt() const;
  void set_encrypt(::SDMS::Encryption value);

  private:
  ::SDMS::Encryption _internal_encrypt() const;
  void _internal_set_encrypt(::SDMS::Encryption value);

  public:
  // optional bool check = 5;
  bool has_check() const;
  void clear_check() ;
  bool check() const;
  void set_check(bool value);

  private:
  bool _internal_check() const;
  void _internal_set_check(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.DataPutRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr ext_;
    int encrypt_;
    bool check_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class DataPathRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.DataPathRequest) */ {
 public:
  inline DataPathRequest() : DataPathRequest(nullptr) {}
  ~DataPathRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataPathRequest(::google::protobuf::internal::ConstantInitialized);

  inline DataPathRequest(const DataPathRequest& from)
      : DataPathRequest(nullptr, from) {}
  DataPathRequest(DataPathRequest&& from) noexcept
    : DataPathRequest() {
    *this = ::std::move(from);
  }

  inline DataPathRequest& operator=(const DataPathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPathRequest& operator=(DataPathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataPathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataPathRequest* internal_default_instance() {
    return reinterpret_cast<const DataPathRequest*>(
               &_DataPathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DataPathRequest& a, DataPathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPathRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataPathRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataPathRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataPathRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataPathRequest& from) {
    DataPathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataPathRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.DataPathRequest";
  }
  protected:
  explicit DataPathRequest(::google::protobuf::Arena* arena);
  DataPathRequest(::google::protobuf::Arena* arena, const DataPathRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDomainFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string domain = 2;
  bool has_domain() const;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.DataPathRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class DataPathReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.DataPathReply) */ {
 public:
  inline DataPathReply() : DataPathReply(nullptr) {}
  ~DataPathReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataPathReply(::google::protobuf::internal::ConstantInitialized);

  inline DataPathReply(const DataPathReply& from)
      : DataPathReply(nullptr, from) {}
  DataPathReply(DataPathReply&& from) noexcept
    : DataPathReply() {
    *this = ::std::move(from);
  }

  inline DataPathReply& operator=(const DataPathReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPathReply& operator=(DataPathReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataPathReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataPathReply* internal_default_instance() {
    return reinterpret_cast<const DataPathReply*>(
               &_DataPathReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(DataPathReply& a, DataPathReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPathReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPathReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataPathReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataPathReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataPathReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataPathReply& from) {
    DataPathReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataPathReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.DataPathReply";
  }
  protected:
  explicit DataPathReply(::google::protobuf::Arena* arena);
  DataPathReply(::google::protobuf::Arena* arena, const DataPathReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // required string path = 1;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.DataPathReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class DataGetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.DataGetRequest) */ {
 public:
  inline DataGetRequest() : DataGetRequest(nullptr) {}
  ~DataGetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataGetRequest(::google::protobuf::internal::ConstantInitialized);

  inline DataGetRequest(const DataGetRequest& from)
      : DataGetRequest(nullptr, from) {}
  DataGetRequest(DataGetRequest&& from) noexcept
    : DataGetRequest() {
    *this = ::std::move(from);
  }

  inline DataGetRequest& operator=(const DataGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataGetRequest& operator=(DataGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataGetRequest* internal_default_instance() {
    return reinterpret_cast<const DataGetRequest*>(
               &_DataGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DataGetRequest& a, DataGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataGetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataGetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataGetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataGetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataGetRequest& from) {
    DataGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataGetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.DataGetRequest";
  }
  protected:
  explicit DataGetRequest(::google::protobuf::Arena* arena);
  DataGetRequest(::google::protobuf::Arena* arena, const DataGetRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
    kEncryptFieldNumber = 3,
    kOrigFnameFieldNumber = 4,
    kCheckFieldNumber = 5,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // optional string path = 2;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional .SDMS.Encryption encrypt = 3;
  bool has_encrypt() const;
  void clear_encrypt() ;
  ::SDMS::Encryption encrypt() const;
  void set_encrypt(::SDMS::Encryption value);

  private:
  ::SDMS::Encryption _internal_encrypt() const;
  void _internal_set_encrypt(::SDMS::Encryption value);

  public:
  // optional bool orig_fname = 4;
  bool has_orig_fname() const;
  void clear_orig_fname() ;
  bool orig_fname() const;
  void set_orig_fname(bool value);

  private:
  bool _internal_orig_fname() const;
  void _internal_set_orig_fname(bool value);

  public:
  // optional bool check = 5;
  bool has_check() const;
  void clear_check() ;
  bool check() const;
  void set_check(bool value);

  private:
  bool _internal_check() const;
  void _internal_set_check(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.DataGetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    int encrypt_;
    bool orig_fname_;
    bool check_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class DataDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.DataDeleteRequest) */ {
 public:
  inline DataDeleteRequest() : DataDeleteRequest(nullptr) {}
  ~DataDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline DataDeleteRequest(const DataDeleteRequest& from)
      : DataDeleteRequest(nullptr, from) {}
  DataDeleteRequest(DataDeleteRequest&& from) noexcept
    : DataDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DataDeleteRequest& operator=(const DataDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataDeleteRequest& operator=(DataDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DataDeleteRequest*>(
               &_DataDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DataDeleteRequest& a, DataDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataDeleteRequest& from) {
    DataDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.DataDeleteRequest";
  }
  protected:
  explicit DataDeleteRequest(::google::protobuf::Arena* arena);
  DataDeleteRequest(::google::protobuf::Arena* arena, const DataDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.DataDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollWriteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollWriteRequest) */ {
 public:
  inline CollWriteRequest() : CollWriteRequest(nullptr) {}
  ~CollWriteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollWriteRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollWriteRequest(const CollWriteRequest& from)
      : CollWriteRequest(nullptr, from) {}
  CollWriteRequest(CollWriteRequest&& from) noexcept
    : CollWriteRequest() {
    *this = ::std::move(from);
  }

  inline CollWriteRequest& operator=(const CollWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollWriteRequest& operator=(CollWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollWriteRequest* internal_default_instance() {
    return reinterpret_cast<const CollWriteRequest*>(
               &_CollWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CollWriteRequest& a, CollWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollWriteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollWriteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollWriteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollWriteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollWriteRequest& from) {
    CollWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollWriteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollWriteRequest";
  }
  protected:
  explicit CollWriteRequest(::google::protobuf::Arena* arena);
  CollWriteRequest(::google::protobuf::Arena* arena, const CollWriteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddFieldNumber = 2,
    kRemFieldNumber = 3,
    kIdFieldNumber = 1,
    kRemAllFieldNumber = 4,
  };
  // repeated string add = 2;
  int add_size() const;
  private:
  int _internal_add_size() const;

  public:
  void clear_add() ;
  const std::string& add(int index) const;
  std::string* mutable_add(int index);
  void set_add(int index, const std::string& value);
  void set_add(int index, std::string&& value);
  void set_add(int index, const char* value);
  void set_add(int index, const char* value, std::size_t size);
  void set_add(int index, absl::string_view value);
  std::string* add_add();
  void add_add(const std::string& value);
  void add_add(std::string&& value);
  void add_add(const char* value);
  void add_add(const char* value, std::size_t size);
  void add_add(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_add();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_add();

  public:
  // repeated string rem = 3;
  int rem_size() const;
  private:
  int _internal_rem_size() const;

  public:
  void clear_rem() ;
  const std::string& rem(int index) const;
  std::string* mutable_rem(int index);
  void set_rem(int index, const std::string& value);
  void set_rem(int index, std::string&& value);
  void set_rem(int index, const char* value);
  void set_rem(int index, const char* value, std::size_t size);
  void set_rem(int index, absl::string_view value);
  std::string* add_rem();
  void add_rem(const std::string& value);
  void add_rem(std::string&& value);
  void add_rem(const char* value);
  void add_rem(const char* value, std::size_t size);
  void add_rem(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& rem() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_rem();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_rem() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_rem();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional bool rem_all = 4;
  bool has_rem_all() const;
  void clear_rem_all() ;
  bool rem_all() const;
  void set_rem_all(bool value);

  private:
  bool _internal_rem_all() const;
  void _internal_set_rem_all(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollWriteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> add_;
    ::google::protobuf::RepeatedPtrField<std::string> rem_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    bool rem_all_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollViewRequest) */ {
 public:
  inline CollViewRequest() : CollViewRequest(nullptr) {}
  ~CollViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollViewRequest(const CollViewRequest& from)
      : CollViewRequest(nullptr, from) {}
  CollViewRequest(CollViewRequest&& from) noexcept
    : CollViewRequest() {
    *this = ::std::move(from);
  }

  inline CollViewRequest& operator=(const CollViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollViewRequest& operator=(CollViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollViewRequest* internal_default_instance() {
    return reinterpret_cast<const CollViewRequest*>(
               &_CollViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CollViewRequest& a, CollViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollViewRequest& from) {
    CollViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollViewRequest";
  }
  protected:
  explicit CollViewRequest(::google::protobuf::Arena* arena);
  CollViewRequest(::google::protobuf::Arena* arena, const CollViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollUpdateRequest) */ {
 public:
  inline CollUpdateRequest() : CollUpdateRequest(nullptr) {}
  ~CollUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollUpdateRequest(const CollUpdateRequest& from)
      : CollUpdateRequest(nullptr, from) {}
  CollUpdateRequest(CollUpdateRequest&& from) noexcept
    : CollUpdateRequest() {
    *this = ::std::move(from);
  }

  inline CollUpdateRequest& operator=(const CollUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollUpdateRequest& operator=(CollUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const CollUpdateRequest*>(
               &_CollUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CollUpdateRequest& a, CollUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollUpdateRequest& from) {
    CollUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollUpdateRequest";
  }
  protected:
  explicit CollUpdateRequest(::google::protobuf::Arena* arena);
  CollUpdateRequest(::google::protobuf::Arena* arena, const CollUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 7,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 3,
    kAliasFieldNumber = 4,
    kTopicFieldNumber = 6,
    kTagsClearFieldNumber = 8,
  };
  // repeated string tags = 7;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string alias = 4;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional string topic = 6;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // optional bool tags_clear = 8;
  bool has_tags_clear() const;
  void clear_tags_clear() ;
  bool tags_clear() const;
  void set_tags_clear(bool value);

  private:
  bool _internal_tags_clear() const;
  void _internal_set_tags_clear(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    bool tags_clear_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollReadRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollReadRequest) */ {
 public:
  inline CollReadRequest() : CollReadRequest(nullptr) {}
  ~CollReadRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollReadRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollReadRequest(const CollReadRequest& from)
      : CollReadRequest(nullptr, from) {}
  CollReadRequest(CollReadRequest&& from) noexcept
    : CollReadRequest() {
    *this = ::std::move(from);
  }

  inline CollReadRequest& operator=(const CollReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollReadRequest& operator=(CollReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollReadRequest* internal_default_instance() {
    return reinterpret_cast<const CollReadRequest*>(
               &_CollReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CollReadRequest& a, CollReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollReadRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollReadRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollReadRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollReadRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollReadRequest& from) {
    CollReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollReadRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollReadRequest";
  }
  protected:
  explicit CollReadRequest(::google::protobuf::Arena* arena);
  CollReadRequest(::google::protobuf::Arena* arena, const CollReadRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDetailsFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kCountFieldNumber = 5,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional bool details = 3;
  bool has_details() const;
  void clear_details() ;
  bool details() const;
  void set_details(bool value);

  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);

  public:
  // optional uint32 offset = 4;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 5;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollReadRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    bool details_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollMoveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollMoveRequest) */ {
 public:
  inline CollMoveRequest() : CollMoveRequest(nullptr) {}
  ~CollMoveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollMoveRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollMoveRequest(const CollMoveRequest& from)
      : CollMoveRequest(nullptr, from) {}
  CollMoveRequest(CollMoveRequest&& from) noexcept
    : CollMoveRequest() {
    *this = ::std::move(from);
  }

  inline CollMoveRequest& operator=(const CollMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollMoveRequest& operator=(CollMoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollMoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollMoveRequest* internal_default_instance() {
    return reinterpret_cast<const CollMoveRequest*>(
               &_CollMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CollMoveRequest& a, CollMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollMoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollMoveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollMoveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollMoveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollMoveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollMoveRequest& from) {
    CollMoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollMoveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollMoveRequest";
  }
  protected:
  explicit CollMoveRequest(::google::protobuf::Arena* arena);
  CollMoveRequest(::google::protobuf::Arena* arena, const CollMoveRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 3,
    kSrcIdFieldNumber = 1,
    kDstIdFieldNumber = 2,
  };
  // repeated string item = 3;
  int item_size() const;
  private:
  int _internal_item_size() const;

  public:
  void clear_item() ;
  const std::string& item(int index) const;
  std::string* mutable_item(int index);
  void set_item(int index, const std::string& value);
  void set_item(int index, std::string&& value);
  void set_item(int index, const char* value);
  void set_item(int index, const char* value, std::size_t size);
  void set_item(int index, absl::string_view value);
  std::string* add_item();
  void add_item(const std::string& value);
  void add_item(std::string&& value);
  void add_item(const char* value);
  void add_item(const char* value, std::size_t size);
  void add_item(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& item() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_item();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_item() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_item();

  public:
  // required string src_id = 1;
  bool has_src_id() const;
  void clear_src_id() ;
  const std::string& src_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_id(Arg_&& arg, Args_... args);
  std::string* mutable_src_id();
  PROTOBUF_NODISCARD std::string* release_src_id();
  void set_allocated_src_id(std::string* value);

  private:
  const std::string& _internal_src_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_id(
      const std::string& value);
  std::string* _internal_mutable_src_id();

  public:
  // required string dst_id = 2;
  bool has_dst_id() const;
  void clear_dst_id() ;
  const std::string& dst_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_id(Arg_&& arg, Args_... args);
  std::string* mutable_dst_id();
  PROTOBUF_NODISCARD std::string* release_dst_id();
  void set_allocated_dst_id(std::string* value);

  private:
  const std::string& _internal_dst_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_id(
      const std::string& value);
  std::string* _internal_mutable_dst_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollMoveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> item_;
    ::google::protobuf::internal::ArenaStringPtr src_id_;
    ::google::protobuf::internal::ArenaStringPtr dst_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollListPublishedRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollListPublishedRequest) */ {
 public:
  inline CollListPublishedRequest() : CollListPublishedRequest(nullptr) {}
  ~CollListPublishedRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollListPublishedRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollListPublishedRequest(const CollListPublishedRequest& from)
      : CollListPublishedRequest(nullptr, from) {}
  CollListPublishedRequest(CollListPublishedRequest&& from) noexcept
    : CollListPublishedRequest() {
    *this = ::std::move(from);
  }

  inline CollListPublishedRequest& operator=(const CollListPublishedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollListPublishedRequest& operator=(CollListPublishedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollListPublishedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollListPublishedRequest* internal_default_instance() {
    return reinterpret_cast<const CollListPublishedRequest*>(
               &_CollListPublishedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CollListPublishedRequest& a, CollListPublishedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollListPublishedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollListPublishedRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollListPublishedRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollListPublishedRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollListPublishedRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollListPublishedRequest& from) {
    CollListPublishedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollListPublishedRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollListPublishedRequest";
  }
  protected:
  explicit CollListPublishedRequest(::google::protobuf::Arena* arena);
  CollListPublishedRequest(::google::protobuf::Arena* arena, const CollListPublishedRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // optional string subject = 1;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollListPublishedRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    ::uint32_t offset_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollGetParentsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollGetParentsRequest) */ {
 public:
  inline CollGetParentsRequest() : CollGetParentsRequest(nullptr) {}
  ~CollGetParentsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollGetParentsRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollGetParentsRequest(const CollGetParentsRequest& from)
      : CollGetParentsRequest(nullptr, from) {}
  CollGetParentsRequest(CollGetParentsRequest&& from) noexcept
    : CollGetParentsRequest() {
    *this = ::std::move(from);
  }

  inline CollGetParentsRequest& operator=(const CollGetParentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollGetParentsRequest& operator=(CollGetParentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollGetParentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollGetParentsRequest* internal_default_instance() {
    return reinterpret_cast<const CollGetParentsRequest*>(
               &_CollGetParentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CollGetParentsRequest& a, CollGetParentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollGetParentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollGetParentsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollGetParentsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollGetParentsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollGetParentsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollGetParentsRequest& from) {
    CollGetParentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollGetParentsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollGetParentsRequest";
  }
  protected:
  explicit CollGetParentsRequest(::google::protobuf::Arena* arena);
  CollGetParentsRequest(::google::protobuf::Arena* arena, const CollGetParentsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kInclusiveFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional bool inclusive = 2;
  bool has_inclusive() const;
  void clear_inclusive() ;
  bool inclusive() const;
  void set_inclusive(bool value);

  private:
  bool _internal_inclusive() const;
  void _internal_set_inclusive(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollGetParentsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    bool inclusive_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollGetOffsetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollGetOffsetRequest) */ {
 public:
  inline CollGetOffsetRequest() : CollGetOffsetRequest(nullptr) {}
  ~CollGetOffsetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollGetOffsetRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollGetOffsetRequest(const CollGetOffsetRequest& from)
      : CollGetOffsetRequest(nullptr, from) {}
  CollGetOffsetRequest(CollGetOffsetRequest&& from) noexcept
    : CollGetOffsetRequest() {
    *this = ::std::move(from);
  }

  inline CollGetOffsetRequest& operator=(const CollGetOffsetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollGetOffsetRequest& operator=(CollGetOffsetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollGetOffsetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollGetOffsetRequest* internal_default_instance() {
    return reinterpret_cast<const CollGetOffsetRequest*>(
               &_CollGetOffsetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CollGetOffsetRequest& a, CollGetOffsetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollGetOffsetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollGetOffsetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollGetOffsetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollGetOffsetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollGetOffsetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollGetOffsetRequest& from) {
    CollGetOffsetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollGetOffsetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollGetOffsetRequest";
  }
  protected:
  explicit CollGetOffsetRequest(::google::protobuf::Arena* arena);
  CollGetOffsetRequest(::google::protobuf::Arena* arena, const CollGetOffsetRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kItemFieldNumber = 2,
    kPageSzFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string item = 2;
  bool has_item() const;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // required uint32 page_sz = 3;
  bool has_page_sz() const;
  void clear_page_sz() ;
  ::uint32_t page_sz() const;
  void set_page_sz(::uint32_t value);

  private:
  ::uint32_t _internal_page_sz() const;
  void _internal_set_page_sz(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollGetOffsetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::uint32_t page_sz_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollGetOffsetReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollGetOffsetReply) */ {
 public:
  inline CollGetOffsetReply() : CollGetOffsetReply(nullptr) {}
  ~CollGetOffsetReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollGetOffsetReply(::google::protobuf::internal::ConstantInitialized);

  inline CollGetOffsetReply(const CollGetOffsetReply& from)
      : CollGetOffsetReply(nullptr, from) {}
  CollGetOffsetReply(CollGetOffsetReply&& from) noexcept
    : CollGetOffsetReply() {
    *this = ::std::move(from);
  }

  inline CollGetOffsetReply& operator=(const CollGetOffsetReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollGetOffsetReply& operator=(CollGetOffsetReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollGetOffsetReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollGetOffsetReply* internal_default_instance() {
    return reinterpret_cast<const CollGetOffsetReply*>(
               &_CollGetOffsetReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CollGetOffsetReply& a, CollGetOffsetReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CollGetOffsetReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollGetOffsetReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollGetOffsetReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollGetOffsetReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollGetOffsetReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollGetOffsetReply& from) {
    CollGetOffsetReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollGetOffsetReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollGetOffsetReply";
  }
  protected:
  explicit CollGetOffsetReply(::google::protobuf::Arena* arena);
  CollGetOffsetReply(::google::protobuf::Arena* arena, const CollGetOffsetReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kItemFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string item = 2;
  bool has_item() const;
  void clear_item() ;
  const std::string& item() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item(Arg_&& arg, Args_... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* value);

  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(
      const std::string& value);
  std::string* _internal_mutable_item();

  public:
  // required uint32 offset = 3;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollGetOffsetReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr item_;
    ::uint32_t offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollDeleteRequest) */ {
 public:
  inline CollDeleteRequest() : CollDeleteRequest(nullptr) {}
  ~CollDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollDeleteRequest(const CollDeleteRequest& from)
      : CollDeleteRequest(nullptr, from) {}
  CollDeleteRequest(CollDeleteRequest&& from) noexcept
    : CollDeleteRequest() {
    *this = ::std::move(from);
  }

  inline CollDeleteRequest& operator=(const CollDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollDeleteRequest& operator=(CollDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const CollDeleteRequest*>(
               &_CollDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CollDeleteRequest& a, CollDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollDeleteRequest& from) {
    CollDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollDeleteRequest";
  }
  protected:
  explicit CollDeleteRequest(::google::protobuf::Arena* arena);
  CollDeleteRequest(::google::protobuf::Arena* arena, const CollDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;

  public:
  void clear_id() ;
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, std::size_t size);
  void set_id(int index, absl::string_view value);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, std::size_t size);
  void add_id(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_id();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_id() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollCreateRequest) */ {
 public:
  inline CollCreateRequest() : CollCreateRequest(nullptr) {}
  ~CollCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline CollCreateRequest(const CollCreateRequest& from)
      : CollCreateRequest(nullptr, from) {}
  CollCreateRequest(CollCreateRequest&& from) noexcept
    : CollCreateRequest() {
    *this = ::std::move(from);
  }

  inline CollCreateRequest& operator=(const CollCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollCreateRequest& operator=(CollCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollCreateRequest* internal_default_instance() {
    return reinterpret_cast<const CollCreateRequest*>(
               &_CollCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CollCreateRequest& a, CollCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollCreateRequest& from) {
    CollCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollCreateRequest";
  }
  protected:
  explicit CollCreateRequest(::google::protobuf::Arena* arena);
  CollCreateRequest(::google::protobuf::Arena* arena, const CollCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 7,
    kTitleFieldNumber = 1,
    kDescFieldNumber = 2,
    kAliasFieldNumber = 3,
    kParentIdFieldNumber = 4,
    kTopicFieldNumber = 6,
  };
  // repeated string tags = 7;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // optional string title = 1;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 2;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string alias = 3;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional string parent_id = 4;
  bool has_parent_id() const;
  void clear_parent_id() ;
  const std::string& parent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* value);

  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(
      const std::string& value);
  std::string* _internal_mutable_parent_id();

  public:
  // optional string topic = 6;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr parent_id_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CheckPermsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CheckPermsRequest) */ {
 public:
  inline CheckPermsRequest() : CheckPermsRequest(nullptr) {}
  ~CheckPermsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckPermsRequest(::google::protobuf::internal::ConstantInitialized);

  inline CheckPermsRequest(const CheckPermsRequest& from)
      : CheckPermsRequest(nullptr, from) {}
  CheckPermsRequest(CheckPermsRequest&& from) noexcept
    : CheckPermsRequest() {
    *this = ::std::move(from);
  }

  inline CheckPermsRequest& operator=(const CheckPermsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermsRequest& operator=(CheckPermsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckPermsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckPermsRequest* internal_default_instance() {
    return reinterpret_cast<const CheckPermsRequest*>(
               &_CheckPermsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CheckPermsRequest& a, CheckPermsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckPermsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckPermsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckPermsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckPermsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckPermsRequest& from) {
    CheckPermsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckPermsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CheckPermsRequest";
  }
  protected:
  explicit CheckPermsRequest(::google::protobuf::Arena* arena);
  CheckPermsRequest(::google::protobuf::Arena* arena, const CheckPermsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPermsFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required uint32 perms = 2;
  bool has_perms() const;
  void clear_perms() ;
  ::uint32_t perms() const;
  void set_perms(::uint32_t value);

  private:
  ::uint32_t _internal_perms() const;
  void _internal_set_perms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CheckPermsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::uint32_t perms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CheckPermsReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CheckPermsReply) */ {
 public:
  inline CheckPermsReply() : CheckPermsReply(nullptr) {}
  ~CheckPermsReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckPermsReply(::google::protobuf::internal::ConstantInitialized);

  inline CheckPermsReply(const CheckPermsReply& from)
      : CheckPermsReply(nullptr, from) {}
  CheckPermsReply(CheckPermsReply&& from) noexcept
    : CheckPermsReply() {
    *this = ::std::move(from);
  }

  inline CheckPermsReply& operator=(const CheckPermsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermsReply& operator=(CheckPermsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckPermsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckPermsReply* internal_default_instance() {
    return reinterpret_cast<const CheckPermsReply*>(
               &_CheckPermsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CheckPermsReply& a, CheckPermsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckPermsReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckPermsReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckPermsReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckPermsReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckPermsReply& from) {
    CheckPermsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckPermsReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CheckPermsReply";
  }
  protected:
  explicit CheckPermsReply(::google::protobuf::Arena* arena);
  CheckPermsReply(::google::protobuf::Arena* arena, const CheckPermsReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrantedFieldNumber = 1,
  };
  // required bool granted = 1;
  bool has_granted() const;
  void clear_granted() ;
  bool granted() const;
  void set_granted(bool value);

  private:
  bool _internal_granted() const;
  void _internal_set_granted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CheckPermsReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool granted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ACLViewRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ACLViewRequest) */ {
 public:
  inline ACLViewRequest() : ACLViewRequest(nullptr) {}
  ~ACLViewRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ACLViewRequest(::google::protobuf::internal::ConstantInitialized);

  inline ACLViewRequest(const ACLViewRequest& from)
      : ACLViewRequest(nullptr, from) {}
  ACLViewRequest(ACLViewRequest&& from) noexcept
    : ACLViewRequest() {
    *this = ::std::move(from);
  }

  inline ACLViewRequest& operator=(const ACLViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACLViewRequest& operator=(ACLViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACLViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACLViewRequest* internal_default_instance() {
    return reinterpret_cast<const ACLViewRequest*>(
               &_ACLViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(ACLViewRequest& a, ACLViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ACLViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACLViewRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACLViewRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACLViewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACLViewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ACLViewRequest& from) {
    ACLViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ACLViewRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ACLViewRequest";
  }
  protected:
  explicit ACLViewRequest(::google::protobuf::Arena* arena);
  ACLViewRequest(::google::protobuf::Arena* arena, const ACLViewRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ACLViewRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ACLUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ACLUpdateRequest) */ {
 public:
  inline ACLUpdateRequest() : ACLUpdateRequest(nullptr) {}
  ~ACLUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ACLUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline ACLUpdateRequest(const ACLUpdateRequest& from)
      : ACLUpdateRequest(nullptr, from) {}
  ACLUpdateRequest(ACLUpdateRequest&& from) noexcept
    : ACLUpdateRequest() {
    *this = ::std::move(from);
  }

  inline ACLUpdateRequest& operator=(const ACLUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACLUpdateRequest& operator=(ACLUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACLUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACLUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const ACLUpdateRequest*>(
               &_ACLUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(ACLUpdateRequest& a, ACLUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ACLUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACLUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACLUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACLUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACLUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ACLUpdateRequest& from) {
    ACLUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ACLUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ACLUpdateRequest";
  }
  protected:
  explicit ACLUpdateRequest(::google::protobuf::Arena* arena);
  ACLUpdateRequest(::google::protobuf::Arena* arena, const ACLUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRulesFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string rules = 2;
  bool has_rules() const;
  void clear_rules() ;
  const std::string& rules() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rules(Arg_&& arg, Args_... args);
  std::string* mutable_rules();
  PROTOBUF_NODISCARD std::string* release_rules();
  void set_allocated_rules(std::string* value);

  private:
  const std::string& _internal_rules() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rules(
      const std::string& value);
  std::string* _internal_mutable_rules();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ACLUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr rules_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ACLSharedListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ACLSharedListRequest) */ {
 public:
  inline ACLSharedListRequest() : ACLSharedListRequest(nullptr) {}
  ~ACLSharedListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ACLSharedListRequest(::google::protobuf::internal::ConstantInitialized);

  inline ACLSharedListRequest(const ACLSharedListRequest& from)
      : ACLSharedListRequest(nullptr, from) {}
  ACLSharedListRequest(ACLSharedListRequest&& from) noexcept
    : ACLSharedListRequest() {
    *this = ::std::move(from);
  }

  inline ACLSharedListRequest& operator=(const ACLSharedListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACLSharedListRequest& operator=(ACLSharedListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACLSharedListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACLSharedListRequest* internal_default_instance() {
    return reinterpret_cast<const ACLSharedListRequest*>(
               &_ACLSharedListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(ACLSharedListRequest& a, ACLSharedListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ACLSharedListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACLSharedListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACLSharedListRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACLSharedListRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACLSharedListRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ACLSharedListRequest& from) {
    ACLSharedListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ACLSharedListRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ACLSharedListRequest";
  }
  protected:
  explicit ACLSharedListRequest(::google::protobuf::Arena* arena);
  ACLSharedListRequest(::google::protobuf::Arena* arena, const ACLSharedListRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncUsersFieldNumber = 2,
    kIncProjectsFieldNumber = 3,
  };
  // optional bool inc_users = 2;
  bool has_inc_users() const;
  void clear_inc_users() ;
  bool inc_users() const;
  void set_inc_users(bool value);

  private:
  bool _internal_inc_users() const;
  void _internal_set_inc_users(bool value);

  public:
  // optional bool inc_projects = 3;
  bool has_inc_projects() const;
  void clear_inc_projects() ;
  bool inc_projects() const;
  void set_inc_projects(bool value);

  private:
  bool _internal_inc_projects() const;
  void _internal_set_inc_projects(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ACLSharedListRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool inc_users_;
    bool inc_projects_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ACLSharedListItemsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ACLSharedListItemsRequest) */ {
 public:
  inline ACLSharedListItemsRequest() : ACLSharedListItemsRequest(nullptr) {}
  ~ACLSharedListItemsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ACLSharedListItemsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ACLSharedListItemsRequest(const ACLSharedListItemsRequest& from)
      : ACLSharedListItemsRequest(nullptr, from) {}
  ACLSharedListItemsRequest(ACLSharedListItemsRequest&& from) noexcept
    : ACLSharedListItemsRequest() {
    *this = ::std::move(from);
  }

  inline ACLSharedListItemsRequest& operator=(const ACLSharedListItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACLSharedListItemsRequest& operator=(ACLSharedListItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACLSharedListItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACLSharedListItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ACLSharedListItemsRequest*>(
               &_ACLSharedListItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ACLSharedListItemsRequest& a, ACLSharedListItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ACLSharedListItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACLSharedListItemsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACLSharedListItemsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACLSharedListItemsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACLSharedListItemsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ACLSharedListItemsRequest& from) {
    ACLSharedListItemsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ACLSharedListItemsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ACLSharedListItemsRequest";
  }
  protected:
  explicit ACLSharedListItemsRequest(::google::protobuf::Arena* arena);
  ACLSharedListItemsRequest(::google::protobuf::Arena* arena, const ACLSharedListItemsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 2,
  };
  // required string owner = 2;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* value);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ACLSharedListItemsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TopicDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TopicDataReply) */ {
 public:
  inline TopicDataReply() : TopicDataReply(nullptr) {}
  ~TopicDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TopicDataReply(::google::protobuf::internal::ConstantInitialized);

  inline TopicDataReply(const TopicDataReply& from)
      : TopicDataReply(nullptr, from) {}
  TopicDataReply(TopicDataReply&& from) noexcept
    : TopicDataReply() {
    *this = ::std::move(from);
  }

  inline TopicDataReply& operator=(const TopicDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicDataReply& operator=(TopicDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicDataReply* internal_default_instance() {
    return reinterpret_cast<const TopicDataReply*>(
               &_TopicDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(TopicDataReply& a, TopicDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopicDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopicDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TopicDataReply& from) {
    TopicDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopicDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TopicDataReply";
  }
  protected:
  explicit TopicDataReply(::google::protobuf::Arena* arena);
  TopicDataReply(::google::protobuf::Arena* arena, const TopicDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
    kTotalFieldNumber = 4,
  };
  // repeated .SDMS.TopicData topic = 1;
  int topic_size() const;
  private:
  int _internal_topic_size() const;

  public:
  void clear_topic() ;
  ::SDMS::TopicData* mutable_topic(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::TopicData >*
      mutable_topic();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>& _internal_topic() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>* _internal_mutable_topic();
  public:
  const ::SDMS::TopicData& topic(int index) const;
  ::SDMS::TopicData* add_topic();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::TopicData >&
      topic() const;
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // optional uint32 total = 4;
  bool has_total() const;
  void clear_total() ;
  ::uint32_t total() const;
  void set_total(::uint32_t value);

  private:
  ::uint32_t _internal_total() const;
  void _internal_set_total(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TopicDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::TopicData > topic_;
    ::uint32_t offset_;
    ::uint32_t count_;
    ::uint32_t total_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TaskDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TaskDataReply) */ {
 public:
  inline TaskDataReply() : TaskDataReply(nullptr) {}
  ~TaskDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskDataReply(::google::protobuf::internal::ConstantInitialized);

  inline TaskDataReply(const TaskDataReply& from)
      : TaskDataReply(nullptr, from) {}
  TaskDataReply(TaskDataReply&& from) noexcept
    : TaskDataReply() {
    *this = ::std::move(from);
  }

  inline TaskDataReply& operator=(const TaskDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskDataReply& operator=(TaskDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskDataReply* internal_default_instance() {
    return reinterpret_cast<const TaskDataReply*>(
               &_TaskDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(TaskDataReply& a, TaskDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TaskDataReply& from) {
    TaskDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TaskDataReply";
  }
  protected:
  explicit TaskDataReply(::google::protobuf::Arena* arena);
  TaskDataReply(::google::protobuf::Arena* arena, const TaskDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 1,
  };
  // repeated .SDMS.TaskData task = 1;
  int task_size() const;
  private:
  int _internal_task_size() const;

  public:
  void clear_task() ;
  ::SDMS::TaskData* mutable_task(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::TaskData >*
      mutable_task();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::TaskData>& _internal_task() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::TaskData>* _internal_mutable_task();
  public:
  const ::SDMS::TaskData& task(int index) const;
  ::SDMS::TaskData* add_task();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::TaskData >&
      task() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TaskDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::TaskData > task_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class TagDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.TagDataReply) */ {
 public:
  inline TagDataReply() : TagDataReply(nullptr) {}
  ~TagDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TagDataReply(::google::protobuf::internal::ConstantInitialized);

  inline TagDataReply(const TagDataReply& from)
      : TagDataReply(nullptr, from) {}
  TagDataReply(TagDataReply&& from) noexcept
    : TagDataReply() {
    *this = ::std::move(from);
  }

  inline TagDataReply& operator=(const TagDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagDataReply& operator=(TagDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagDataReply* internal_default_instance() {
    return reinterpret_cast<const TagDataReply*>(
               &_TagDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(TagDataReply& a, TagDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(TagDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TagDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TagDataReply& from) {
    TagDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TagDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.TagDataReply";
  }
  protected:
  explicit TagDataReply(::google::protobuf::Arena* arena);
  TagDataReply(::google::protobuf::Arena* arena, const TagDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
    kTotalFieldNumber = 4,
  };
  // repeated .SDMS.TagData tag = 1;
  int tag_size() const;
  private:
  int _internal_tag_size() const;

  public:
  void clear_tag() ;
  ::SDMS::TagData* mutable_tag(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::TagData >*
      mutable_tag();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::TagData>& _internal_tag() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::TagData>* _internal_mutable_tag();
  public:
  const ::SDMS::TagData& tag(int index) const;
  ::SDMS::TagData* add_tag();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::TagData >&
      tag() const;
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // optional uint32 total = 4;
  bool has_total() const;
  void clear_total() ;
  ::uint32_t total() const;
  void set_total(::uint32_t value);

  private:
  ::uint32_t _internal_total() const;
  void _internal_set_total(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.TagDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::TagData > tag_;
    ::uint32_t offset_;
    ::uint32_t count_;
    ::uint32_t total_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class SchemaDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.SchemaDataReply) */ {
 public:
  inline SchemaDataReply() : SchemaDataReply(nullptr) {}
  ~SchemaDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaDataReply(::google::protobuf::internal::ConstantInitialized);

  inline SchemaDataReply(const SchemaDataReply& from)
      : SchemaDataReply(nullptr, from) {}
  SchemaDataReply(SchemaDataReply&& from) noexcept
    : SchemaDataReply() {
    *this = ::std::move(from);
  }

  inline SchemaDataReply& operator=(const SchemaDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaDataReply& operator=(SchemaDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaDataReply* internal_default_instance() {
    return reinterpret_cast<const SchemaDataReply*>(
               &_SchemaDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(SchemaDataReply& a, SchemaDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SchemaDataReply& from) {
    SchemaDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SchemaDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.SchemaDataReply";
  }
  protected:
  explicit SchemaDataReply(::google::protobuf::Arena* arena);
  SchemaDataReply(::google::protobuf::Arena* arena, const SchemaDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
    kTotalFieldNumber = 4,
  };
  // repeated .SDMS.SchemaData schema = 1;
  int schema_size() const;
  private:
  int _internal_schema_size() const;

  public:
  void clear_schema() ;
  ::SDMS::SchemaData* mutable_schema(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData >*
      mutable_schema();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>& _internal_schema() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>* _internal_mutable_schema();
  public:
  const ::SDMS::SchemaData& schema(int index) const;
  ::SDMS::SchemaData* add_schema();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData >&
      schema() const;
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // optional uint32 total = 4;
  bool has_total() const;
  void clear_total() ;
  ::uint32_t total() const;
  void set_total(::uint32_t value);

  private:
  ::uint32_t _internal_total() const;
  void _internal_set_total(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.SchemaDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData > schema_;
    ::uint32_t offset_;
    ::uint32_t count_;
    ::uint32_t total_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoDataSizeReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoDataSizeReply) */ {
 public:
  inline RepoDataSizeReply() : RepoDataSizeReply(nullptr) {}
  ~RepoDataSizeReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoDataSizeReply(::google::protobuf::internal::ConstantInitialized);

  inline RepoDataSizeReply(const RepoDataSizeReply& from)
      : RepoDataSizeReply(nullptr, from) {}
  RepoDataSizeReply(RepoDataSizeReply&& from) noexcept
    : RepoDataSizeReply() {
    *this = ::std::move(from);
  }

  inline RepoDataSizeReply& operator=(const RepoDataSizeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoDataSizeReply& operator=(RepoDataSizeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoDataSizeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoDataSizeReply* internal_default_instance() {
    return reinterpret_cast<const RepoDataSizeReply*>(
               &_RepoDataSizeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(RepoDataSizeReply& a, RepoDataSizeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoDataSizeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoDataSizeReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoDataSizeReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoDataSizeReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoDataSizeReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoDataSizeReply& from) {
    RepoDataSizeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoDataSizeReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoDataSizeReply";
  }
  protected:
  explicit RepoDataSizeReply(::google::protobuf::Arena* arena);
  RepoDataSizeReply(::google::protobuf::Arena* arena, const RepoDataSizeReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // repeated .SDMS.RecordDataSize size = 1;
  int size_size() const;
  private:
  int _internal_size_size() const;

  public:
  void clear_size() ;
  ::SDMS::RecordDataSize* mutable_size(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataSize >*
      mutable_size();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataSize>& _internal_size() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataSize>* _internal_mutable_size();
  public:
  const ::SDMS::RecordDataSize& size(int index) const;
  ::SDMS::RecordDataSize* add_size();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataSize >&
      size() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoDataSizeReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataSize > size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoDataReply) */ {
 public:
  inline RepoDataReply() : RepoDataReply(nullptr) {}
  ~RepoDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoDataReply(::google::protobuf::internal::ConstantInitialized);

  inline RepoDataReply(const RepoDataReply& from)
      : RepoDataReply(nullptr, from) {}
  RepoDataReply(RepoDataReply&& from) noexcept
    : RepoDataReply() {
    *this = ::std::move(from);
  }

  inline RepoDataReply& operator=(const RepoDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoDataReply& operator=(RepoDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoDataReply* internal_default_instance() {
    return reinterpret_cast<const RepoDataReply*>(
               &_RepoDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(RepoDataReply& a, RepoDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoDataReply& from) {
    RepoDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoDataReply";
  }
  protected:
  explicit RepoDataReply(::google::protobuf::Arena* arena);
  RepoDataReply(::google::protobuf::Arena* arena, const RepoDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
  };
  // repeated .SDMS.RepoData repo = 1;
  int repo_size() const;
  private:
  int _internal_repo_size() const;

  public:
  void clear_repo() ;
  ::SDMS::RepoData* mutable_repo(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::RepoData >*
      mutable_repo();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::RepoData>& _internal_repo() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::RepoData>* _internal_mutable_repo();
  public:
  const ::SDMS::RepoData& repo(int index) const;
  ::SDMS::RepoData* add_repo();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::RepoData >&
      repo() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::RepoData > repo_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoDataGetSizeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoDataGetSizeRequest) */ {
 public:
  inline RepoDataGetSizeRequest() : RepoDataGetSizeRequest(nullptr) {}
  ~RepoDataGetSizeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoDataGetSizeRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoDataGetSizeRequest(const RepoDataGetSizeRequest& from)
      : RepoDataGetSizeRequest(nullptr, from) {}
  RepoDataGetSizeRequest(RepoDataGetSizeRequest&& from) noexcept
    : RepoDataGetSizeRequest() {
    *this = ::std::move(from);
  }

  inline RepoDataGetSizeRequest& operator=(const RepoDataGetSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoDataGetSizeRequest& operator=(RepoDataGetSizeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoDataGetSizeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoDataGetSizeRequest* internal_default_instance() {
    return reinterpret_cast<const RepoDataGetSizeRequest*>(
               &_RepoDataGetSizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(RepoDataGetSizeRequest& a, RepoDataGetSizeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoDataGetSizeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoDataGetSizeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoDataGetSizeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoDataGetSizeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoDataGetSizeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoDataGetSizeRequest& from) {
    RepoDataGetSizeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoDataGetSizeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoDataGetSizeRequest";
  }
  protected:
  explicit RepoDataGetSizeRequest(::google::protobuf::Arena* arena);
  RepoDataGetSizeRequest(::google::protobuf::Arena* arena, const RepoDataGetSizeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocFieldNumber = 1,
  };
  // repeated .SDMS.RecordDataLocation loc = 1;
  int loc_size() const;
  private:
  int _internal_loc_size() const;

  public:
  void clear_loc() ;
  ::SDMS::RecordDataLocation* mutable_loc(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation >*
      mutable_loc();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>& _internal_loc() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>* _internal_mutable_loc();
  public:
  const ::SDMS::RecordDataLocation& loc(int index) const;
  ::SDMS::RecordDataLocation* add_loc();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation >&
      loc() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoDataGetSizeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation > loc_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoDataDeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoDataDeleteRequest) */ {
 public:
  inline RepoDataDeleteRequest() : RepoDataDeleteRequest(nullptr) {}
  ~RepoDataDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoDataDeleteRequest(::google::protobuf::internal::ConstantInitialized);

  inline RepoDataDeleteRequest(const RepoDataDeleteRequest& from)
      : RepoDataDeleteRequest(nullptr, from) {}
  RepoDataDeleteRequest(RepoDataDeleteRequest&& from) noexcept
    : RepoDataDeleteRequest() {
    *this = ::std::move(from);
  }

  inline RepoDataDeleteRequest& operator=(const RepoDataDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoDataDeleteRequest& operator=(RepoDataDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoDataDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoDataDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const RepoDataDeleteRequest*>(
               &_RepoDataDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(RepoDataDeleteRequest& a, RepoDataDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoDataDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoDataDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoDataDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoDataDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoDataDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoDataDeleteRequest& from) {
    RepoDataDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoDataDeleteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoDataDeleteRequest";
  }
  protected:
  explicit RepoDataDeleteRequest(::google::protobuf::Arena* arena);
  RepoDataDeleteRequest(::google::protobuf::Arena* arena, const RepoDataDeleteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocFieldNumber = 1,
  };
  // repeated .SDMS.RecordDataLocation loc = 1;
  int loc_size() const;
  private:
  int _internal_loc_size() const;

  public:
  void clear_loc() ;
  ::SDMS::RecordDataLocation* mutable_loc(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation >*
      mutable_loc();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>& _internal_loc() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>* _internal_mutable_loc();
  public:
  const ::SDMS::RecordDataLocation& loc(int index) const;
  ::SDMS::RecordDataLocation* add_loc();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation >&
      loc() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoDataDeleteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation > loc_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoCalcSizeReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoCalcSizeReply) */ {
 public:
  inline RepoCalcSizeReply() : RepoCalcSizeReply(nullptr) {}
  ~RepoCalcSizeReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoCalcSizeReply(::google::protobuf::internal::ConstantInitialized);

  inline RepoCalcSizeReply(const RepoCalcSizeReply& from)
      : RepoCalcSizeReply(nullptr, from) {}
  RepoCalcSizeReply(RepoCalcSizeReply&& from) noexcept
    : RepoCalcSizeReply() {
    *this = ::std::move(from);
  }

  inline RepoCalcSizeReply& operator=(const RepoCalcSizeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoCalcSizeReply& operator=(RepoCalcSizeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoCalcSizeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoCalcSizeReply* internal_default_instance() {
    return reinterpret_cast<const RepoCalcSizeReply*>(
               &_RepoCalcSizeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(RepoCalcSizeReply& a, RepoCalcSizeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoCalcSizeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoCalcSizeReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoCalcSizeReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoCalcSizeReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoCalcSizeReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoCalcSizeReply& from) {
    RepoCalcSizeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoCalcSizeReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoCalcSizeReply";
  }
  protected:
  explicit RepoCalcSizeReply(::google::protobuf::Arena* arena);
  RepoCalcSizeReply(::google::protobuf::Arena* arena, const RepoCalcSizeReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // repeated .SDMS.AllocStatsData stats = 1;
  int stats_size() const;
  private:
  int _internal_stats_size() const;

  public:
  void clear_stats() ;
  ::SDMS::AllocStatsData* mutable_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::AllocStatsData >*
      mutable_stats();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::AllocStatsData>& _internal_stats() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::AllocStatsData>* _internal_mutable_stats();
  public:
  const ::SDMS::AllocStatsData& stats(int index) const;
  ::SDMS::AllocStatsData* add_stats();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::AllocStatsData >&
      stats() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoCalcSizeReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::AllocStatsData > stats_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoAllocationStatsReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoAllocationStatsReply) */ {
 public:
  inline RepoAllocationStatsReply() : RepoAllocationStatsReply(nullptr) {}
  ~RepoAllocationStatsReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoAllocationStatsReply(::google::protobuf::internal::ConstantInitialized);

  inline RepoAllocationStatsReply(const RepoAllocationStatsReply& from)
      : RepoAllocationStatsReply(nullptr, from) {}
  RepoAllocationStatsReply(RepoAllocationStatsReply&& from) noexcept
    : RepoAllocationStatsReply() {
    *this = ::std::move(from);
  }

  inline RepoAllocationStatsReply& operator=(const RepoAllocationStatsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoAllocationStatsReply& operator=(RepoAllocationStatsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoAllocationStatsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoAllocationStatsReply* internal_default_instance() {
    return reinterpret_cast<const RepoAllocationStatsReply*>(
               &_RepoAllocationStatsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(RepoAllocationStatsReply& a, RepoAllocationStatsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoAllocationStatsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoAllocationStatsReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoAllocationStatsReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoAllocationStatsReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoAllocationStatsReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoAllocationStatsReply& from) {
    RepoAllocationStatsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoAllocationStatsReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoAllocationStatsReply";
  }
  protected:
  explicit RepoAllocationStatsReply(::google::protobuf::Arena* arena);
  RepoAllocationStatsReply(::google::protobuf::Arena* arena, const RepoAllocationStatsReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocFieldNumber = 1,
  };
  // required .SDMS.AllocStatsData alloc = 1;
  bool has_alloc() const;
  void clear_alloc() ;
  const ::SDMS::AllocStatsData& alloc() const;
  PROTOBUF_NODISCARD ::SDMS::AllocStatsData* release_alloc();
  ::SDMS::AllocStatsData* mutable_alloc();
  void set_allocated_alloc(::SDMS::AllocStatsData* value);
  void unsafe_arena_set_allocated_alloc(::SDMS::AllocStatsData* value);
  ::SDMS::AllocStatsData* unsafe_arena_release_alloc();

  private:
  const ::SDMS::AllocStatsData& _internal_alloc() const;
  ::SDMS::AllocStatsData* _internal_mutable_alloc();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoAllocationStatsReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SDMS::AllocStatsData* alloc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordUpdateRequest) */ {
 public:
  inline RecordUpdateRequest() : RecordUpdateRequest(nullptr) {}
  ~RecordUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordUpdateRequest(const RecordUpdateRequest& from)
      : RecordUpdateRequest(nullptr, from) {}
  RecordUpdateRequest(RecordUpdateRequest&& from) noexcept
    : RecordUpdateRequest() {
    *this = ::std::move(from);
  }

  inline RecordUpdateRequest& operator=(const RecordUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordUpdateRequest& operator=(RecordUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const RecordUpdateRequest*>(
               &_RecordUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RecordUpdateRequest& a, RecordUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordUpdateRequest& from) {
    RecordUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordUpdateRequest";
  }
  protected:
  explicit RecordUpdateRequest(::google::protobuf::Arena* arena);
  RecordUpdateRequest(::google::protobuf::Arena* arena, const RecordUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 4,
    kDepAddFieldNumber = 16,
    kDepRemFieldNumber = 17,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 3,
    kAliasFieldNumber = 6,
    kMetadataFieldNumber = 7,
    kSchIdFieldNumber = 9,
    kSourceFieldNumber = 11,
    kExtFieldNumber = 12,
    kTagsClearFieldNumber = 5,
    kMdsetFieldNumber = 8,
    kSchEnforceFieldNumber = 10,
    kExtAutoFieldNumber = 13,
  };
  // repeated string tags = 4;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // repeated .SDMS.DependencySpecData dep_add = 16;
  int dep_add_size() const;
  private:
  int _internal_dep_add_size() const;

  public:
  void clear_dep_add() ;
  ::SDMS::DependencySpecData* mutable_dep_add(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData >*
      mutable_dep_add();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>& _internal_dep_add() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>* _internal_mutable_dep_add();
  public:
  const ::SDMS::DependencySpecData& dep_add(int index) const;
  ::SDMS::DependencySpecData* add_dep_add();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData >&
      dep_add() const;
  // repeated .SDMS.DependencySpecData dep_rem = 17;
  int dep_rem_size() const;
  private:
  int _internal_dep_rem_size() const;

  public:
  void clear_dep_rem() ;
  ::SDMS::DependencySpecData* mutable_dep_rem(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData >*
      mutable_dep_rem();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>& _internal_dep_rem() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>* _internal_mutable_dep_rem();
  public:
  const ::SDMS::DependencySpecData& dep_rem(int index) const;
  ::SDMS::DependencySpecData* add_dep_rem();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData >&
      dep_rem() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string alias = 6;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional string metadata = 7;
  bool has_metadata() const;
  void clear_metadata() ;
  const std::string& metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* value);

  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(
      const std::string& value);
  std::string* _internal_mutable_metadata();

  public:
  // optional string sch_id = 9;
  bool has_sch_id() const;
  void clear_sch_id() ;
  const std::string& sch_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sch_id(Arg_&& arg, Args_... args);
  std::string* mutable_sch_id();
  PROTOBUF_NODISCARD std::string* release_sch_id();
  void set_allocated_sch_id(std::string* value);

  private:
  const std::string& _internal_sch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sch_id(
      const std::string& value);
  std::string* _internal_mutable_sch_id();

  public:
  // optional string source = 11;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* value);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // optional string ext = 12;
  bool has_ext() const;
  void clear_ext() ;
  const std::string& ext() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ext(Arg_&& arg, Args_... args);
  std::string* mutable_ext();
  PROTOBUF_NODISCARD std::string* release_ext();
  void set_allocated_ext(std::string* value);

  private:
  const std::string& _internal_ext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ext(
      const std::string& value);
  std::string* _internal_mutable_ext();

  public:
  // optional bool tags_clear = 5;
  bool has_tags_clear() const;
  void clear_tags_clear() ;
  bool tags_clear() const;
  void set_tags_clear(bool value);

  private:
  bool _internal_tags_clear() const;
  void _internal_set_tags_clear(bool value);

  public:
  // optional bool mdset = 8;
  bool has_mdset() const;
  void clear_mdset() ;
  bool mdset() const;
  void set_mdset(bool value);

  private:
  bool _internal_mdset() const;
  void _internal_set_mdset(bool value);

  public:
  // optional bool sch_enforce = 10;
  bool has_sch_enforce() const;
  void clear_sch_enforce() ;
  bool sch_enforce() const;
  void set_sch_enforce(bool value);

  private:
  bool _internal_sch_enforce() const;
  void _internal_set_sch_enforce(bool value);

  public:
  // optional bool ext_auto = 13;
  bool has_ext_auto() const;
  void clear_ext_auto() ;
  bool ext_auto() const;
  void set_ext_auto(bool value);

  private:
  bool _internal_ext_auto() const;
  void _internal_set_ext_auto(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 2,
      89, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData > dep_add_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData > dep_rem_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr metadata_;
    ::google::protobuf::internal::ArenaStringPtr sch_id_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr ext_;
    bool tags_clear_;
    bool mdset_;
    bool sch_enforce_;
    bool ext_auto_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordCreateRequest) */ {
 public:
  inline RecordCreateRequest() : RecordCreateRequest(nullptr) {}
  ~RecordCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecordCreateRequest(const RecordCreateRequest& from)
      : RecordCreateRequest(nullptr, from) {}
  RecordCreateRequest(RecordCreateRequest&& from) noexcept
    : RecordCreateRequest() {
    *this = ::std::move(from);
  }

  inline RecordCreateRequest& operator=(const RecordCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordCreateRequest& operator=(RecordCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordCreateRequest* internal_default_instance() {
    return reinterpret_cast<const RecordCreateRequest*>(
               &_RecordCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RecordCreateRequest& a, RecordCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordCreateRequest& from) {
    RecordCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordCreateRequest";
  }
  protected:
  explicit RecordCreateRequest(::google::protobuf::Arena* arena);
  RecordCreateRequest(::google::protobuf::Arena* arena, const RecordCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
    kDepsFieldNumber = 12,
    kTitleFieldNumber = 1,
    kDescFieldNumber = 2,
    kAliasFieldNumber = 4,
    kMetadataFieldNumber = 5,
    kParentIdFieldNumber = 6,
    kSourceFieldNumber = 8,
    kRepoIdFieldNumber = 9,
    kExtFieldNumber = 10,
    kSchIdFieldNumber = 13,
    kExternalFieldNumber = 7,
    kExtAutoFieldNumber = 11,
    kSchEnforceFieldNumber = 14,
  };
  // repeated string tags = 3;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // repeated .SDMS.DependencySpecData deps = 12;
  int deps_size() const;
  private:
  int _internal_deps_size() const;

  public:
  void clear_deps() ;
  ::SDMS::DependencySpecData* mutable_deps(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData >*
      mutable_deps();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>& _internal_deps() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>* _internal_mutable_deps();
  public:
  const ::SDMS::DependencySpecData& deps(int index) const;
  ::SDMS::DependencySpecData* add_deps();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData >&
      deps() const;
  // optional string title = 1;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 2;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string alias = 4;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional string metadata = 5;
  bool has_metadata() const;
  void clear_metadata() ;
  const std::string& metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* value);

  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(
      const std::string& value);
  std::string* _internal_mutable_metadata();

  public:
  // optional string parent_id = 6;
  bool has_parent_id() const;
  void clear_parent_id() ;
  const std::string& parent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* value);

  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(
      const std::string& value);
  std::string* _internal_mutable_parent_id();

  public:
  // optional string source = 8;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* value);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // optional string repo_id = 9;
  bool has_repo_id() const;
  void clear_repo_id() ;
  const std::string& repo_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo_id(Arg_&& arg, Args_... args);
  std::string* mutable_repo_id();
  PROTOBUF_NODISCARD std::string* release_repo_id();
  void set_allocated_repo_id(std::string* value);

  private:
  const std::string& _internal_repo_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo_id(
      const std::string& value);
  std::string* _internal_mutable_repo_id();

  public:
  // optional string ext = 10;
  bool has_ext() const;
  void clear_ext() ;
  const std::string& ext() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ext(Arg_&& arg, Args_... args);
  std::string* mutable_ext();
  PROTOBUF_NODISCARD std::string* release_ext();
  void set_allocated_ext(std::string* value);

  private:
  const std::string& _internal_ext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ext(
      const std::string& value);
  std::string* _internal_mutable_ext();

  public:
  // optional string sch_id = 13;
  bool has_sch_id() const;
  void clear_sch_id() ;
  const std::string& sch_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sch_id(Arg_&& arg, Args_... args);
  std::string* mutable_sch_id();
  PROTOBUF_NODISCARD std::string* release_sch_id();
  void set_allocated_sch_id(std::string* value);

  private:
  const std::string& _internal_sch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sch_id(
      const std::string& value);
  std::string* _internal_mutable_sch_id();

  public:
  // optional bool external = 7;
  bool has_external() const;
  void clear_external() ;
  bool external() const;
  void set_external(bool value);

  private:
  bool _internal_external() const;
  void _internal_set_external(bool value);

  public:
  // optional bool ext_auto = 11;
  bool has_ext_auto() const;
  void clear_ext_auto() ;
  bool ext_auto() const;
  void set_ext_auto(bool value);

  private:
  bool _internal_ext_auto() const;
  void _internal_set_ext_auto(bool value);

  public:
  // optional bool sch_enforce = 14;
  bool has_sch_enforce() const;
  void clear_sch_enforce() ;
  bool sch_enforce() const;
  void set_sch_enforce(bool value);

  private:
  bool _internal_sch_enforce() const;
  void _internal_set_sch_enforce(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 1,
      103, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::DependencySpecData > deps_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr metadata_;
    ::google::protobuf::internal::ArenaStringPtr parent_id_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr repo_id_;
    ::google::protobuf::internal::ArenaStringPtr ext_;
    ::google::protobuf::internal::ArenaStringPtr sch_id_;
    bool external_;
    bool ext_auto_;
    bool sch_enforce_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordAllocChangeReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordAllocChangeReply) */ {
 public:
  inline RecordAllocChangeReply() : RecordAllocChangeReply(nullptr) {}
  ~RecordAllocChangeReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordAllocChangeReply(::google::protobuf::internal::ConstantInitialized);

  inline RecordAllocChangeReply(const RecordAllocChangeReply& from)
      : RecordAllocChangeReply(nullptr, from) {}
  RecordAllocChangeReply(RecordAllocChangeReply&& from) noexcept
    : RecordAllocChangeReply() {
    *this = ::std::move(from);
  }

  inline RecordAllocChangeReply& operator=(const RecordAllocChangeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordAllocChangeReply& operator=(RecordAllocChangeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordAllocChangeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordAllocChangeReply* internal_default_instance() {
    return reinterpret_cast<const RecordAllocChangeReply*>(
               &_RecordAllocChangeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RecordAllocChangeReply& a, RecordAllocChangeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordAllocChangeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordAllocChangeReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordAllocChangeReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordAllocChangeReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordAllocChangeReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordAllocChangeReply& from) {
    RecordAllocChangeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordAllocChangeReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordAllocChangeReply";
  }
  protected:
  explicit RecordAllocChangeReply(::google::protobuf::Arena* arena);
  RecordAllocChangeReply(::google::protobuf::Arena* arena, const RecordAllocChangeReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 8,
    kActSizeFieldNumber = 2,
    kActCntFieldNumber = 1,
    kTotCntFieldNumber = 3,
    kDataLimitFieldNumber = 4,
    kDataSizeFieldNumber = 5,
    kRecLimitFieldNumber = 6,
    kRecCountFieldNumber = 7,
  };
  // optional .SDMS.TaskData task = 8;
  bool has_task() const;
  void clear_task() ;
  const ::SDMS::TaskData& task() const;
  PROTOBUF_NODISCARD ::SDMS::TaskData* release_task();
  ::SDMS::TaskData* mutable_task();
  void set_allocated_task(::SDMS::TaskData* value);
  void unsafe_arena_set_allocated_task(::SDMS::TaskData* value);
  ::SDMS::TaskData* unsafe_arena_release_task();

  private:
  const ::SDMS::TaskData& _internal_task() const;
  ::SDMS::TaskData* _internal_mutable_task();

  public:
  // required uint64 act_size = 2;
  bool has_act_size() const;
  void clear_act_size() ;
  ::uint64_t act_size() const;
  void set_act_size(::uint64_t value);

  private:
  ::uint64_t _internal_act_size() const;
  void _internal_set_act_size(::uint64_t value);

  public:
  // required uint32 act_cnt = 1;
  bool has_act_cnt() const;
  void clear_act_cnt() ;
  ::uint32_t act_cnt() const;
  void set_act_cnt(::uint32_t value);

  private:
  ::uint32_t _internal_act_cnt() const;
  void _internal_set_act_cnt(::uint32_t value);

  public:
  // required uint32 tot_cnt = 3;
  bool has_tot_cnt() const;
  void clear_tot_cnt() ;
  ::uint32_t tot_cnt() const;
  void set_tot_cnt(::uint32_t value);

  private:
  ::uint32_t _internal_tot_cnt() const;
  void _internal_set_tot_cnt(::uint32_t value);

  public:
  // required uint64 data_limit = 4;
  bool has_data_limit() const;
  void clear_data_limit() ;
  ::uint64_t data_limit() const;
  void set_data_limit(::uint64_t value);

  private:
  ::uint64_t _internal_data_limit() const;
  void _internal_set_data_limit(::uint64_t value);

  public:
  // required uint64 data_size = 5;
  bool has_data_size() const;
  void clear_data_size() ;
  ::uint64_t data_size() const;
  void set_data_size(::uint64_t value);

  private:
  ::uint64_t _internal_data_size() const;
  void _internal_set_data_size(::uint64_t value);

  public:
  // required uint32 rec_limit = 6;
  bool has_rec_limit() const;
  void clear_rec_limit() ;
  ::uint32_t rec_limit() const;
  void set_rec_limit(::uint32_t value);

  private:
  ::uint32_t _internal_rec_limit() const;
  void _internal_set_rec_limit(::uint32_t value);

  public:
  // required uint32 rec_count = 7;
  bool has_rec_count() const;
  void clear_rec_count() ;
  ::uint32_t rec_count() const;
  void set_rec_count(::uint32_t value);

  private:
  ::uint32_t _internal_rec_count() const;
  void _internal_set_rec_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordAllocChangeReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SDMS::TaskData* task_;
    ::uint64_t act_size_;
    ::uint32_t act_cnt_;
    ::uint32_t tot_cnt_;
    ::uint64_t data_limit_;
    ::uint64_t data_size_;
    ::uint32_t rec_limit_;
    ::uint32_t rec_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class QueryUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.QueryUpdateRequest) */ {
 public:
  inline QueryUpdateRequest() : QueryUpdateRequest(nullptr) {}
  ~QueryUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline QueryUpdateRequest(const QueryUpdateRequest& from)
      : QueryUpdateRequest(nullptr, from) {}
  QueryUpdateRequest(QueryUpdateRequest&& from) noexcept
    : QueryUpdateRequest() {
    *this = ::std::move(from);
  }

  inline QueryUpdateRequest& operator=(const QueryUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryUpdateRequest& operator=(QueryUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const QueryUpdateRequest*>(
               &_QueryUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(QueryUpdateRequest& a, QueryUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryUpdateRequest& from) {
    QueryUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.QueryUpdateRequest";
  }
  protected:
  explicit QueryUpdateRequest(::google::protobuf::Arena* arena);
  QueryUpdateRequest(::google::protobuf::Arena* arena, const QueryUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kQueryFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional .SDMS.Auth.SearchRequest query = 3;
  bool has_query() const;
  void clear_query() ;
  const ::SDMS::Auth::SearchRequest& query() const;
  PROTOBUF_NODISCARD ::SDMS::Auth::SearchRequest* release_query();
  ::SDMS::Auth::SearchRequest* mutable_query();
  void set_allocated_query(::SDMS::Auth::SearchRequest* value);
  void unsafe_arena_set_allocated_query(::SDMS::Auth::SearchRequest* value);
  ::SDMS::Auth::SearchRequest* unsafe_arena_release_query();

  private:
  const ::SDMS::Auth::SearchRequest& _internal_query() const;
  ::SDMS::Auth::SearchRequest* _internal_mutable_query();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.QueryUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::SDMS::Auth::SearchRequest* query_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class QueryDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.QueryDataReply) */ {
 public:
  inline QueryDataReply() : QueryDataReply(nullptr) {}
  ~QueryDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDataReply(::google::protobuf::internal::ConstantInitialized);

  inline QueryDataReply(const QueryDataReply& from)
      : QueryDataReply(nullptr, from) {}
  QueryDataReply(QueryDataReply&& from) noexcept
    : QueryDataReply() {
    *this = ::std::move(from);
  }

  inline QueryDataReply& operator=(const QueryDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDataReply& operator=(QueryDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDataReply* internal_default_instance() {
    return reinterpret_cast<const QueryDataReply*>(
               &_QueryDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(QueryDataReply& a, QueryDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryDataReply& from) {
    QueryDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.QueryDataReply";
  }
  protected:
  explicit QueryDataReply(::google::protobuf::Arena* arena);
  QueryDataReply(::google::protobuf::Arena* arena, const QueryDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kOwnerFieldNumber = 4,
    kQueryFieldNumber = 7,
    kCtFieldNumber = 5,
    kUtFieldNumber = 6,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // required string owner = 4;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* value);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // required .SDMS.Auth.SearchRequest query = 7;
  bool has_query() const;
  void clear_query() ;
  const ::SDMS::Auth::SearchRequest& query() const;
  PROTOBUF_NODISCARD ::SDMS::Auth::SearchRequest* release_query();
  ::SDMS::Auth::SearchRequest* mutable_query();
  void set_allocated_query(::SDMS::Auth::SearchRequest* value);
  void unsafe_arena_set_allocated_query(::SDMS::Auth::SearchRequest* value);
  ::SDMS::Auth::SearchRequest* unsafe_arena_release_query();

  private:
  const ::SDMS::Auth::SearchRequest& _internal_query() const;
  ::SDMS::Auth::SearchRequest* _internal_mutable_query();

  public:
  // required uint32 ct = 5;
  bool has_ct() const;
  void clear_ct() ;
  ::uint32_t ct() const;
  void set_ct(::uint32_t value);

  private:
  ::uint32_t _internal_ct() const;
  void _internal_set_ct(::uint32_t value);

  public:
  // required uint32 ut = 6;
  bool has_ut() const;
  void clear_ut() ;
  ::uint32_t ut() const;
  void set_ut(::uint32_t value);

  private:
  ::uint32_t _internal_ut() const;
  void _internal_set_ut(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.QueryDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    ::SDMS::Auth::SearchRequest* query_;
    ::uint32_t ct_;
    ::uint32_t ut_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class QueryCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.QueryCreateRequest) */ {
 public:
  inline QueryCreateRequest() : QueryCreateRequest(nullptr) {}
  ~QueryCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline QueryCreateRequest(const QueryCreateRequest& from)
      : QueryCreateRequest(nullptr, from) {}
  QueryCreateRequest(QueryCreateRequest&& from) noexcept
    : QueryCreateRequest() {
    *this = ::std::move(from);
  }

  inline QueryCreateRequest& operator=(const QueryCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryCreateRequest& operator=(QueryCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryCreateRequest* internal_default_instance() {
    return reinterpret_cast<const QueryCreateRequest*>(
               &_QueryCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(QueryCreateRequest& a, QueryCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryCreateRequest& from) {
    QueryCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.QueryCreateRequest";
  }
  protected:
  explicit QueryCreateRequest(::google::protobuf::Arena* arena);
  QueryCreateRequest(::google::protobuf::Arena* arena, const QueryCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kQueryFieldNumber = 2,
  };
  // required string title = 1;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // required .SDMS.Auth.SearchRequest query = 2;
  bool has_query() const;
  void clear_query() ;
  const ::SDMS::Auth::SearchRequest& query() const;
  PROTOBUF_NODISCARD ::SDMS::Auth::SearchRequest* release_query();
  ::SDMS::Auth::SearchRequest* mutable_query();
  void set_allocated_query(::SDMS::Auth::SearchRequest* value);
  void unsafe_arena_set_allocated_query(::SDMS::Auth::SearchRequest* value);
  ::SDMS::Auth::SearchRequest* unsafe_arena_release_query();

  private:
  const ::SDMS::Auth::SearchRequest& _internal_query() const;
  ::SDMS::Auth::SearchRequest* _internal_mutable_query();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.QueryCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::SDMS::Auth::SearchRequest* query_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GroupDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GroupDataReply) */ {
 public:
  inline GroupDataReply() : GroupDataReply(nullptr) {}
  ~GroupDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupDataReply(::google::protobuf::internal::ConstantInitialized);

  inline GroupDataReply(const GroupDataReply& from)
      : GroupDataReply(nullptr, from) {}
  GroupDataReply(GroupDataReply&& from) noexcept
    : GroupDataReply() {
    *this = ::std::move(from);
  }

  inline GroupDataReply& operator=(const GroupDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupDataReply& operator=(GroupDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupDataReply* internal_default_instance() {
    return reinterpret_cast<const GroupDataReply*>(
               &_GroupDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(GroupDataReply& a, GroupDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupDataReply& from) {
    GroupDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GroupDataReply";
  }
  protected:
  explicit GroupDataReply(::google::protobuf::Arena* arena);
  GroupDataReply(::google::protobuf::Arena* arena, const GroupDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // repeated .SDMS.GroupData group = 1;
  int group_size() const;
  private:
  int _internal_group_size() const;

  public:
  void clear_group() ;
  ::SDMS::GroupData* mutable_group(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::GroupData >*
      mutable_group();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::GroupData>& _internal_group() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::GroupData>* _internal_mutable_group();
  public:
  const ::SDMS::GroupData& group(int index) const;
  ::SDMS::GroupData* add_group();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::GroupData >&
      group() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GroupDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::GroupData > group_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class GroupCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.GroupCreateRequest) */ {
 public:
  inline GroupCreateRequest() : GroupCreateRequest(nullptr) {}
  ~GroupCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupCreateRequest(::google::protobuf::internal::ConstantInitialized);

  inline GroupCreateRequest(const GroupCreateRequest& from)
      : GroupCreateRequest(nullptr, from) {}
  GroupCreateRequest(GroupCreateRequest&& from) noexcept
    : GroupCreateRequest() {
    *this = ::std::move(from);
  }

  inline GroupCreateRequest& operator=(const GroupCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupCreateRequest& operator=(GroupCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupCreateRequest* internal_default_instance() {
    return reinterpret_cast<const GroupCreateRequest*>(
               &_GroupCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(GroupCreateRequest& a, GroupCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupCreateRequest& from) {
    GroupCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupCreateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.GroupCreateRequest";
  }
  protected:
  explicit GroupCreateRequest(::google::protobuf::Arena* arena);
  GroupCreateRequest(::google::protobuf::Arena* arena, const GroupCreateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // required .SDMS.GroupData group = 1;
  bool has_group() const;
  void clear_group() ;
  const ::SDMS::GroupData& group() const;
  PROTOBUF_NODISCARD ::SDMS::GroupData* release_group();
  ::SDMS::GroupData* mutable_group();
  void set_allocated_group(::SDMS::GroupData* value);
  void unsafe_arena_set_allocated_group(::SDMS::GroupData* value);
  ::SDMS::GroupData* unsafe_arena_release_group();

  private:
  const ::SDMS::GroupData& _internal_group() const;
  ::SDMS::GroupData* _internal_mutable_group();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.GroupCreateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SDMS::GroupData* group_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ACLDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ACLDataReply) */ {
 public:
  inline ACLDataReply() : ACLDataReply(nullptr) {}
  ~ACLDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ACLDataReply(::google::protobuf::internal::ConstantInitialized);

  inline ACLDataReply(const ACLDataReply& from)
      : ACLDataReply(nullptr, from) {}
  ACLDataReply(ACLDataReply&& from) noexcept
    : ACLDataReply() {
    *this = ::std::move(from);
  }

  inline ACLDataReply& operator=(const ACLDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACLDataReply& operator=(ACLDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACLDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACLDataReply* internal_default_instance() {
    return reinterpret_cast<const ACLDataReply*>(
               &_ACLDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(ACLDataReply& a, ACLDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ACLDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACLDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACLDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACLDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACLDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ACLDataReply& from) {
    ACLDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ACLDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ACLDataReply";
  }
  protected:
  explicit ACLDataReply(::google::protobuf::Arena* arena);
  ACLDataReply(::google::protobuf::Arena* arena, const ACLDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleFieldNumber = 1,
  };
  // repeated .SDMS.ACLRule rule = 1;
  int rule_size() const;
  private:
  int _internal_rule_size() const;

  public:
  void clear_rule() ;
  ::SDMS::ACLRule* mutable_rule(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::ACLRule >*
      mutable_rule();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::ACLRule>& _internal_rule() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::ACLRule>* _internal_mutable_rule();
  public:
  const ::SDMS::ACLRule& rule(int index) const;
  ::SDMS::ACLRule* add_rule();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::ACLRule >&
      rule() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ACLDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::ACLRule > rule_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RepoAllocationsReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RepoAllocationsReply) */ {
 public:
  inline RepoAllocationsReply() : RepoAllocationsReply(nullptr) {}
  ~RepoAllocationsReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoAllocationsReply(::google::protobuf::internal::ConstantInitialized);

  inline RepoAllocationsReply(const RepoAllocationsReply& from)
      : RepoAllocationsReply(nullptr, from) {}
  RepoAllocationsReply(RepoAllocationsReply&& from) noexcept
    : RepoAllocationsReply() {
    *this = ::std::move(from);
  }

  inline RepoAllocationsReply& operator=(const RepoAllocationsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoAllocationsReply& operator=(RepoAllocationsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoAllocationsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoAllocationsReply* internal_default_instance() {
    return reinterpret_cast<const RepoAllocationsReply*>(
               &_RepoAllocationsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(RepoAllocationsReply& a, RepoAllocationsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoAllocationsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoAllocationsReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoAllocationsReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoAllocationsReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoAllocationsReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoAllocationsReply& from) {
    RepoAllocationsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoAllocationsReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RepoAllocationsReply";
  }
  protected:
  explicit RepoAllocationsReply(::google::protobuf::Arena* arena);
  RepoAllocationsReply(::google::protobuf::Arena* arena, const RepoAllocationsReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocFieldNumber = 1,
  };
  // repeated .SDMS.AllocData alloc = 1;
  int alloc_size() const;
  private:
  int _internal_alloc_size() const;

  public:
  void clear_alloc() ;
  ::SDMS::AllocData* mutable_alloc(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData >*
      mutable_alloc();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>& _internal_alloc() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>* _internal_mutable_alloc();
  public:
  const ::SDMS::AllocData& alloc(int index) const;
  ::SDMS::AllocData* add_alloc();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData >&
      alloc() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RepoAllocationsReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData > alloc_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordOwnerChangeReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordOwnerChangeReply) */ {
 public:
  inline RecordOwnerChangeReply() : RecordOwnerChangeReply(nullptr) {}
  ~RecordOwnerChangeReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordOwnerChangeReply(::google::protobuf::internal::ConstantInitialized);

  inline RecordOwnerChangeReply(const RecordOwnerChangeReply& from)
      : RecordOwnerChangeReply(nullptr, from) {}
  RecordOwnerChangeReply(RecordOwnerChangeReply&& from) noexcept
    : RecordOwnerChangeReply() {
    *this = ::std::move(from);
  }

  inline RecordOwnerChangeReply& operator=(const RecordOwnerChangeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordOwnerChangeReply& operator=(RecordOwnerChangeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordOwnerChangeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordOwnerChangeReply* internal_default_instance() {
    return reinterpret_cast<const RecordOwnerChangeReply*>(
               &_RecordOwnerChangeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(RecordOwnerChangeReply& a, RecordOwnerChangeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordOwnerChangeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordOwnerChangeReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordOwnerChangeReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordOwnerChangeReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordOwnerChangeReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordOwnerChangeReply& from) {
    RecordOwnerChangeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordOwnerChangeReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordOwnerChangeReply";
  }
  protected:
  explicit RecordOwnerChangeReply(::google::protobuf::Arena* arena);
  RecordOwnerChangeReply(::google::protobuf::Arena* arena, const RecordOwnerChangeReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocFieldNumber = 4,
    kTaskFieldNumber = 8,
    kActSizeFieldNumber = 2,
    kActCntFieldNumber = 1,
    kTotCntFieldNumber = 3,
  };
  // repeated .SDMS.AllocData alloc = 4;
  int alloc_size() const;
  private:
  int _internal_alloc_size() const;

  public:
  void clear_alloc() ;
  ::SDMS::AllocData* mutable_alloc(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData >*
      mutable_alloc();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>& _internal_alloc() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>* _internal_mutable_alloc();
  public:
  const ::SDMS::AllocData& alloc(int index) const;
  ::SDMS::AllocData* add_alloc();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData >&
      alloc() const;
  // optional .SDMS.TaskData task = 8;
  bool has_task() const;
  void clear_task() ;
  const ::SDMS::TaskData& task() const;
  PROTOBUF_NODISCARD ::SDMS::TaskData* release_task();
  ::SDMS::TaskData* mutable_task();
  void set_allocated_task(::SDMS::TaskData* value);
  void unsafe_arena_set_allocated_task(::SDMS::TaskData* value);
  ::SDMS::TaskData* unsafe_arena_release_task();

  private:
  const ::SDMS::TaskData& _internal_task() const;
  ::SDMS::TaskData* _internal_mutable_task();

  public:
  // required uint64 act_size = 2;
  bool has_act_size() const;
  void clear_act_size() ;
  ::uint64_t act_size() const;
  void set_act_size(::uint64_t value);

  private:
  ::uint64_t _internal_act_size() const;
  void _internal_set_act_size(::uint64_t value);

  public:
  // required uint32 act_cnt = 1;
  bool has_act_cnt() const;
  void clear_act_cnt() ;
  ::uint32_t act_cnt() const;
  void set_act_cnt(::uint32_t value);

  private:
  ::uint32_t _internal_act_cnt() const;
  void _internal_set_act_cnt(::uint32_t value);

  public:
  // required uint32 tot_cnt = 3;
  bool has_tot_cnt() const;
  void clear_tot_cnt() ;
  ::uint32_t tot_cnt() const;
  void set_tot_cnt(::uint32_t value);

  private:
  ::uint32_t _internal_tot_cnt() const;
  void _internal_set_tot_cnt(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordOwnerChangeReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData > alloc_;
    ::SDMS::TaskData* task_;
    ::uint64_t act_size_;
    ::uint32_t act_cnt_;
    ::uint32_t tot_cnt_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class RecordDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.RecordDataReply) */ {
 public:
  inline RecordDataReply() : RecordDataReply(nullptr) {}
  ~RecordDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordDataReply(::google::protobuf::internal::ConstantInitialized);

  inline RecordDataReply(const RecordDataReply& from)
      : RecordDataReply(nullptr, from) {}
  RecordDataReply(RecordDataReply&& from) noexcept
    : RecordDataReply() {
    *this = ::std::move(from);
  }

  inline RecordDataReply& operator=(const RecordDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDataReply& operator=(RecordDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDataReply* internal_default_instance() {
    return reinterpret_cast<const RecordDataReply*>(
               &_RecordDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RecordDataReply& a, RecordDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordDataReply& from) {
    RecordDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.RecordDataReply";
  }
  protected:
  explicit RecordDataReply(::google::protobuf::Arena* arena);
  RecordDataReply(::google::protobuf::Arena* arena, const RecordDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kUpdateFieldNumber = 2,
  };
  // repeated .SDMS.RecordData data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::SDMS::RecordData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::RecordData >*
      mutable_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::RecordData>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::RecordData>* _internal_mutable_data();
  public:
  const ::SDMS::RecordData& data(int index) const;
  ::SDMS::RecordData* add_data();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::RecordData >&
      data() const;
  // repeated .SDMS.ListingData update = 2;
  int update_size() const;
  private:
  int _internal_update_size() const;

  public:
  void clear_update() ;
  ::SDMS::ListingData* mutable_update(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >*
      mutable_update();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& _internal_update() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* _internal_mutable_update();
  public:
  const ::SDMS::ListingData& update(int index) const;
  ::SDMS::ListingData* add_update();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >&
      update() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.RecordDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::RecordData > data_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData > update_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class NoteDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.NoteDataReply) */ {
 public:
  inline NoteDataReply() : NoteDataReply(nullptr) {}
  ~NoteDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoteDataReply(::google::protobuf::internal::ConstantInitialized);

  inline NoteDataReply(const NoteDataReply& from)
      : NoteDataReply(nullptr, from) {}
  NoteDataReply(NoteDataReply&& from) noexcept
    : NoteDataReply() {
    *this = ::std::move(from);
  }

  inline NoteDataReply& operator=(const NoteDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteDataReply& operator=(NoteDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteDataReply* internal_default_instance() {
    return reinterpret_cast<const NoteDataReply*>(
               &_NoteDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(NoteDataReply& a, NoteDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoteDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoteDataReply& from) {
    NoteDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoteDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.NoteDataReply";
  }
  protected:
  explicit NoteDataReply(::google::protobuf::Arena* arena);
  NoteDataReply(::google::protobuf::Arena* arena, const NoteDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoteFieldNumber = 1,
    kUpdateFieldNumber = 2,
  };
  // repeated .SDMS.NoteData note = 1;
  int note_size() const;
  private:
  int _internal_note_size() const;

  public:
  void clear_note() ;
  ::SDMS::NoteData* mutable_note(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::NoteData >*
      mutable_note();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::NoteData>& _internal_note() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::NoteData>* _internal_mutable_note();
  public:
  const ::SDMS::NoteData& note(int index) const;
  ::SDMS::NoteData* add_note();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::NoteData >&
      note() const;
  // repeated .SDMS.ListingData update = 2;
  int update_size() const;
  private:
  int _internal_update_size() const;

  public:
  void clear_update() ;
  ::SDMS::ListingData* mutable_update(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >*
      mutable_update();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& _internal_update() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* _internal_mutable_update();
  public:
  const ::SDMS::ListingData& update(int index) const;
  ::SDMS::ListingData* add_update();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >&
      update() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.NoteDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::NoteData > note_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData > update_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ListingReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ListingReply) */ {
 public:
  inline ListingReply() : ListingReply(nullptr) {}
  ~ListingReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListingReply(::google::protobuf::internal::ConstantInitialized);

  inline ListingReply(const ListingReply& from)
      : ListingReply(nullptr, from) {}
  ListingReply(ListingReply&& from) noexcept
    : ListingReply() {
    *this = ::std::move(from);
  }

  inline ListingReply& operator=(const ListingReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListingReply& operator=(ListingReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListingReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListingReply* internal_default_instance() {
    return reinterpret_cast<const ListingReply*>(
               &_ListingReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ListingReply& a, ListingReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ListingReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListingReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListingReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListingReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListingReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListingReply& from) {
    ListingReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListingReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ListingReply";
  }
  protected:
  explicit ListingReply(::google::protobuf::Arena* arena);
  ListingReply(::google::protobuf::Arena* arena, const ListingReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
    kTotalFieldNumber = 4,
  };
  // repeated .SDMS.ListingData item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;

  public:
  void clear_item() ;
  ::SDMS::ListingData* mutable_item(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >*
      mutable_item();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& _internal_item() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* _internal_mutable_item();
  public:
  const ::SDMS::ListingData& item(int index) const;
  ::SDMS::ListingData* add_item();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >&
      item() const;
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // optional uint32 total = 4;
  bool has_total() const;
  void clear_total() ;
  ::uint32_t total() const;
  void set_total(::uint32_t value);

  private:
  ::uint32_t _internal_total() const;
  void _internal_set_total(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ListingReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData > item_;
    ::uint32_t offset_;
    ::uint32_t count_;
    ::uint32_t total_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class DataPutReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.DataPutReply) */ {
 public:
  inline DataPutReply() : DataPutReply(nullptr) {}
  ~DataPutReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataPutReply(::google::protobuf::internal::ConstantInitialized);

  inline DataPutReply(const DataPutReply& from)
      : DataPutReply(nullptr, from) {}
  DataPutReply(DataPutReply&& from) noexcept
    : DataPutReply() {
    *this = ::std::move(from);
  }

  inline DataPutReply& operator=(const DataPutReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPutReply& operator=(DataPutReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataPutReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataPutReply* internal_default_instance() {
    return reinterpret_cast<const DataPutReply*>(
               &_DataPutReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(DataPutReply& a, DataPutReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPutReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPutReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataPutReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataPutReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataPutReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataPutReply& from) {
    DataPutReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataPutReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.DataPutReply";
  }
  protected:
  explicit DataPutReply(::google::protobuf::Arena* arena);
  DataPutReply(::google::protobuf::Arena* arena, const DataPutReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kTaskFieldNumber = 2,
  };
  // required .SDMS.RecordData item = 1;
  bool has_item() const;
  void clear_item() ;
  const ::SDMS::RecordData& item() const;
  PROTOBUF_NODISCARD ::SDMS::RecordData* release_item();
  ::SDMS::RecordData* mutable_item();
  void set_allocated_item(::SDMS::RecordData* value);
  void unsafe_arena_set_allocated_item(::SDMS::RecordData* value);
  ::SDMS::RecordData* unsafe_arena_release_item();

  private:
  const ::SDMS::RecordData& _internal_item() const;
  ::SDMS::RecordData* _internal_mutable_item();

  public:
  // optional .SDMS.TaskData task = 2;
  bool has_task() const;
  void clear_task() ;
  const ::SDMS::TaskData& task() const;
  PROTOBUF_NODISCARD ::SDMS::TaskData* release_task();
  ::SDMS::TaskData* mutable_task();
  void set_allocated_task(::SDMS::TaskData* value);
  void unsafe_arena_set_allocated_task(::SDMS::TaskData* value);
  ::SDMS::TaskData* unsafe_arena_release_task();

  private:
  const ::SDMS::TaskData& _internal_task() const;
  ::SDMS::TaskData* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.DataPutReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SDMS::RecordData* item_;
    ::SDMS::TaskData* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class DataGetReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.DataGetReply) */ {
 public:
  inline DataGetReply() : DataGetReply(nullptr) {}
  ~DataGetReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataGetReply(::google::protobuf::internal::ConstantInitialized);

  inline DataGetReply(const DataGetReply& from)
      : DataGetReply(nullptr, from) {}
  DataGetReply(DataGetReply&& from) noexcept
    : DataGetReply() {
    *this = ::std::move(from);
  }

  inline DataGetReply& operator=(const DataGetReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataGetReply& operator=(DataGetReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataGetReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataGetReply* internal_default_instance() {
    return reinterpret_cast<const DataGetReply*>(
               &_DataGetReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(DataGetReply& a, DataGetReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DataGetReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataGetReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataGetReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataGetReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataGetReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataGetReply& from) {
    DataGetReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataGetReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.DataGetReply";
  }
  protected:
  explicit DataGetReply(::google::protobuf::Arena* arena);
  DataGetReply(::google::protobuf::Arena* arena, const DataGetReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kTaskFieldNumber = 2,
  };
  // repeated .SDMS.ListingData item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;

  public:
  void clear_item() ;
  ::SDMS::ListingData* mutable_item(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >*
      mutable_item();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& _internal_item() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* _internal_mutable_item();
  public:
  const ::SDMS::ListingData& item(int index) const;
  ::SDMS::ListingData* add_item();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >&
      item() const;
  // optional .SDMS.TaskData task = 2;
  bool has_task() const;
  void clear_task() ;
  const ::SDMS::TaskData& task() const;
  PROTOBUF_NODISCARD ::SDMS::TaskData* release_task();
  ::SDMS::TaskData* mutable_task();
  void set_allocated_task(::SDMS::TaskData* value);
  void unsafe_arena_set_allocated_task(::SDMS::TaskData* value);
  ::SDMS::TaskData* unsafe_arena_release_task();

  private:
  const ::SDMS::TaskData& _internal_task() const;
  ::SDMS::TaskData* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.DataGetReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData > item_;
    ::SDMS::TaskData* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollDataReply) */ {
 public:
  inline CollDataReply() : CollDataReply(nullptr) {}
  ~CollDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollDataReply(::google::protobuf::internal::ConstantInitialized);

  inline CollDataReply(const CollDataReply& from)
      : CollDataReply(nullptr, from) {}
  CollDataReply(CollDataReply&& from) noexcept
    : CollDataReply() {
    *this = ::std::move(from);
  }

  inline CollDataReply& operator=(const CollDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollDataReply& operator=(CollDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollDataReply* internal_default_instance() {
    return reinterpret_cast<const CollDataReply*>(
               &_CollDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CollDataReply& a, CollDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CollDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollDataReply& from) {
    CollDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollDataReply";
  }
  protected:
  explicit CollDataReply(::google::protobuf::Arena* arena);
  CollDataReply(::google::protobuf::Arena* arena, const CollDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollFieldNumber = 1,
    kUpdateFieldNumber = 2,
  };
  // repeated .SDMS.CollData coll = 1;
  int coll_size() const;
  private:
  int _internal_coll_size() const;

  public:
  void clear_coll() ;
  ::SDMS::CollData* mutable_coll(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::CollData >*
      mutable_coll();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::CollData>& _internal_coll() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::CollData>* _internal_mutable_coll();
  public:
  const ::SDMS::CollData& coll(int index) const;
  ::SDMS::CollData* add_coll();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::CollData >&
      coll() const;
  // repeated .SDMS.ListingData update = 2;
  int update_size() const;
  private:
  int _internal_update_size() const;

  public:
  void clear_update() ;
  ::SDMS::ListingData* mutable_update(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >*
      mutable_update();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& _internal_update() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* _internal_mutable_update();
  public:
  const ::SDMS::ListingData& update(int index) const;
  ::SDMS::ListingData* add_update();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >&
      update() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::CollData > coll_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData > update_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class UserDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.UserDataReply) */ {
 public:
  inline UserDataReply() : UserDataReply(nullptr) {}
  ~UserDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserDataReply(::google::protobuf::internal::ConstantInitialized);

  inline UserDataReply(const UserDataReply& from)
      : UserDataReply(nullptr, from) {}
  UserDataReply(UserDataReply&& from) noexcept
    : UserDataReply() {
    *this = ::std::move(from);
  }

  inline UserDataReply& operator=(const UserDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDataReply& operator=(UserDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDataReply* internal_default_instance() {
    return reinterpret_cast<const UserDataReply*>(
               &_UserDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UserDataReply& a, UserDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserDataReply& from) {
    UserDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.UserDataReply";
  }
  protected:
  explicit UserDataReply(::google::protobuf::Arena* arena);
  UserDataReply(::google::protobuf::Arena* arena, const UserDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCountFieldNumber = 3,
    kTotalFieldNumber = 4,
  };
  // repeated .SDMS.UserData user = 1;
  int user_size() const;
  private:
  int _internal_user_size() const;

  public:
  void clear_user() ;
  ::SDMS::UserData* mutable_user(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::UserData >*
      mutable_user();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::UserData>& _internal_user() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::UserData>* _internal_mutable_user();
  public:
  const ::SDMS::UserData& user(int index) const;
  ::SDMS::UserData* add_user();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::UserData >&
      user() const;
  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::uint32_t offset() const;
  void set_offset(::uint32_t value);

  private:
  ::uint32_t _internal_offset() const;
  void _internal_set_offset(::uint32_t value);

  public:
  // optional uint32 count = 3;
  bool has_count() const;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // optional uint32 total = 4;
  bool has_total() const;
  void clear_total() ;
  ::uint32_t total() const;
  void set_total(::uint32_t value);

  private:
  ::uint32_t _internal_total() const;
  void _internal_set_total(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.Auth.UserDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::UserData > user_;
    ::uint32_t offset_;
    ::uint32_t count_;
    ::uint32_t total_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class ProjectDataReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.ProjectDataReply) */ {
 public:
  inline ProjectDataReply() : ProjectDataReply(nullptr) {}
  ~ProjectDataReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectDataReply(::google::protobuf::internal::ConstantInitialized);

  inline ProjectDataReply(const ProjectDataReply& from)
      : ProjectDataReply(nullptr, from) {}
  ProjectDataReply(ProjectDataReply&& from) noexcept
    : ProjectDataReply() {
    *this = ::std::move(from);
  }

  inline ProjectDataReply& operator=(const ProjectDataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectDataReply& operator=(ProjectDataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectDataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectDataReply* internal_default_instance() {
    return reinterpret_cast<const ProjectDataReply*>(
               &_ProjectDataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ProjectDataReply& a, ProjectDataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectDataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectDataReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectDataReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectDataReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectDataReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectDataReply& from) {
    ProjectDataReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectDataReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.ProjectDataReply";
  }
  protected:
  explicit ProjectDataReply(::google::protobuf::Arena* arena);
  ProjectDataReply(::google::protobuf::Arena* arena, const ProjectDataReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjFieldNumber = 1,
  };
  // repeated .SDMS.ProjectData proj = 1;
  int proj_size() const;
  private:
  int _internal_proj_size() const;

  public:
  void clear_proj() ;
  ::SDMS::ProjectData* mutable_proj(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::ProjectData >*
      mutable_proj();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::ProjectData>& _internal_proj() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::ProjectData>* _internal_mutable_proj();
  public:
  const ::SDMS::ProjectData& proj(int index) const;
  ::SDMS::ProjectData* add_proj();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::ProjectData >&
      proj() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.ProjectDataReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::ProjectData > proj_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};// -------------------------------------------------------------------

class CollPathReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.Auth.CollPathReply) */ {
 public:
  inline CollPathReply() : CollPathReply(nullptr) {}
  ~CollPathReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollPathReply(::google::protobuf::internal::ConstantInitialized);

  inline CollPathReply(const CollPathReply& from)
      : CollPathReply(nullptr, from) {}
  CollPathReply(CollPathReply&& from) noexcept
    : CollPathReply() {
    *this = ::std::move(from);
  }

  inline CollPathReply& operator=(const CollPathReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollPathReply& operator=(CollPathReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollPathReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollPathReply* internal_default_instance() {
    return reinterpret_cast<const CollPathReply*>(
               &_CollPathReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CollPathReply& a, CollPathReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CollPathReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollPathReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollPathReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollPathReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollPathReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollPathReply& from) {
    CollPathReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollPathReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.Auth.CollPathReply";
  }
  protected:
  explicit CollPathReply(::google::protobuf::Arena* arena);
  CollPathReply(::google::protobuf::Arena* arena, const CollPathReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // repeated .SDMS.PathData path = 1;
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::SDMS::PathData* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::PathData >*
      mutable_path();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::PathData>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::PathData>* _internal_mutable_path();
  public:
  const ::SDMS::PathData& path(int index) const;
  ::SDMS::PathData* add_path();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::PathData >&
      path() const;
  // @@protoc_insertion_point(class_scope:SDMS.Auth.CollPathReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::PathData > path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_5fAuth_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GenerateCredentialsRequest

// optional string domain = 1;
inline bool GenerateCredentialsRequest::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenerateCredentialsRequest::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenerateCredentialsRequest::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GenerateCredentialsRequest.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateCredentialsRequest::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GenerateCredentialsRequest.domain)
}
inline std::string* GenerateCredentialsRequest::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GenerateCredentialsRequest.domain)
  return _s;
}
inline const std::string& GenerateCredentialsRequest::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void GenerateCredentialsRequest::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* GenerateCredentialsRequest::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* GenerateCredentialsRequest::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GenerateCredentialsRequest.domain)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.domain_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenerateCredentialsRequest::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GenerateCredentialsRequest.domain)
}

// optional uint32 uid = 2;
inline bool GenerateCredentialsRequest::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GenerateCredentialsRequest::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t GenerateCredentialsRequest::uid() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GenerateCredentialsRequest.uid)
  return _internal_uid();
}
inline void GenerateCredentialsRequest::set_uid(::uint32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.GenerateCredentialsRequest.uid)
}
inline ::uint32_t GenerateCredentialsRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_;
}
inline void GenerateCredentialsRequest::_internal_set_uid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uid_ = value;
}

// -------------------------------------------------------------------

// RevokeCredentialsRequest

// -------------------------------------------------------------------

// GenerateCredentialsReply

// required string pub_key = 1;
inline bool GenerateCredentialsReply::has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenerateCredentialsReply::clear_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pub_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenerateCredentialsReply::pub_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GenerateCredentialsReply.pub_key)
  return _internal_pub_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateCredentialsReply::set_pub_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pub_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GenerateCredentialsReply.pub_key)
}
inline std::string* GenerateCredentialsReply::mutable_pub_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GenerateCredentialsReply.pub_key)
  return _s;
}
inline const std::string& GenerateCredentialsReply::_internal_pub_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pub_key_.Get();
}
inline void GenerateCredentialsReply::_internal_set_pub_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pub_key_.Set(value, GetArena());
}
inline std::string* GenerateCredentialsReply::_internal_mutable_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pub_key_.Mutable( GetArena());
}
inline std::string* GenerateCredentialsReply::release_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GenerateCredentialsReply.pub_key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.pub_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pub_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenerateCredentialsReply::set_allocated_pub_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pub_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pub_key_.IsDefault()) {
          _impl_.pub_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GenerateCredentialsReply.pub_key)
}

// required string priv_key = 2;
inline bool GenerateCredentialsReply::has_priv_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GenerateCredentialsReply::clear_priv_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priv_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GenerateCredentialsReply::priv_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GenerateCredentialsReply.priv_key)
  return _internal_priv_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateCredentialsReply::set_priv_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.priv_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GenerateCredentialsReply.priv_key)
}
inline std::string* GenerateCredentialsReply::mutable_priv_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_priv_key();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GenerateCredentialsReply.priv_key)
  return _s;
}
inline const std::string& GenerateCredentialsReply::_internal_priv_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.priv_key_.Get();
}
inline void GenerateCredentialsReply::_internal_set_priv_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.priv_key_.Set(value, GetArena());
}
inline std::string* GenerateCredentialsReply::_internal_mutable_priv_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.priv_key_.Mutable( GetArena());
}
inline std::string* GenerateCredentialsReply::release_priv_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GenerateCredentialsReply.priv_key)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.priv_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.priv_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenerateCredentialsReply::set_allocated_priv_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.priv_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.priv_key_.IsDefault()) {
          _impl_.priv_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GenerateCredentialsReply.priv_key)
}

// -------------------------------------------------------------------

// CheckPermsRequest

// required string id = 1;
inline bool CheckPermsRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CheckPermsRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckPermsRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CheckPermsRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckPermsRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CheckPermsRequest.id)
}
inline std::string* CheckPermsRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CheckPermsRequest.id)
  return _s;
}
inline const std::string& CheckPermsRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CheckPermsRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CheckPermsRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CheckPermsRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CheckPermsRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CheckPermsRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CheckPermsRequest.id)
}

// required uint32 perms = 2;
inline bool CheckPermsRequest::has_perms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CheckPermsRequest::clear_perms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.perms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t CheckPermsRequest::perms() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CheckPermsRequest.perms)
  return _internal_perms();
}
inline void CheckPermsRequest::set_perms(::uint32_t value) {
  _internal_set_perms(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CheckPermsRequest.perms)
}
inline ::uint32_t CheckPermsRequest::_internal_perms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perms_;
}
inline void CheckPermsRequest::_internal_set_perms(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.perms_ = value;
}

// -------------------------------------------------------------------

// CheckPermsReply

// required bool granted = 1;
inline bool CheckPermsReply::has_granted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CheckPermsReply::clear_granted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.granted_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CheckPermsReply::granted() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CheckPermsReply.granted)
  return _internal_granted();
}
inline void CheckPermsReply::set_granted(bool value) {
  _internal_set_granted(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CheckPermsReply.granted)
}
inline bool CheckPermsReply::_internal_granted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.granted_;
}
inline void CheckPermsReply::_internal_set_granted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.granted_ = value;
}

// -------------------------------------------------------------------

// GetPermsRequest

// required string id = 1;
inline bool GetPermsRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetPermsRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetPermsRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GetPermsRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPermsRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GetPermsRequest.id)
}
inline std::string* GetPermsRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GetPermsRequest.id)
  return _s;
}
inline const std::string& GetPermsRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GetPermsRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GetPermsRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GetPermsRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GetPermsRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GetPermsRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GetPermsRequest.id)
}

// optional uint32 perms = 2;
inline bool GetPermsRequest::has_perms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetPermsRequest::clear_perms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.perms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t GetPermsRequest::perms() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GetPermsRequest.perms)
  return _internal_perms();
}
inline void GetPermsRequest::set_perms(::uint32_t value) {
  _internal_set_perms(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.GetPermsRequest.perms)
}
inline ::uint32_t GetPermsRequest::_internal_perms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perms_;
}
inline void GetPermsRequest::_internal_set_perms(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.perms_ = value;
}

// -------------------------------------------------------------------

// GetPermsReply

// required uint32 granted = 1;
inline bool GetPermsReply::has_granted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetPermsReply::clear_granted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.granted_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t GetPermsReply::granted() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GetPermsReply.granted)
  return _internal_granted();
}
inline void GetPermsReply::set_granted(::uint32_t value) {
  _internal_set_granted(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.GetPermsReply.granted)
}
inline ::uint32_t GetPermsReply::_internal_granted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.granted_;
}
inline void GetPermsReply::_internal_set_granted(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.granted_ = value;
}

// -------------------------------------------------------------------

// UserViewRequest

// required string uid = 1;
inline bool UserViewRequest::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserViewRequest::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserViewRequest::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserViewRequest.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserViewRequest::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserViewRequest.uid)
}
inline std::string* UserViewRequest::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserViewRequest.uid)
  return _s;
}
inline const std::string& UserViewRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void UserViewRequest::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* UserViewRequest::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* UserViewRequest::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserViewRequest.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserViewRequest::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserViewRequest.uid)
}

// optional bool details = 2;
inline bool UserViewRequest::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserViewRequest::clear_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.details_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UserViewRequest::details() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserViewRequest.details)
  return _internal_details();
}
inline void UserViewRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserViewRequest.details)
}
inline bool UserViewRequest::_internal_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.details_;
}
inline void UserViewRequest::_internal_set_details(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.details_ = value;
}

// -------------------------------------------------------------------

// UserDataReply

// repeated .SDMS.UserData user = 1;
inline int UserDataReply::_internal_user_size() const {
  return _internal_user().size();
}
inline int UserDataReply::user_size() const {
  return _internal_user_size();
}
inline ::SDMS::UserData* UserDataReply::mutable_user(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserDataReply.user)
  return _internal_mutable_user()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::UserData>* UserDataReply::mutable_user()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.UserDataReply.user)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_user();
}
inline const ::SDMS::UserData& UserDataReply::user(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserDataReply.user)
  return _internal_user().Get(index);
}
inline ::SDMS::UserData* UserDataReply::add_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::UserData* _add = _internal_mutable_user()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserDataReply.user)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::UserData>& UserDataReply::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.UserDataReply.user)
  return _internal_user();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::UserData>&
UserDataReply::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::UserData>*
UserDataReply::_internal_mutable_user() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.user_;
}

// optional uint32 offset = 2;
inline bool UserDataReply::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserDataReply::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t UserDataReply::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserDataReply.offset)
  return _internal_offset();
}
inline void UserDataReply::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserDataReply.offset)
}
inline ::uint32_t UserDataReply::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void UserDataReply::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool UserDataReply::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserDataReply::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UserDataReply::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserDataReply.count)
  return _internal_count();
}
inline void UserDataReply::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserDataReply.count)
}
inline ::uint32_t UserDataReply::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void UserDataReply::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// optional uint32 total = 4;
inline bool UserDataReply::has_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserDataReply::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UserDataReply::total() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserDataReply.total)
  return _internal_total();
}
inline void UserDataReply::set_total(::uint32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserDataReply.total)
}
inline ::uint32_t UserDataReply::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void UserDataReply::_internal_set_total(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// UserSetAccessTokenRequest

// required string access = 1;
inline bool UserSetAccessTokenRequest::has_access() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserSetAccessTokenRequest::clear_access() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.access_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserSetAccessTokenRequest::access() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserSetAccessTokenRequest.access)
  return _internal_access();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSetAccessTokenRequest::set_access(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserSetAccessTokenRequest.access)
}
inline std::string* UserSetAccessTokenRequest::mutable_access() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserSetAccessTokenRequest.access)
  return _s;
}
inline const std::string& UserSetAccessTokenRequest::_internal_access() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.access_.Get();
}
inline void UserSetAccessTokenRequest::_internal_set_access(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_.Set(value, GetArena());
}
inline std::string* UserSetAccessTokenRequest::_internal_mutable_access() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.access_.Mutable( GetArena());
}
inline std::string* UserSetAccessTokenRequest::release_access() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserSetAccessTokenRequest.access)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.access_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.access_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserSetAccessTokenRequest::set_allocated_access(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.access_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.access_.IsDefault()) {
          _impl_.access_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserSetAccessTokenRequest.access)
}

// required uint32 expires_in = 2;
inline bool UserSetAccessTokenRequest::has_expires_in() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserSetAccessTokenRequest::clear_expires_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expires_in_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UserSetAccessTokenRequest::expires_in() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserSetAccessTokenRequest.expires_in)
  return _internal_expires_in();
}
inline void UserSetAccessTokenRequest::set_expires_in(::uint32_t value) {
  _internal_set_expires_in(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserSetAccessTokenRequest.expires_in)
}
inline ::uint32_t UserSetAccessTokenRequest::_internal_expires_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expires_in_;
}
inline void UserSetAccessTokenRequest::_internal_set_expires_in(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.expires_in_ = value;
}

// required string refresh = 3;
inline bool UserSetAccessTokenRequest::has_refresh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserSetAccessTokenRequest::clear_refresh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.refresh_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserSetAccessTokenRequest::refresh() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserSetAccessTokenRequest.refresh)
  return _internal_refresh();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSetAccessTokenRequest::set_refresh(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.refresh_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserSetAccessTokenRequest.refresh)
}
inline std::string* UserSetAccessTokenRequest::mutable_refresh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_refresh();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserSetAccessTokenRequest.refresh)
  return _s;
}
inline const std::string& UserSetAccessTokenRequest::_internal_refresh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.refresh_.Get();
}
inline void UserSetAccessTokenRequest::_internal_set_refresh(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.refresh_.Set(value, GetArena());
}
inline std::string* UserSetAccessTokenRequest::_internal_mutable_refresh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.refresh_.Mutable( GetArena());
}
inline std::string* UserSetAccessTokenRequest::release_refresh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserSetAccessTokenRequest.refresh)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.refresh_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.refresh_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserSetAccessTokenRequest::set_allocated_refresh(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.refresh_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.refresh_.IsDefault()) {
          _impl_.refresh_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserSetAccessTokenRequest.refresh)
}

// -------------------------------------------------------------------

// UserGetAccessTokenRequest

// -------------------------------------------------------------------

// UserAccessTokenReply

// required string access = 1;
inline bool UserAccessTokenReply::has_access() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserAccessTokenReply::clear_access() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.access_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserAccessTokenReply::access() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserAccessTokenReply.access)
  return _internal_access();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserAccessTokenReply::set_access(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserAccessTokenReply.access)
}
inline std::string* UserAccessTokenReply::mutable_access() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserAccessTokenReply.access)
  return _s;
}
inline const std::string& UserAccessTokenReply::_internal_access() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.access_.Get();
}
inline void UserAccessTokenReply::_internal_set_access(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_.Set(value, GetArena());
}
inline std::string* UserAccessTokenReply::_internal_mutable_access() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.access_.Mutable( GetArena());
}
inline std::string* UserAccessTokenReply::release_access() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserAccessTokenReply.access)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.access_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.access_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserAccessTokenReply::set_allocated_access(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.access_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.access_.IsDefault()) {
          _impl_.access_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserAccessTokenReply.access)
}

// required uint32 expires_in = 2;
inline bool UserAccessTokenReply::has_expires_in() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserAccessTokenReply::clear_expires_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expires_in_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UserAccessTokenReply::expires_in() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserAccessTokenReply.expires_in)
  return _internal_expires_in();
}
inline void UserAccessTokenReply::set_expires_in(::uint32_t value) {
  _internal_set_expires_in(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserAccessTokenReply.expires_in)
}
inline ::uint32_t UserAccessTokenReply::_internal_expires_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expires_in_;
}
inline void UserAccessTokenReply::_internal_set_expires_in(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.expires_in_ = value;
}

// -------------------------------------------------------------------

// UserCreateRequest

// required string uid = 1;
inline bool UserCreateRequest::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserCreateRequest::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserCreateRequest::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserCreateRequest.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserCreateRequest::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserCreateRequest.uid)
}
inline std::string* UserCreateRequest::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserCreateRequest.uid)
  return _s;
}
inline const std::string& UserCreateRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void UserCreateRequest::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* UserCreateRequest::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* UserCreateRequest::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserCreateRequest.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserCreateRequest::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserCreateRequest.uid)
}

// optional string password = 2;
inline bool UserCreateRequest::has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserCreateRequest::clear_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserCreateRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserCreateRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserCreateRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserCreateRequest.password)
}
inline std::string* UserCreateRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserCreateRequest.password)
  return _s;
}
inline const std::string& UserCreateRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void UserCreateRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* UserCreateRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* UserCreateRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserCreateRequest.password)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.password_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserCreateRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserCreateRequest.password)
}

// required string name = 3;
inline bool UserCreateRequest::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserCreateRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserCreateRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserCreateRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserCreateRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserCreateRequest.name)
}
inline std::string* UserCreateRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserCreateRequest.name)
  return _s;
}
inline const std::string& UserCreateRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void UserCreateRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* UserCreateRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* UserCreateRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserCreateRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserCreateRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserCreateRequest.name)
}

// required string email = 4;
inline bool UserCreateRequest::has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserCreateRequest::clear_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserCreateRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserCreateRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserCreateRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserCreateRequest.email)
}
inline std::string* UserCreateRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserCreateRequest.email)
  return _s;
}
inline const std::string& UserCreateRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void UserCreateRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* UserCreateRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* UserCreateRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserCreateRequest.email)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.email_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserCreateRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserCreateRequest.email)
}

// repeated string uuid = 5;
inline int UserCreateRequest::_internal_uuid_size() const {
  return _internal_uuid().size();
}
inline int UserCreateRequest::uuid_size() const {
  return _internal_uuid_size();
}
inline void UserCreateRequest::clear_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.Clear();
}
inline std::string* UserCreateRequest::add_uuid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_uuid()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.UserCreateRequest.uuid)
  return _s;
}
inline const std::string& UserCreateRequest::uuid(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserCreateRequest.uuid)
  return _internal_uuid().Get(index);
}
inline std::string* UserCreateRequest::mutable_uuid(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserCreateRequest.uuid)
  return _internal_mutable_uuid()->Mutable(index);
}
inline void UserCreateRequest::set_uuid(int index, const std::string& value) {
  _internal_mutable_uuid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::set_uuid(int index, std::string&& value) {
  _internal_mutable_uuid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::set_uuid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_uuid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::set_uuid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_uuid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::set_uuid(int index, absl::string_view value) {
  _internal_mutable_uuid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::add_uuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::add_uuid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::add_uuid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::add_uuid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.UserCreateRequest.uuid)
}
inline void UserCreateRequest::add_uuid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.UserCreateRequest.uuid)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserCreateRequest::uuid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.UserCreateRequest.uuid)
  return _internal_uuid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserCreateRequest::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.UserCreateRequest.uuid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_uuid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserCreateRequest::_internal_uuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uuid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserCreateRequest::_internal_mutable_uuid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.uuid_;
}

// optional string options = 6;
inline bool UserCreateRequest::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UserCreateRequest::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.options_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserCreateRequest::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserCreateRequest.options)
  return _internal_options();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserCreateRequest::set_options(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.options_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserCreateRequest.options)
}
inline std::string* UserCreateRequest::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserCreateRequest.options)
  return _s;
}
inline const std::string& UserCreateRequest::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.options_.Get();
}
inline void UserCreateRequest::_internal_set_options(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.options_.Set(value, GetArena());
}
inline std::string* UserCreateRequest::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.options_.Mutable( GetArena());
}
inline std::string* UserCreateRequest::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserCreateRequest.options)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.options_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.options_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserCreateRequest::set_allocated_options(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.options_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.options_.IsDefault()) {
          _impl_.options_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserCreateRequest.options)
}

// required string secret = 7;
inline bool UserCreateRequest::has_secret() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserCreateRequest::clear_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserCreateRequest::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserCreateRequest.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserCreateRequest::set_secret(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserCreateRequest.secret)
}
inline std::string* UserCreateRequest::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserCreateRequest.secret)
  return _s;
}
inline const std::string& UserCreateRequest::_internal_secret() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secret_.Get();
}
inline void UserCreateRequest::_internal_set_secret(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* UserCreateRequest::_internal_mutable_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* UserCreateRequest::release_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserCreateRequest.secret)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.secret_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secret_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserCreateRequest::set_allocated_secret(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.secret_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserCreateRequest.secret)
}

// -------------------------------------------------------------------

// UserFindByUUIDsRequest

// repeated string uuid = 1;
inline int UserFindByUUIDsRequest::_internal_uuid_size() const {
  return _internal_uuid().size();
}
inline int UserFindByUUIDsRequest::uuid_size() const {
  return _internal_uuid_size();
}
inline void UserFindByUUIDsRequest::clear_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.Clear();
}
inline std::string* UserFindByUUIDsRequest::add_uuid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_uuid()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.UserFindByUUIDsRequest.uuid)
  return _s;
}
inline const std::string& UserFindByUUIDsRequest::uuid(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserFindByUUIDsRequest.uuid)
  return _internal_uuid().Get(index);
}
inline std::string* UserFindByUUIDsRequest::mutable_uuid(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserFindByUUIDsRequest.uuid)
  return _internal_mutable_uuid()->Mutable(index);
}
inline void UserFindByUUIDsRequest::set_uuid(int index, const std::string& value) {
  _internal_mutable_uuid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::set_uuid(int index, std::string&& value) {
  _internal_mutable_uuid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::set_uuid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_uuid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::set_uuid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_uuid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::set_uuid(int index, absl::string_view value) {
  _internal_mutable_uuid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::add_uuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::add_uuid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::add_uuid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::add_uuid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline void UserFindByUUIDsRequest::add_uuid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uuid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.UserFindByUUIDsRequest.uuid)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserFindByUUIDsRequest::uuid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.UserFindByUUIDsRequest.uuid)
  return _internal_uuid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserFindByUUIDsRequest::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.UserFindByUUIDsRequest.uuid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_uuid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserFindByUUIDsRequest::_internal_uuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uuid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserFindByUUIDsRequest::_internal_mutable_uuid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.uuid_;
}

// -------------------------------------------------------------------

// UserFindByNameUIDRequest

// required string name_uid = 1;
inline bool UserFindByNameUIDRequest::has_name_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserFindByNameUIDRequest::clear_name_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserFindByNameUIDRequest::name_uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserFindByNameUIDRequest.name_uid)
  return _internal_name_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserFindByNameUIDRequest::set_name_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserFindByNameUIDRequest.name_uid)
}
inline std::string* UserFindByNameUIDRequest::mutable_name_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserFindByNameUIDRequest.name_uid)
  return _s;
}
inline const std::string& UserFindByNameUIDRequest::_internal_name_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_uid_.Get();
}
inline void UserFindByNameUIDRequest::_internal_set_name_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_uid_.Set(value, GetArena());
}
inline std::string* UserFindByNameUIDRequest::_internal_mutable_name_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_uid_.Mutable( GetArena());
}
inline std::string* UserFindByNameUIDRequest::release_name_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserFindByNameUIDRequest.name_uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserFindByNameUIDRequest::set_allocated_name_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_uid_.IsDefault()) {
          _impl_.name_uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserFindByNameUIDRequest.name_uid)
}

// optional uint32 offset = 2;
inline bool UserFindByNameUIDRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserFindByNameUIDRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UserFindByNameUIDRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserFindByNameUIDRequest.offset)
  return _internal_offset();
}
inline void UserFindByNameUIDRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserFindByNameUIDRequest.offset)
}
inline ::uint32_t UserFindByNameUIDRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void UserFindByNameUIDRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool UserFindByNameUIDRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserFindByNameUIDRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UserFindByNameUIDRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserFindByNameUIDRequest.count)
  return _internal_count();
}
inline void UserFindByNameUIDRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserFindByNameUIDRequest.count)
}
inline ::uint32_t UserFindByNameUIDRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void UserFindByNameUIDRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// UserUpdateRequest

// required string uid = 1;
inline bool UserUpdateRequest::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserUpdateRequest::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserUpdateRequest::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserUpdateRequest.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserUpdateRequest::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserUpdateRequest.uid)
}
inline std::string* UserUpdateRequest::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserUpdateRequest.uid)
  return _s;
}
inline const std::string& UserUpdateRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void UserUpdateRequest::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* UserUpdateRequest::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* UserUpdateRequest::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserUpdateRequest.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserUpdateRequest::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserUpdateRequest.uid)
}

// optional string email = 2;
inline bool UserUpdateRequest::has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserUpdateRequest::clear_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserUpdateRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserUpdateRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserUpdateRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserUpdateRequest.email)
}
inline std::string* UserUpdateRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserUpdateRequest.email)
  return _s;
}
inline const std::string& UserUpdateRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void UserUpdateRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* UserUpdateRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* UserUpdateRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserUpdateRequest.email)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.email_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserUpdateRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserUpdateRequest.email)
}

// optional string password = 3;
inline bool UserUpdateRequest::has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserUpdateRequest::clear_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserUpdateRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserUpdateRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserUpdateRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserUpdateRequest.password)
}
inline std::string* UserUpdateRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserUpdateRequest.password)
  return _s;
}
inline const std::string& UserUpdateRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void UserUpdateRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* UserUpdateRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* UserUpdateRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserUpdateRequest.password)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.password_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserUpdateRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserUpdateRequest.password)
}

// optional string options = 4;
inline bool UserUpdateRequest::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserUpdateRequest::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.options_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserUpdateRequest::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserUpdateRequest.options)
  return _internal_options();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserUpdateRequest::set_options(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.options_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserUpdateRequest.options)
}
inline std::string* UserUpdateRequest::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserUpdateRequest.options)
  return _s;
}
inline const std::string& UserUpdateRequest::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.options_.Get();
}
inline void UserUpdateRequest::_internal_set_options(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.options_.Set(value, GetArena());
}
inline std::string* UserUpdateRequest::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.options_.Mutable( GetArena());
}
inline std::string* UserUpdateRequest::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.UserUpdateRequest.options)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.options_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.options_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserUpdateRequest::set_allocated_options(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.options_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.options_.IsDefault()) {
          _impl_.options_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.UserUpdateRequest.options)
}

// -------------------------------------------------------------------

// UserListAllRequest

// optional uint32 offset = 1;
inline bool UserListAllRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserListAllRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t UserListAllRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserListAllRequest.offset)
  return _internal_offset();
}
inline void UserListAllRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserListAllRequest.offset)
}
inline ::uint32_t UserListAllRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void UserListAllRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 2;
inline bool UserListAllRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserListAllRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UserListAllRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserListAllRequest.count)
  return _internal_count();
}
inline void UserListAllRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserListAllRequest.count)
}
inline ::uint32_t UserListAllRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void UserListAllRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// UserListCollabRequest

// optional uint32 offset = 1;
inline bool UserListCollabRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserListCollabRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t UserListCollabRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserListCollabRequest.offset)
  return _internal_offset();
}
inline void UserListCollabRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserListCollabRequest.offset)
}
inline ::uint32_t UserListCollabRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void UserListCollabRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 2;
inline bool UserListCollabRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserListCollabRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UserListCollabRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserListCollabRequest.count)
  return _internal_count();
}
inline void UserListCollabRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserListCollabRequest.count)
}
inline ::uint32_t UserListCollabRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void UserListCollabRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// UserGetRecentEPRequest

// -------------------------------------------------------------------

// UserGetRecentEPReply

// repeated string ep = 1;
inline int UserGetRecentEPReply::_internal_ep_size() const {
  return _internal_ep().size();
}
inline int UserGetRecentEPReply::ep_size() const {
  return _internal_ep_size();
}
inline void UserGetRecentEPReply::clear_ep() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ep_.Clear();
}
inline std::string* UserGetRecentEPReply::add_ep()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_ep()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.UserGetRecentEPReply.ep)
  return _s;
}
inline const std::string& UserGetRecentEPReply::ep(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserGetRecentEPReply.ep)
  return _internal_ep().Get(index);
}
inline std::string* UserGetRecentEPReply::mutable_ep(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserGetRecentEPReply.ep)
  return _internal_mutable_ep()->Mutable(index);
}
inline void UserGetRecentEPReply::set_ep(int index, const std::string& value) {
  _internal_mutable_ep()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::set_ep(int index, std::string&& value) {
  _internal_mutable_ep()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::set_ep(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ep()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::set_ep(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_ep()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::set_ep(int index, absl::string_view value) {
  _internal_mutable_ep()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::add_ep(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::add_ep(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::add_ep(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::add_ep(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline void UserGetRecentEPReply::add_ep(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.UserGetRecentEPReply.ep)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserGetRecentEPReply::ep() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.UserGetRecentEPReply.ep)
  return _internal_ep();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserGetRecentEPReply::mutable_ep() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.UserGetRecentEPReply.ep)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ep();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserGetRecentEPReply::_internal_ep() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ep_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserGetRecentEPReply::_internal_mutable_ep() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ep_;
}

// -------------------------------------------------------------------

// UserSetRecentEPRequest

// repeated string ep = 1;
inline int UserSetRecentEPRequest::_internal_ep_size() const {
  return _internal_ep().size();
}
inline int UserSetRecentEPRequest::ep_size() const {
  return _internal_ep_size();
}
inline void UserSetRecentEPRequest::clear_ep() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ep_.Clear();
}
inline std::string* UserSetRecentEPRequest::add_ep()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_ep()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.UserSetRecentEPRequest.ep)
  return _s;
}
inline const std::string& UserSetRecentEPRequest::ep(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.UserSetRecentEPRequest.ep)
  return _internal_ep().Get(index);
}
inline std::string* UserSetRecentEPRequest::mutable_ep(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.UserSetRecentEPRequest.ep)
  return _internal_mutable_ep()->Mutable(index);
}
inline void UserSetRecentEPRequest::set_ep(int index, const std::string& value) {
  _internal_mutable_ep()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::set_ep(int index, std::string&& value) {
  _internal_mutable_ep()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::set_ep(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ep()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::set_ep(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_ep()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::set_ep(int index, absl::string_view value) {
  _internal_mutable_ep()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::add_ep(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::add_ep(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::add_ep(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::add_ep(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline void UserSetRecentEPRequest::add_ep(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ep()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.UserSetRecentEPRequest.ep)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserSetRecentEPRequest::ep() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.UserSetRecentEPRequest.ep)
  return _internal_ep();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserSetRecentEPRequest::mutable_ep() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.UserSetRecentEPRequest.ep)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ep();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserSetRecentEPRequest::_internal_ep() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ep_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserSetRecentEPRequest::_internal_mutable_ep() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ep_;
}

// -------------------------------------------------------------------

// ListingReply

// repeated .SDMS.ListingData item = 1;
inline int ListingReply::_internal_item_size() const {
  return _internal_item().size();
}
inline int ListingReply::item_size() const {
  return _internal_item_size();
}
inline ::SDMS::ListingData* ListingReply::mutable_item(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ListingReply.item)
  return _internal_mutable_item()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* ListingReply::mutable_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ListingReply.item)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_item();
}
inline const ::SDMS::ListingData& ListingReply::item(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ListingReply.item)
  return _internal_item().Get(index);
}
inline ::SDMS::ListingData* ListingReply::add_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::ListingData* _add = _internal_mutable_item()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.ListingReply.item)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& ListingReply::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ListingReply.item)
  return _internal_item();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>&
ListingReply::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>*
ListingReply::_internal_mutable_item() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.item_;
}

// optional uint32 offset = 2;
inline bool ListingReply::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ListingReply::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t ListingReply::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ListingReply.offset)
  return _internal_offset();
}
inline void ListingReply::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ListingReply.offset)
}
inline ::uint32_t ListingReply::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void ListingReply::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool ListingReply::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ListingReply::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ListingReply::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ListingReply.count)
  return _internal_count();
}
inline void ListingReply::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ListingReply.count)
}
inline ::uint32_t ListingReply::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void ListingReply::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// optional uint32 total = 4;
inline bool ListingReply::has_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ListingReply::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ListingReply::total() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ListingReply.total)
  return _internal_total();
}
inline void ListingReply::set_total(::uint32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ListingReply.total)
}
inline ::uint32_t ListingReply::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void ListingReply::_internal_set_total(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// RecordListByAllocRequest

// required string repo = 1;
inline bool RecordListByAllocRequest::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordListByAllocRequest::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordListByAllocRequest::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordListByAllocRequest.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordListByAllocRequest::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordListByAllocRequest.repo)
}
inline std::string* RecordListByAllocRequest::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordListByAllocRequest.repo)
  return _s;
}
inline const std::string& RecordListByAllocRequest::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void RecordListByAllocRequest::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* RecordListByAllocRequest::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* RecordListByAllocRequest::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordListByAllocRequest.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordListByAllocRequest::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordListByAllocRequest.repo)
}

// optional string subject = 2;
inline bool RecordListByAllocRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordListByAllocRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecordListByAllocRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordListByAllocRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordListByAllocRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordListByAllocRequest.subject)
}
inline std::string* RecordListByAllocRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordListByAllocRequest.subject)
  return _s;
}
inline const std::string& RecordListByAllocRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void RecordListByAllocRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* RecordListByAllocRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* RecordListByAllocRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordListByAllocRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordListByAllocRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordListByAllocRequest.subject)
}

// optional uint32 offset = 3;
inline bool RecordListByAllocRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordListByAllocRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t RecordListByAllocRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordListByAllocRequest.offset)
  return _internal_offset();
}
inline void RecordListByAllocRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordListByAllocRequest.offset)
}
inline ::uint32_t RecordListByAllocRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void RecordListByAllocRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.offset_ = value;
}

// optional uint32 count = 4;
inline bool RecordListByAllocRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RecordListByAllocRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RecordListByAllocRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordListByAllocRequest.count)
  return _internal_count();
}
inline void RecordListByAllocRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordListByAllocRequest.count)
}
inline ::uint32_t RecordListByAllocRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void RecordListByAllocRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// RecordViewRequest

// required string id = 1;
inline bool RecordViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordViewRequest.id)
}
inline std::string* RecordViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordViewRequest.id)
  return _s;
}
inline const std::string& RecordViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RecordViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RecordViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RecordViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordViewRequest.id)
}

// optional bool details = 2;
inline bool RecordViewRequest::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordViewRequest::clear_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.details_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RecordViewRequest::details() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordViewRequest.details)
  return _internal_details();
}
inline void RecordViewRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordViewRequest.details)
}
inline bool RecordViewRequest::_internal_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.details_;
}
inline void RecordViewRequest::_internal_set_details(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.details_ = value;
}

// -------------------------------------------------------------------

// RecordDataReply

// repeated .SDMS.RecordData data = 1;
inline int RecordDataReply::_internal_data_size() const {
  return _internal_data().size();
}
inline int RecordDataReply::data_size() const {
  return _internal_data_size();
}
inline ::SDMS::RecordData* RecordDataReply::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordDataReply.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordData>* RecordDataReply::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordDataReply.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::SDMS::RecordData& RecordDataReply::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordDataReply.data)
  return _internal_data().Get(index);
}
inline ::SDMS::RecordData* RecordDataReply::add_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::RecordData* _add = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordDataReply.data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordData>& RecordDataReply::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordDataReply.data)
  return _internal_data();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordData>&
RecordDataReply::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordData>*
RecordDataReply::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// repeated .SDMS.ListingData update = 2;
inline int RecordDataReply::_internal_update_size() const {
  return _internal_update().size();
}
inline int RecordDataReply::update_size() const {
  return _internal_update_size();
}
inline ::SDMS::ListingData* RecordDataReply::mutable_update(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordDataReply.update)
  return _internal_mutable_update()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* RecordDataReply::mutable_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordDataReply.update)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_update();
}
inline const ::SDMS::ListingData& RecordDataReply::update(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordDataReply.update)
  return _internal_update().Get(index);
}
inline ::SDMS::ListingData* RecordDataReply::add_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::ListingData* _add = _internal_mutable_update()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordDataReply.update)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& RecordDataReply::update() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordDataReply.update)
  return _internal_update();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>&
RecordDataReply::_internal_update() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>*
RecordDataReply::_internal_mutable_update() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.update_;
}

// -------------------------------------------------------------------

// RecordCreateRequest

// optional string title = 1;
inline bool RecordCreateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordCreateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.title)
}
inline std::string* RecordCreateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.title)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void RecordCreateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.title)
}

// optional string desc = 2;
inline bool RecordCreateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecordCreateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.desc)
}
inline std::string* RecordCreateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.desc)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void RecordCreateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.desc)
}

// repeated string tags = 3;
inline int RecordCreateRequest::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int RecordCreateRequest::tags_size() const {
  return _internal_tags_size();
}
inline void RecordCreateRequest::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* RecordCreateRequest::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RecordCreateRequest.tags)
  return _s;
}
inline const std::string& RecordCreateRequest::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.tags)
  return _internal_tags().Get(index);
}
inline std::string* RecordCreateRequest::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void RecordCreateRequest::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RecordCreateRequest.tags)
}
inline void RecordCreateRequest::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RecordCreateRequest.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordCreateRequest::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordCreateRequest.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordCreateRequest::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordCreateRequest.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordCreateRequest::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordCreateRequest::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// optional string alias = 4;
inline bool RecordCreateRequest::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RecordCreateRequest::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.alias)
}
inline std::string* RecordCreateRequest::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.alias)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void RecordCreateRequest::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.alias)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.alias_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.alias)
}

// optional string metadata = 5;
inline bool RecordCreateRequest::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RecordCreateRequest::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_metadata(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.metadata)
}
inline std::string* RecordCreateRequest::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.metadata)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_.Get();
}
inline void RecordCreateRequest::_internal_set_metadata(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.metadata_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.metadata_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.metadata)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.metadata_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.metadata_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_metadata(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.metadata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_.IsDefault()) {
          _impl_.metadata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.metadata)
}

// optional string parent_id = 6;
inline bool RecordCreateRequest::has_parent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RecordCreateRequest::parent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.parent_id)
  return _internal_parent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_parent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.parent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.parent_id)
}
inline std::string* RecordCreateRequest::mutable_parent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.parent_id)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_parent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_id_.Get();
}
inline void RecordCreateRequest::_internal_set_parent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.parent_id_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.parent_id_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.parent_id)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.parent_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_parent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.parent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_id_.IsDefault()) {
          _impl_.parent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.parent_id)
}

// optional bool external = 7;
inline bool RecordCreateRequest::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.external_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool RecordCreateRequest::external() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.external)
  return _internal_external();
}
inline void RecordCreateRequest::set_external(bool value) {
  _internal_set_external(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.external)
}
inline bool RecordCreateRequest::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.external_;
}
inline void RecordCreateRequest::_internal_set_external(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.external_ = value;
}

// optional string source = 8;
inline bool RecordCreateRequest::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& RecordCreateRequest::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.source)
}
inline std::string* RecordCreateRequest::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.source)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void RecordCreateRequest::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.source_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.source_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.source)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.source_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.source)
}

// optional string repo_id = 9;
inline bool RecordCreateRequest::has_repo_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& RecordCreateRequest::repo_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.repo_id)
  return _internal_repo_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_repo_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.repo_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.repo_id)
}
inline std::string* RecordCreateRequest::mutable_repo_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.repo_id)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_repo_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_id_.Get();
}
inline void RecordCreateRequest::_internal_set_repo_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.repo_id_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.repo_id_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.repo_id)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.repo_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_repo_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.repo_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_id_.IsDefault()) {
          _impl_.repo_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.repo_id)
}

// optional string ext = 10;
inline bool RecordCreateRequest::has_ext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& RecordCreateRequest::ext() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.ext)
  return _internal_ext();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_ext(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ext_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.ext)
}
inline std::string* RecordCreateRequest::mutable_ext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ext();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.ext)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_ext() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ext_.Get();
}
inline void RecordCreateRequest::_internal_set_ext(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ext_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.ext_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.ext)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.ext_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ext_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_ext(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.ext_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ext_.IsDefault()) {
          _impl_.ext_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.ext)
}

// optional bool ext_auto = 11;
inline bool RecordCreateRequest::has_ext_auto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_ext_auto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ext_auto_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool RecordCreateRequest::ext_auto() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.ext_auto)
  return _internal_ext_auto();
}
inline void RecordCreateRequest::set_ext_auto(bool value) {
  _internal_set_ext_auto(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.ext_auto)
}
inline bool RecordCreateRequest::_internal_ext_auto() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ext_auto_;
}
inline void RecordCreateRequest::_internal_set_ext_auto(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.ext_auto_ = value;
}

// repeated .SDMS.DependencySpecData deps = 12;
inline int RecordCreateRequest::_internal_deps_size() const {
  return _internal_deps().size();
}
inline int RecordCreateRequest::deps_size() const {
  return _internal_deps_size();
}
inline ::SDMS::DependencySpecData* RecordCreateRequest::mutable_deps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.deps)
  return _internal_mutable_deps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>* RecordCreateRequest::mutable_deps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordCreateRequest.deps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_deps();
}
inline const ::SDMS::DependencySpecData& RecordCreateRequest::deps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.deps)
  return _internal_deps().Get(index);
}
inline ::SDMS::DependencySpecData* RecordCreateRequest::add_deps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::DependencySpecData* _add = _internal_mutable_deps()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordCreateRequest.deps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>& RecordCreateRequest::deps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordCreateRequest.deps)
  return _internal_deps();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>&
RecordCreateRequest::_internal_deps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deps_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>*
RecordCreateRequest::_internal_mutable_deps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.deps_;
}

// optional string sch_id = 13;
inline bool RecordCreateRequest::has_sch_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sch_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& RecordCreateRequest::sch_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.sch_id)
  return _internal_sch_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateRequest::set_sch_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.sch_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.sch_id)
}
inline std::string* RecordCreateRequest::mutable_sch_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sch_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateRequest.sch_id)
  return _s;
}
inline const std::string& RecordCreateRequest::_internal_sch_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sch_id_.Get();
}
inline void RecordCreateRequest::_internal_set_sch_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.sch_id_.Set(value, GetArena());
}
inline std::string* RecordCreateRequest::_internal_mutable_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.sch_id_.Mutable( GetArena());
}
inline std::string* RecordCreateRequest::release_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateRequest.sch_id)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.sch_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sch_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateRequest::set_allocated_sch_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.sch_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sch_id_.IsDefault()) {
          _impl_.sch_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateRequest.sch_id)
}

// optional bool sch_enforce = 14;
inline bool RecordCreateRequest::has_sch_enforce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void RecordCreateRequest::clear_sch_enforce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sch_enforce_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool RecordCreateRequest::sch_enforce() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateRequest.sch_enforce)
  return _internal_sch_enforce();
}
inline void RecordCreateRequest::set_sch_enforce(bool value) {
  _internal_set_sch_enforce(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateRequest.sch_enforce)
}
inline bool RecordCreateRequest::_internal_sch_enforce() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sch_enforce_;
}
inline void RecordCreateRequest::_internal_set_sch_enforce(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.sch_enforce_ = value;
}

// -------------------------------------------------------------------

// RecordCreateBatchRequest

// required string records = 1;
inline bool RecordCreateBatchRequest::has_records() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordCreateBatchRequest::clear_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.records_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordCreateBatchRequest::records() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordCreateBatchRequest.records)
  return _internal_records();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordCreateBatchRequest::set_records(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.records_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordCreateBatchRequest.records)
}
inline std::string* RecordCreateBatchRequest::mutable_records() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_records();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordCreateBatchRequest.records)
  return _s;
}
inline const std::string& RecordCreateBatchRequest::_internal_records() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.records_.Get();
}
inline void RecordCreateBatchRequest::_internal_set_records(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.records_.Set(value, GetArena());
}
inline std::string* RecordCreateBatchRequest::_internal_mutable_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.records_.Mutable( GetArena());
}
inline std::string* RecordCreateBatchRequest::release_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordCreateBatchRequest.records)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.records_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.records_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordCreateBatchRequest::set_allocated_records(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.records_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.records_.IsDefault()) {
          _impl_.records_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordCreateBatchRequest.records)
}

// -------------------------------------------------------------------

// RecordUpdateRequest

// required string id = 1;
inline bool RecordUpdateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordUpdateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.id)
}
inline std::string* RecordUpdateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.id)
  return _s;
}
inline const std::string& RecordUpdateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RecordUpdateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RecordUpdateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RecordUpdateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateRequest.id)
}

// optional string title = 2;
inline bool RecordUpdateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecordUpdateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.title)
}
inline std::string* RecordUpdateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.title)
  return _s;
}
inline const std::string& RecordUpdateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void RecordUpdateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* RecordUpdateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* RecordUpdateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateRequest.title)
}

// optional string desc = 3;
inline bool RecordUpdateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RecordUpdateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.desc)
}
inline std::string* RecordUpdateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.desc)
  return _s;
}
inline const std::string& RecordUpdateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void RecordUpdateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* RecordUpdateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* RecordUpdateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateRequest.desc)
}

// repeated string tags = 4;
inline int RecordUpdateRequest::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int RecordUpdateRequest::tags_size() const {
  return _internal_tags_size();
}
inline void RecordUpdateRequest::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* RecordUpdateRequest::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RecordUpdateRequest.tags)
  return _s;
}
inline const std::string& RecordUpdateRequest::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.tags)
  return _internal_tags().Get(index);
}
inline std::string* RecordUpdateRequest::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void RecordUpdateRequest::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RecordUpdateRequest.tags)
}
inline void RecordUpdateRequest::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RecordUpdateRequest.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordUpdateRequest::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordUpdateRequest.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordUpdateRequest::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordUpdateRequest.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordUpdateRequest::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordUpdateRequest::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// optional bool tags_clear = 5;
inline bool RecordUpdateRequest::has_tags_clear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_tags_clear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_clear_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool RecordUpdateRequest::tags_clear() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.tags_clear)
  return _internal_tags_clear();
}
inline void RecordUpdateRequest::set_tags_clear(bool value) {
  _internal_set_tags_clear(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.tags_clear)
}
inline bool RecordUpdateRequest::_internal_tags_clear() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_clear_;
}
inline void RecordUpdateRequest::_internal_set_tags_clear(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.tags_clear_ = value;
}

// optional string alias = 6;
inline bool RecordUpdateRequest::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RecordUpdateRequest::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateRequest::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.alias)
}
inline std::string* RecordUpdateRequest::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.alias)
  return _s;
}
inline const std::string& RecordUpdateRequest::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void RecordUpdateRequest::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* RecordUpdateRequest::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* RecordUpdateRequest::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateRequest.alias)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.alias_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateRequest::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateRequest.alias)
}

// optional string metadata = 7;
inline bool RecordUpdateRequest::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RecordUpdateRequest::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateRequest::set_metadata(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.metadata)
}
inline std::string* RecordUpdateRequest::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.metadata)
  return _s;
}
inline const std::string& RecordUpdateRequest::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_.Get();
}
inline void RecordUpdateRequest::_internal_set_metadata(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.metadata_.Set(value, GetArena());
}
inline std::string* RecordUpdateRequest::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.metadata_.Mutable( GetArena());
}
inline std::string* RecordUpdateRequest::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateRequest.metadata)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.metadata_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.metadata_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateRequest::set_allocated_metadata(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.metadata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_.IsDefault()) {
          _impl_.metadata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateRequest.metadata)
}

// optional bool mdset = 8;
inline bool RecordUpdateRequest::has_mdset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_mdset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mdset_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool RecordUpdateRequest::mdset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.mdset)
  return _internal_mdset();
}
inline void RecordUpdateRequest::set_mdset(bool value) {
  _internal_set_mdset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.mdset)
}
inline bool RecordUpdateRequest::_internal_mdset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mdset_;
}
inline void RecordUpdateRequest::_internal_set_mdset(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.mdset_ = value;
}

// optional string sch_id = 9;
inline bool RecordUpdateRequest::has_sch_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sch_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& RecordUpdateRequest::sch_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.sch_id)
  return _internal_sch_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateRequest::set_sch_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sch_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.sch_id)
}
inline std::string* RecordUpdateRequest::mutable_sch_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sch_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.sch_id)
  return _s;
}
inline const std::string& RecordUpdateRequest::_internal_sch_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sch_id_.Get();
}
inline void RecordUpdateRequest::_internal_set_sch_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sch_id_.Set(value, GetArena());
}
inline std::string* RecordUpdateRequest::_internal_mutable_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.sch_id_.Mutable( GetArena());
}
inline std::string* RecordUpdateRequest::release_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateRequest.sch_id)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.sch_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sch_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateRequest::set_allocated_sch_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sch_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sch_id_.IsDefault()) {
          _impl_.sch_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateRequest.sch_id)
}

// optional bool sch_enforce = 10;
inline bool RecordUpdateRequest::has_sch_enforce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_sch_enforce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sch_enforce_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool RecordUpdateRequest::sch_enforce() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.sch_enforce)
  return _internal_sch_enforce();
}
inline void RecordUpdateRequest::set_sch_enforce(bool value) {
  _internal_set_sch_enforce(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.sch_enforce)
}
inline bool RecordUpdateRequest::_internal_sch_enforce() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sch_enforce_;
}
inline void RecordUpdateRequest::_internal_set_sch_enforce(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.sch_enforce_ = value;
}

// optional string source = 11;
inline bool RecordUpdateRequest::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& RecordUpdateRequest::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateRequest::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.source)
}
inline std::string* RecordUpdateRequest::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.source)
  return _s;
}
inline const std::string& RecordUpdateRequest::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void RecordUpdateRequest::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.source_.Set(value, GetArena());
}
inline std::string* RecordUpdateRequest::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.source_.Mutable( GetArena());
}
inline std::string* RecordUpdateRequest::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateRequest.source)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateRequest::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.source_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateRequest.source)
}

// optional string ext = 12;
inline bool RecordUpdateRequest::has_ext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& RecordUpdateRequest::ext() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.ext)
  return _internal_ext();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateRequest::set_ext(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ext_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.ext)
}
inline std::string* RecordUpdateRequest::mutable_ext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ext();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.ext)
  return _s;
}
inline const std::string& RecordUpdateRequest::_internal_ext() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ext_.Get();
}
inline void RecordUpdateRequest::_internal_set_ext(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ext_.Set(value, GetArena());
}
inline std::string* RecordUpdateRequest::_internal_mutable_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.ext_.Mutable( GetArena());
}
inline std::string* RecordUpdateRequest::release_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateRequest.ext)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.ext_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ext_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateRequest::set_allocated_ext(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.ext_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ext_.IsDefault()) {
          _impl_.ext_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateRequest.ext)
}

// optional bool ext_auto = 13;
inline bool RecordUpdateRequest::has_ext_auto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void RecordUpdateRequest::clear_ext_auto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ext_auto_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool RecordUpdateRequest::ext_auto() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.ext_auto)
  return _internal_ext_auto();
}
inline void RecordUpdateRequest::set_ext_auto(bool value) {
  _internal_set_ext_auto(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateRequest.ext_auto)
}
inline bool RecordUpdateRequest::_internal_ext_auto() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ext_auto_;
}
inline void RecordUpdateRequest::_internal_set_ext_auto(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.ext_auto_ = value;
}

// repeated .SDMS.DependencySpecData dep_add = 16;
inline int RecordUpdateRequest::_internal_dep_add_size() const {
  return _internal_dep_add().size();
}
inline int RecordUpdateRequest::dep_add_size() const {
  return _internal_dep_add_size();
}
inline ::SDMS::DependencySpecData* RecordUpdateRequest::mutable_dep_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.dep_add)
  return _internal_mutable_dep_add()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>* RecordUpdateRequest::mutable_dep_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordUpdateRequest.dep_add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dep_add();
}
inline const ::SDMS::DependencySpecData& RecordUpdateRequest::dep_add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.dep_add)
  return _internal_dep_add().Get(index);
}
inline ::SDMS::DependencySpecData* RecordUpdateRequest::add_dep_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::DependencySpecData* _add = _internal_mutable_dep_add()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordUpdateRequest.dep_add)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>& RecordUpdateRequest::dep_add() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordUpdateRequest.dep_add)
  return _internal_dep_add();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>&
RecordUpdateRequest::_internal_dep_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dep_add_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>*
RecordUpdateRequest::_internal_mutable_dep_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dep_add_;
}

// repeated .SDMS.DependencySpecData dep_rem = 17;
inline int RecordUpdateRequest::_internal_dep_rem_size() const {
  return _internal_dep_rem().size();
}
inline int RecordUpdateRequest::dep_rem_size() const {
  return _internal_dep_rem_size();
}
inline ::SDMS::DependencySpecData* RecordUpdateRequest::mutable_dep_rem(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateRequest.dep_rem)
  return _internal_mutable_dep_rem()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>* RecordUpdateRequest::mutable_dep_rem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordUpdateRequest.dep_rem)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dep_rem();
}
inline const ::SDMS::DependencySpecData& RecordUpdateRequest::dep_rem(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateRequest.dep_rem)
  return _internal_dep_rem().Get(index);
}
inline ::SDMS::DependencySpecData* RecordUpdateRequest::add_dep_rem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::DependencySpecData* _add = _internal_mutable_dep_rem()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordUpdateRequest.dep_rem)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>& RecordUpdateRequest::dep_rem() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordUpdateRequest.dep_rem)
  return _internal_dep_rem();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>&
RecordUpdateRequest::_internal_dep_rem() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dep_rem_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencySpecData>*
RecordUpdateRequest::_internal_mutable_dep_rem() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dep_rem_;
}

// -------------------------------------------------------------------

// RecordUpdateBatchRequest

// required string records = 1;
inline bool RecordUpdateBatchRequest::has_records() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordUpdateBatchRequest::clear_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.records_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordUpdateBatchRequest::records() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordUpdateBatchRequest.records)
  return _internal_records();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordUpdateBatchRequest::set_records(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.records_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordUpdateBatchRequest.records)
}
inline std::string* RecordUpdateBatchRequest::mutable_records() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_records();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordUpdateBatchRequest.records)
  return _s;
}
inline const std::string& RecordUpdateBatchRequest::_internal_records() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.records_.Get();
}
inline void RecordUpdateBatchRequest::_internal_set_records(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.records_.Set(value, GetArena());
}
inline std::string* RecordUpdateBatchRequest::_internal_mutable_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.records_.Mutable( GetArena());
}
inline std::string* RecordUpdateBatchRequest::release_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordUpdateBatchRequest.records)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.records_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.records_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordUpdateBatchRequest::set_allocated_records(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.records_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.records_.IsDefault()) {
          _impl_.records_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordUpdateBatchRequest.records)
}

// -------------------------------------------------------------------

// RecordExportRequest

// repeated string id = 1;
inline int RecordExportRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int RecordExportRequest::id_size() const {
  return _internal_id_size();
}
inline void RecordExportRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* RecordExportRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RecordExportRequest.id)
  return _s;
}
inline const std::string& RecordExportRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordExportRequest.id)
  return _internal_id().Get(index);
}
inline std::string* RecordExportRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordExportRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void RecordExportRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RecordExportRequest.id)
}
inline void RecordExportRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RecordExportRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordExportRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordExportRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordExportRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordExportRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordExportRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordExportRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// RecordExportReply

// repeated string record = 1;
inline int RecordExportReply::_internal_record_size() const {
  return _internal_record().size();
}
inline int RecordExportReply::record_size() const {
  return _internal_record_size();
}
inline void RecordExportReply::clear_record() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.record_.Clear();
}
inline std::string* RecordExportReply::add_record()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_record()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RecordExportReply.record)
  return _s;
}
inline const std::string& RecordExportReply::record(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordExportReply.record)
  return _internal_record().Get(index);
}
inline std::string* RecordExportReply::mutable_record(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordExportReply.record)
  return _internal_mutable_record()->Mutable(index);
}
inline void RecordExportReply::set_record(int index, const std::string& value) {
  _internal_mutable_record()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::set_record(int index, std::string&& value) {
  _internal_mutable_record()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::set_record(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_record()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::set_record(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_record()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::set_record(int index, absl::string_view value) {
  _internal_mutable_record()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::add_record(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_record()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::add_record(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_record()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::add_record(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_record()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::add_record(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_record()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RecordExportReply.record)
}
inline void RecordExportReply::add_record(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_record()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RecordExportReply.record)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordExportReply::record() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordExportReply.record)
  return _internal_record();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordExportReply::mutable_record() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordExportReply.record)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_record();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordExportReply::_internal_record() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.record_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordExportReply::_internal_mutable_record() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.record_;
}

// -------------------------------------------------------------------

// RecordLockRequest

// repeated string id = 1;
inline int RecordLockRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int RecordLockRequest::id_size() const {
  return _internal_id_size();
}
inline void RecordLockRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* RecordLockRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RecordLockRequest.id)
  return _s;
}
inline const std::string& RecordLockRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordLockRequest.id)
  return _internal_id().Get(index);
}
inline std::string* RecordLockRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordLockRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void RecordLockRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RecordLockRequest.id)
}
inline void RecordLockRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RecordLockRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordLockRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordLockRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordLockRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordLockRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordLockRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordLockRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// required bool lock = 2;
inline bool RecordLockRequest::has_lock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordLockRequest::clear_lock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lock_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RecordLockRequest::lock() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordLockRequest.lock)
  return _internal_lock();
}
inline void RecordLockRequest::set_lock(bool value) {
  _internal_set_lock(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordLockRequest.lock)
}
inline bool RecordLockRequest::_internal_lock() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lock_;
}
inline void RecordLockRequest::_internal_set_lock(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lock_ = value;
}

// -------------------------------------------------------------------

// RecordDeleteRequest

// repeated string id = 1;
inline int RecordDeleteRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int RecordDeleteRequest::id_size() const {
  return _internal_id_size();
}
inline void RecordDeleteRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* RecordDeleteRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RecordDeleteRequest.id)
  return _s;
}
inline const std::string& RecordDeleteRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordDeleteRequest.id)
  return _internal_id().Get(index);
}
inline std::string* RecordDeleteRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordDeleteRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void RecordDeleteRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RecordDeleteRequest.id)
}
inline void RecordDeleteRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RecordDeleteRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordDeleteRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordDeleteRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordDeleteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordDeleteRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordDeleteRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordDeleteRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// RecordGetDependencyGraphRequest

// required string id = 1;
inline bool RecordGetDependencyGraphRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordGetDependencyGraphRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordGetDependencyGraphRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordGetDependencyGraphRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordGetDependencyGraphRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordGetDependencyGraphRequest.id)
}
inline std::string* RecordGetDependencyGraphRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordGetDependencyGraphRequest.id)
  return _s;
}
inline const std::string& RecordGetDependencyGraphRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RecordGetDependencyGraphRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RecordGetDependencyGraphRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RecordGetDependencyGraphRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordGetDependencyGraphRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordGetDependencyGraphRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordGetDependencyGraphRequest.id)
}

// -------------------------------------------------------------------

// RecordAllocChangeRequest

// repeated string id = 1;
inline int RecordAllocChangeRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int RecordAllocChangeRequest::id_size() const {
  return _internal_id_size();
}
inline void RecordAllocChangeRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* RecordAllocChangeRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RecordAllocChangeRequest.id)
  return _s;
}
inline const std::string& RecordAllocChangeRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeRequest.id)
  return _internal_id().Get(index);
}
inline std::string* RecordAllocChangeRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordAllocChangeRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void RecordAllocChangeRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline void RecordAllocChangeRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RecordAllocChangeRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordAllocChangeRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordAllocChangeRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordAllocChangeRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordAllocChangeRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordAllocChangeRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordAllocChangeRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// required string repo_id = 2;
inline bool RecordAllocChangeRequest::has_repo_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordAllocChangeRequest::clear_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordAllocChangeRequest::repo_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeRequest.repo_id)
  return _internal_repo_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordAllocChangeRequest::set_repo_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeRequest.repo_id)
}
inline std::string* RecordAllocChangeRequest::mutable_repo_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordAllocChangeRequest.repo_id)
  return _s;
}
inline const std::string& RecordAllocChangeRequest::_internal_repo_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_id_.Get();
}
inline void RecordAllocChangeRequest::_internal_set_repo_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_id_.Set(value, GetArena());
}
inline std::string* RecordAllocChangeRequest::_internal_mutable_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_id_.Mutable( GetArena());
}
inline std::string* RecordAllocChangeRequest::release_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordAllocChangeRequest.repo_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordAllocChangeRequest::set_allocated_repo_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_id_.IsDefault()) {
          _impl_.repo_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordAllocChangeRequest.repo_id)
}

// optional string proj_id = 3;
inline bool RecordAllocChangeRequest::has_proj_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordAllocChangeRequest::clear_proj_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proj_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecordAllocChangeRequest::proj_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeRequest.proj_id)
  return _internal_proj_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordAllocChangeRequest::set_proj_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.proj_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeRequest.proj_id)
}
inline std::string* RecordAllocChangeRequest::mutable_proj_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_proj_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordAllocChangeRequest.proj_id)
  return _s;
}
inline const std::string& RecordAllocChangeRequest::_internal_proj_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proj_id_.Get();
}
inline void RecordAllocChangeRequest::_internal_set_proj_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.proj_id_.Set(value, GetArena());
}
inline std::string* RecordAllocChangeRequest::_internal_mutable_proj_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.proj_id_.Mutable( GetArena());
}
inline std::string* RecordAllocChangeRequest::release_proj_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordAllocChangeRequest.proj_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.proj_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.proj_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordAllocChangeRequest::set_allocated_proj_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.proj_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proj_id_.IsDefault()) {
          _impl_.proj_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordAllocChangeRequest.proj_id)
}

// optional bool check = 4;
inline bool RecordAllocChangeRequest::has_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordAllocChangeRequest::clear_check() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.check_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool RecordAllocChangeRequest::check() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeRequest.check)
  return _internal_check();
}
inline void RecordAllocChangeRequest::set_check(bool value) {
  _internal_set_check(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeRequest.check)
}
inline bool RecordAllocChangeRequest::_internal_check() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.check_;
}
inline void RecordAllocChangeRequest::_internal_set_check(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.check_ = value;
}

// -------------------------------------------------------------------

// RecordAllocChangeReply

// required uint32 act_cnt = 1;
inline bool RecordAllocChangeReply::has_act_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordAllocChangeReply::clear_act_cnt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.act_cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t RecordAllocChangeReply::act_cnt() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeReply.act_cnt)
  return _internal_act_cnt();
}
inline void RecordAllocChangeReply::set_act_cnt(::uint32_t value) {
  _internal_set_act_cnt(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeReply.act_cnt)
}
inline ::uint32_t RecordAllocChangeReply::_internal_act_cnt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.act_cnt_;
}
inline void RecordAllocChangeReply::_internal_set_act_cnt(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.act_cnt_ = value;
}

// required uint64 act_size = 2;
inline bool RecordAllocChangeReply::has_act_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordAllocChangeReply::clear_act_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.act_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RecordAllocChangeReply::act_size() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeReply.act_size)
  return _internal_act_size();
}
inline void RecordAllocChangeReply::set_act_size(::uint64_t value) {
  _internal_set_act_size(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeReply.act_size)
}
inline ::uint64_t RecordAllocChangeReply::_internal_act_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.act_size_;
}
inline void RecordAllocChangeReply::_internal_set_act_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.act_size_ = value;
}

// required uint32 tot_cnt = 3;
inline bool RecordAllocChangeReply::has_tot_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RecordAllocChangeReply::clear_tot_cnt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tot_cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RecordAllocChangeReply::tot_cnt() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeReply.tot_cnt)
  return _internal_tot_cnt();
}
inline void RecordAllocChangeReply::set_tot_cnt(::uint32_t value) {
  _internal_set_tot_cnt(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeReply.tot_cnt)
}
inline ::uint32_t RecordAllocChangeReply::_internal_tot_cnt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tot_cnt_;
}
inline void RecordAllocChangeReply::_internal_set_tot_cnt(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tot_cnt_ = value;
}

// required uint64 data_limit = 4;
inline bool RecordAllocChangeReply::has_data_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RecordAllocChangeReply::clear_data_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_limit_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t RecordAllocChangeReply::data_limit() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeReply.data_limit)
  return _internal_data_limit();
}
inline void RecordAllocChangeReply::set_data_limit(::uint64_t value) {
  _internal_set_data_limit(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeReply.data_limit)
}
inline ::uint64_t RecordAllocChangeReply::_internal_data_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_limit_;
}
inline void RecordAllocChangeReply::_internal_set_data_limit(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.data_limit_ = value;
}

// required uint64 data_size = 5;
inline bool RecordAllocChangeReply::has_data_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RecordAllocChangeReply::clear_data_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t RecordAllocChangeReply::data_size() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeReply.data_size)
  return _internal_data_size();
}
inline void RecordAllocChangeReply::set_data_size(::uint64_t value) {
  _internal_set_data_size(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeReply.data_size)
}
inline ::uint64_t RecordAllocChangeReply::_internal_data_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_size_;
}
inline void RecordAllocChangeReply::_internal_set_data_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.data_size_ = value;
}

// required uint32 rec_limit = 6;
inline bool RecordAllocChangeReply::has_rec_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RecordAllocChangeReply::clear_rec_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rec_limit_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t RecordAllocChangeReply::rec_limit() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeReply.rec_limit)
  return _internal_rec_limit();
}
inline void RecordAllocChangeReply::set_rec_limit(::uint32_t value) {
  _internal_set_rec_limit(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeReply.rec_limit)
}
inline ::uint32_t RecordAllocChangeReply::_internal_rec_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rec_limit_;
}
inline void RecordAllocChangeReply::_internal_set_rec_limit(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.rec_limit_ = value;
}

// required uint32 rec_count = 7;
inline bool RecordAllocChangeReply::has_rec_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RecordAllocChangeReply::clear_rec_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rec_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t RecordAllocChangeReply::rec_count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeReply.rec_count)
  return _internal_rec_count();
}
inline void RecordAllocChangeReply::set_rec_count(::uint32_t value) {
  _internal_set_rec_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordAllocChangeReply.rec_count)
}
inline ::uint32_t RecordAllocChangeReply::_internal_rec_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rec_count_;
}
inline void RecordAllocChangeReply::_internal_set_rec_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.rec_count_ = value;
}

// optional .SDMS.TaskData task = 8;
inline bool RecordAllocChangeReply::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::SDMS::TaskData& RecordAllocChangeReply::_internal_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::TaskData* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::TaskData&>(::SDMS::_TaskData_default_instance_);
}
inline const ::SDMS::TaskData& RecordAllocChangeReply::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordAllocChangeReply.task)
  return _internal_task();
}
inline void RecordAllocChangeReply::unsafe_arena_set_allocated_task(::SDMS::TaskData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.RecordAllocChangeReply.task)
}
inline ::SDMS::TaskData* RecordAllocChangeReply::release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::TaskData* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::TaskData* RecordAllocChangeReply::unsafe_arena_release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordAllocChangeReply.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::TaskData* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::SDMS::TaskData* RecordAllocChangeReply::_internal_mutable_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.task_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::TaskData>(GetArena());
    _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(p);
  }
  return _impl_.task_;
}
inline ::SDMS::TaskData* RecordAllocChangeReply::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::TaskData* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordAllocChangeReply.task)
  return _msg;
}
inline void RecordAllocChangeReply::set_allocated_task(::SDMS::TaskData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordAllocChangeReply.task)
}

// -------------------------------------------------------------------

// RecordOwnerChangeRequest

// repeated string id = 1;
inline int RecordOwnerChangeRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int RecordOwnerChangeRequest::id_size() const {
  return _internal_id_size();
}
inline void RecordOwnerChangeRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* RecordOwnerChangeRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RecordOwnerChangeRequest.id)
  return _s;
}
inline const std::string& RecordOwnerChangeRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeRequest.id)
  return _internal_id().Get(index);
}
inline std::string* RecordOwnerChangeRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordOwnerChangeRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void RecordOwnerChangeRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline void RecordOwnerChangeRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RecordOwnerChangeRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordOwnerChangeRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordOwnerChangeRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordOwnerChangeRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordOwnerChangeRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordOwnerChangeRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordOwnerChangeRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// required string coll_id = 2;
inline bool RecordOwnerChangeRequest::has_coll_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordOwnerChangeRequest::clear_coll_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coll_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordOwnerChangeRequest::coll_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeRequest.coll_id)
  return _internal_coll_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordOwnerChangeRequest::set_coll_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.coll_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeRequest.coll_id)
}
inline std::string* RecordOwnerChangeRequest::mutable_coll_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_coll_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordOwnerChangeRequest.coll_id)
  return _s;
}
inline const std::string& RecordOwnerChangeRequest::_internal_coll_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coll_id_.Get();
}
inline void RecordOwnerChangeRequest::_internal_set_coll_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.coll_id_.Set(value, GetArena());
}
inline std::string* RecordOwnerChangeRequest::_internal_mutable_coll_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.coll_id_.Mutable( GetArena());
}
inline std::string* RecordOwnerChangeRequest::release_coll_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordOwnerChangeRequest.coll_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.coll_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.coll_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordOwnerChangeRequest::set_allocated_coll_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.coll_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.coll_id_.IsDefault()) {
          _impl_.coll_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordOwnerChangeRequest.coll_id)
}

// optional string repo_id = 3;
inline bool RecordOwnerChangeRequest::has_repo_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordOwnerChangeRequest::clear_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecordOwnerChangeRequest::repo_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeRequest.repo_id)
  return _internal_repo_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordOwnerChangeRequest::set_repo_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.repo_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeRequest.repo_id)
}
inline std::string* RecordOwnerChangeRequest::mutable_repo_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordOwnerChangeRequest.repo_id)
  return _s;
}
inline const std::string& RecordOwnerChangeRequest::_internal_repo_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_id_.Get();
}
inline void RecordOwnerChangeRequest::_internal_set_repo_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.repo_id_.Set(value, GetArena());
}
inline std::string* RecordOwnerChangeRequest::_internal_mutable_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.repo_id_.Mutable( GetArena());
}
inline std::string* RecordOwnerChangeRequest::release_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordOwnerChangeRequest.repo_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.repo_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordOwnerChangeRequest::set_allocated_repo_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.repo_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_id_.IsDefault()) {
          _impl_.repo_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordOwnerChangeRequest.repo_id)
}

// optional string proj_id = 4;
inline bool RecordOwnerChangeRequest::has_proj_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordOwnerChangeRequest::clear_proj_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proj_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RecordOwnerChangeRequest::proj_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeRequest.proj_id)
  return _internal_proj_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordOwnerChangeRequest::set_proj_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.proj_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeRequest.proj_id)
}
inline std::string* RecordOwnerChangeRequest::mutable_proj_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_proj_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordOwnerChangeRequest.proj_id)
  return _s;
}
inline const std::string& RecordOwnerChangeRequest::_internal_proj_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proj_id_.Get();
}
inline void RecordOwnerChangeRequest::_internal_set_proj_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.proj_id_.Set(value, GetArena());
}
inline std::string* RecordOwnerChangeRequest::_internal_mutable_proj_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.proj_id_.Mutable( GetArena());
}
inline std::string* RecordOwnerChangeRequest::release_proj_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordOwnerChangeRequest.proj_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.proj_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.proj_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordOwnerChangeRequest::set_allocated_proj_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.proj_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proj_id_.IsDefault()) {
          _impl_.proj_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordOwnerChangeRequest.proj_id)
}

// optional bool check = 5;
inline bool RecordOwnerChangeRequest::has_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RecordOwnerChangeRequest::clear_check() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.check_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RecordOwnerChangeRequest::check() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeRequest.check)
  return _internal_check();
}
inline void RecordOwnerChangeRequest::set_check(bool value) {
  _internal_set_check(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeRequest.check)
}
inline bool RecordOwnerChangeRequest::_internal_check() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.check_;
}
inline void RecordOwnerChangeRequest::_internal_set_check(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.check_ = value;
}

// -------------------------------------------------------------------

// RecordOwnerChangeReply

// required uint32 act_cnt = 1;
inline bool RecordOwnerChangeReply::has_act_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordOwnerChangeReply::clear_act_cnt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.act_cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t RecordOwnerChangeReply::act_cnt() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeReply.act_cnt)
  return _internal_act_cnt();
}
inline void RecordOwnerChangeReply::set_act_cnt(::uint32_t value) {
  _internal_set_act_cnt(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeReply.act_cnt)
}
inline ::uint32_t RecordOwnerChangeReply::_internal_act_cnt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.act_cnt_;
}
inline void RecordOwnerChangeReply::_internal_set_act_cnt(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.act_cnt_ = value;
}

// required uint64 act_size = 2;
inline bool RecordOwnerChangeReply::has_act_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordOwnerChangeReply::clear_act_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.act_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RecordOwnerChangeReply::act_size() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeReply.act_size)
  return _internal_act_size();
}
inline void RecordOwnerChangeReply::set_act_size(::uint64_t value) {
  _internal_set_act_size(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeReply.act_size)
}
inline ::uint64_t RecordOwnerChangeReply::_internal_act_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.act_size_;
}
inline void RecordOwnerChangeReply::_internal_set_act_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.act_size_ = value;
}

// required uint32 tot_cnt = 3;
inline bool RecordOwnerChangeReply::has_tot_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RecordOwnerChangeReply::clear_tot_cnt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tot_cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RecordOwnerChangeReply::tot_cnt() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeReply.tot_cnt)
  return _internal_tot_cnt();
}
inline void RecordOwnerChangeReply::set_tot_cnt(::uint32_t value) {
  _internal_set_tot_cnt(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RecordOwnerChangeReply.tot_cnt)
}
inline ::uint32_t RecordOwnerChangeReply::_internal_tot_cnt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tot_cnt_;
}
inline void RecordOwnerChangeReply::_internal_set_tot_cnt(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tot_cnt_ = value;
}

// repeated .SDMS.AllocData alloc = 4;
inline int RecordOwnerChangeReply::_internal_alloc_size() const {
  return _internal_alloc().size();
}
inline int RecordOwnerChangeReply::alloc_size() const {
  return _internal_alloc_size();
}
inline ::SDMS::AllocData* RecordOwnerChangeReply::mutable_alloc(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordOwnerChangeReply.alloc)
  return _internal_mutable_alloc()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>* RecordOwnerChangeReply::mutable_alloc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RecordOwnerChangeReply.alloc)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alloc();
}
inline const ::SDMS::AllocData& RecordOwnerChangeReply::alloc(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeReply.alloc)
  return _internal_alloc().Get(index);
}
inline ::SDMS::AllocData* RecordOwnerChangeReply::add_alloc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::AllocData* _add = _internal_mutable_alloc()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RecordOwnerChangeReply.alloc)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>& RecordOwnerChangeReply::alloc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RecordOwnerChangeReply.alloc)
  return _internal_alloc();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>&
RecordOwnerChangeReply::_internal_alloc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alloc_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>*
RecordOwnerChangeReply::_internal_mutable_alloc() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alloc_;
}

// optional .SDMS.TaskData task = 8;
inline bool RecordOwnerChangeReply::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::SDMS::TaskData& RecordOwnerChangeReply::_internal_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::TaskData* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::TaskData&>(::SDMS::_TaskData_default_instance_);
}
inline const ::SDMS::TaskData& RecordOwnerChangeReply::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RecordOwnerChangeReply.task)
  return _internal_task();
}
inline void RecordOwnerChangeReply::unsafe_arena_set_allocated_task(::SDMS::TaskData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.RecordOwnerChangeReply.task)
}
inline ::SDMS::TaskData* RecordOwnerChangeReply::release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::TaskData* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::TaskData* RecordOwnerChangeReply::unsafe_arena_release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RecordOwnerChangeReply.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::TaskData* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::SDMS::TaskData* RecordOwnerChangeReply::_internal_mutable_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.task_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::TaskData>(GetArena());
    _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(p);
  }
  return _impl_.task_;
}
inline ::SDMS::TaskData* RecordOwnerChangeReply::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::TaskData* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RecordOwnerChangeReply.task)
  return _msg;
}
inline void RecordOwnerChangeReply::set_allocated_task(::SDMS::TaskData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RecordOwnerChangeReply.task)
}

// -------------------------------------------------------------------

// DataGetRequest

// repeated string id = 1;
inline int DataGetRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int DataGetRequest::id_size() const {
  return _internal_id_size();
}
inline void DataGetRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* DataGetRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.DataGetRequest.id)
  return _s;
}
inline const std::string& DataGetRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataGetRequest.id)
  return _internal_id().Get(index);
}
inline std::string* DataGetRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataGetRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void DataGetRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.DataGetRequest.id)
}
inline void DataGetRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.DataGetRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DataGetRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.DataGetRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DataGetRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.DataGetRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DataGetRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DataGetRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// optional string path = 2;
inline bool DataGetRequest::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DataGetRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataGetRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataGetRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataGetRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataGetRequest.path)
}
inline std::string* DataGetRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataGetRequest.path)
  return _s;
}
inline const std::string& DataGetRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void DataGetRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* DataGetRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* DataGetRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataGetRequest.path)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DataGetRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataGetRequest.path)
}

// optional .SDMS.Encryption encrypt = 3;
inline bool DataGetRequest::has_encrypt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DataGetRequest::clear_encrypt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encrypt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SDMS::Encryption DataGetRequest::encrypt() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataGetRequest.encrypt)
  return _internal_encrypt();
}
inline void DataGetRequest::set_encrypt(::SDMS::Encryption value) {
  _internal_set_encrypt(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataGetRequest.encrypt)
}
inline ::SDMS::Encryption DataGetRequest::_internal_encrypt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::Encryption>(_impl_.encrypt_);
}
inline void DataGetRequest::_internal_set_encrypt(::SDMS::Encryption value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::Encryption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.encrypt_ = value;
}

// optional bool orig_fname = 4;
inline bool DataGetRequest::has_orig_fname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DataGetRequest::clear_orig_fname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orig_fname_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool DataGetRequest::orig_fname() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataGetRequest.orig_fname)
  return _internal_orig_fname();
}
inline void DataGetRequest::set_orig_fname(bool value) {
  _internal_set_orig_fname(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataGetRequest.orig_fname)
}
inline bool DataGetRequest::_internal_orig_fname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.orig_fname_;
}
inline void DataGetRequest::_internal_set_orig_fname(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.orig_fname_ = value;
}

// optional bool check = 5;
inline bool DataGetRequest::has_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DataGetRequest::clear_check() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.check_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DataGetRequest::check() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataGetRequest.check)
  return _internal_check();
}
inline void DataGetRequest::set_check(bool value) {
  _internal_set_check(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataGetRequest.check)
}
inline bool DataGetRequest::_internal_check() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.check_;
}
inline void DataGetRequest::_internal_set_check(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.check_ = value;
}

// -------------------------------------------------------------------

// DataPutRequest

// required string id = 1;
inline bool DataPutRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DataPutRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataPutRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPutRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataPutRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataPutRequest.id)
}
inline std::string* DataPutRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataPutRequest.id)
  return _s;
}
inline const std::string& DataPutRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DataPutRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DataPutRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DataPutRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataPutRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DataPutRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataPutRequest.id)
}

// optional string path = 2;
inline bool DataPutRequest::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DataPutRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataPutRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPutRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataPutRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataPutRequest.path)
}
inline std::string* DataPutRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataPutRequest.path)
  return _s;
}
inline const std::string& DataPutRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void DataPutRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* DataPutRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* DataPutRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataPutRequest.path)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DataPutRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataPutRequest.path)
}

// optional .SDMS.Encryption encrypt = 3;
inline bool DataPutRequest::has_encrypt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DataPutRequest::clear_encrypt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encrypt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SDMS::Encryption DataPutRequest::encrypt() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPutRequest.encrypt)
  return _internal_encrypt();
}
inline void DataPutRequest::set_encrypt(::SDMS::Encryption value) {
  _internal_set_encrypt(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataPutRequest.encrypt)
}
inline ::SDMS::Encryption DataPutRequest::_internal_encrypt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::Encryption>(_impl_.encrypt_);
}
inline void DataPutRequest::_internal_set_encrypt(::SDMS::Encryption value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::Encryption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.encrypt_ = value;
}

// optional string ext = 4;
inline bool DataPutRequest::has_ext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DataPutRequest::clear_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataPutRequest::ext() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPutRequest.ext)
  return _internal_ext();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataPutRequest::set_ext(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ext_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataPutRequest.ext)
}
inline std::string* DataPutRequest::mutable_ext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ext();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataPutRequest.ext)
  return _s;
}
inline const std::string& DataPutRequest::_internal_ext() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ext_.Get();
}
inline void DataPutRequest::_internal_set_ext(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ext_.Set(value, GetArena());
}
inline std::string* DataPutRequest::_internal_mutable_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ext_.Mutable( GetArena());
}
inline std::string* DataPutRequest::release_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataPutRequest.ext)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.ext_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ext_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DataPutRequest::set_allocated_ext(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ext_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ext_.IsDefault()) {
          _impl_.ext_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataPutRequest.ext)
}

// optional bool check = 5;
inline bool DataPutRequest::has_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DataPutRequest::clear_check() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.check_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool DataPutRequest::check() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPutRequest.check)
  return _internal_check();
}
inline void DataPutRequest::set_check(bool value) {
  _internal_set_check(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataPutRequest.check)
}
inline bool DataPutRequest::_internal_check() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.check_;
}
inline void DataPutRequest::_internal_set_check(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.check_ = value;
}

// -------------------------------------------------------------------

// DataGetReply

// repeated .SDMS.ListingData item = 1;
inline int DataGetReply::_internal_item_size() const {
  return _internal_item().size();
}
inline int DataGetReply::item_size() const {
  return _internal_item_size();
}
inline ::SDMS::ListingData* DataGetReply::mutable_item(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataGetReply.item)
  return _internal_mutable_item()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* DataGetReply::mutable_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.DataGetReply.item)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_item();
}
inline const ::SDMS::ListingData& DataGetReply::item(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataGetReply.item)
  return _internal_item().Get(index);
}
inline ::SDMS::ListingData* DataGetReply::add_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::ListingData* _add = _internal_mutable_item()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.DataGetReply.item)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& DataGetReply::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.DataGetReply.item)
  return _internal_item();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>&
DataGetReply::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>*
DataGetReply::_internal_mutable_item() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.item_;
}

// optional .SDMS.TaskData task = 2;
inline bool DataGetReply::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::SDMS::TaskData& DataGetReply::_internal_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::TaskData* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::TaskData&>(::SDMS::_TaskData_default_instance_);
}
inline const ::SDMS::TaskData& DataGetReply::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataGetReply.task)
  return _internal_task();
}
inline void DataGetReply::unsafe_arena_set_allocated_task(::SDMS::TaskData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.DataGetReply.task)
}
inline ::SDMS::TaskData* DataGetReply::release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::TaskData* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::TaskData* DataGetReply::unsafe_arena_release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataGetReply.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::TaskData* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::SDMS::TaskData* DataGetReply::_internal_mutable_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.task_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::TaskData>(GetArena());
    _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(p);
  }
  return _impl_.task_;
}
inline ::SDMS::TaskData* DataGetReply::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::TaskData* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataGetReply.task)
  return _msg;
}
inline void DataGetReply::set_allocated_task(::SDMS::TaskData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataGetReply.task)
}

// -------------------------------------------------------------------

// DataPutReply

// required .SDMS.RecordData item = 1;
inline bool DataPutReply::has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.item_ != nullptr);
  return value;
}
inline const ::SDMS::RecordData& DataPutReply::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::RecordData* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::RecordData&>(::SDMS::_RecordData_default_instance_);
}
inline const ::SDMS::RecordData& DataPutReply::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPutReply.item)
  return _internal_item();
}
inline void DataPutReply::unsafe_arena_set_allocated_item(::SDMS::RecordData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = reinterpret_cast<::SDMS::RecordData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.DataPutReply.item)
}
inline ::SDMS::RecordData* DataPutReply::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::RecordData* released = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::RecordData* DataPutReply::unsafe_arena_release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataPutReply.item)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::RecordData* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::SDMS::RecordData* DataPutReply::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::RecordData>(GetArena());
    _impl_.item_ = reinterpret_cast<::SDMS::RecordData*>(p);
  }
  return _impl_.item_;
}
inline ::SDMS::RecordData* DataPutReply::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::RecordData* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataPutReply.item)
  return _msg;
}
inline void DataPutReply::set_allocated_item(::SDMS::RecordData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.item_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.item_ = reinterpret_cast<::SDMS::RecordData*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataPutReply.item)
}

// optional .SDMS.TaskData task = 2;
inline bool DataPutReply::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::SDMS::TaskData& DataPutReply::_internal_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::TaskData* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::TaskData&>(::SDMS::_TaskData_default_instance_);
}
inline const ::SDMS::TaskData& DataPutReply::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPutReply.task)
  return _internal_task();
}
inline void DataPutReply::unsafe_arena_set_allocated_task(::SDMS::TaskData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.DataPutReply.task)
}
inline ::SDMS::TaskData* DataPutReply::release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SDMS::TaskData* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::TaskData* DataPutReply::unsafe_arena_release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataPutReply.task)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SDMS::TaskData* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::SDMS::TaskData* DataPutReply::_internal_mutable_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.task_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::TaskData>(GetArena());
    _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(p);
  }
  return _impl_.task_;
}
inline ::SDMS::TaskData* DataPutReply::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::TaskData* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataPutReply.task)
  return _msg;
}
inline void DataPutReply::set_allocated_task(::SDMS::TaskData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.task_ = reinterpret_cast<::SDMS::TaskData*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataPutReply.task)
}

// -------------------------------------------------------------------

// DataDeleteRequest

// repeated string id = 1;
inline int DataDeleteRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int DataDeleteRequest::id_size() const {
  return _internal_id_size();
}
inline void DataDeleteRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* DataDeleteRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.DataDeleteRequest.id)
  return _s;
}
inline const std::string& DataDeleteRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataDeleteRequest.id)
  return _internal_id().Get(index);
}
inline std::string* DataDeleteRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataDeleteRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void DataDeleteRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.DataDeleteRequest.id)
}
inline void DataDeleteRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.DataDeleteRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DataDeleteRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.DataDeleteRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DataDeleteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.DataDeleteRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DataDeleteRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DataDeleteRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// DataPathRequest

// required string id = 1;
inline bool DataPathRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DataPathRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataPathRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPathRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataPathRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataPathRequest.id)
}
inline std::string* DataPathRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataPathRequest.id)
  return _s;
}
inline const std::string& DataPathRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DataPathRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DataPathRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DataPathRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataPathRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DataPathRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataPathRequest.id)
}

// required string domain = 2;
inline bool DataPathRequest::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DataPathRequest::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataPathRequest::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPathRequest.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataPathRequest::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataPathRequest.domain)
}
inline std::string* DataPathRequest::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataPathRequest.domain)
  return _s;
}
inline const std::string& DataPathRequest::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void DataPathRequest::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* DataPathRequest::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* DataPathRequest::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataPathRequest.domain)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.domain_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DataPathRequest::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataPathRequest.domain)
}

// -------------------------------------------------------------------

// DataPathReply

// required string path = 1;
inline bool DataPathReply::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DataPathReply::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataPathReply::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.DataPathReply.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataPathReply::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.DataPathReply.path)
}
inline std::string* DataPathReply::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.DataPathReply.path)
  return _s;
}
inline const std::string& DataPathReply::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void DataPathReply::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* DataPathReply::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* DataPathReply::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.DataPathReply.path)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DataPathReply::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.DataPathReply.path)
}

// -------------------------------------------------------------------

// SearchRequest

// required .SDMS.SearchMode mode = 1;
inline bool SearchRequest::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SearchRequest::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::SDMS::SearchMode SearchRequest::mode() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.mode)
  return _internal_mode();
}
inline void SearchRequest::set_mode(::SDMS::SearchMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.mode)
}
inline ::SDMS::SearchMode SearchRequest::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::SearchMode>(_impl_.mode_);
}
inline void SearchRequest::_internal_set_mode(::SDMS::SearchMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::SearchMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.mode_ = value;
}

// optional bool published = 2;
inline bool SearchRequest::has_published() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void SearchRequest::clear_published() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.published_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool SearchRequest::published() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.published)
  return _internal_published();
}
inline void SearchRequest::set_published(bool value) {
  _internal_set_published(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.published)
}
inline bool SearchRequest::_internal_published() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.published_;
}
inline void SearchRequest::_internal_set_published(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.published_ = value;
}

// optional string id = 3;
inline bool SearchRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SearchRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SearchRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.id)
}
inline std::string* SearchRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.id)
  return _s;
}
inline const std::string& SearchRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void SearchRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SearchRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SearchRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SearchRequest.id)
}

// optional string text = 4;
inline bool SearchRequest::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SearchRequest::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SearchRequest::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.text)
}
inline std::string* SearchRequest::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.text)
  return _s;
}
inline const std::string& SearchRequest::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void SearchRequest::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SearchRequest.text)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.text_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SearchRequest::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SearchRequest.text)
}

// repeated string tags = 5;
inline int SearchRequest::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int SearchRequest::tags_size() const {
  return _internal_tags_size();
}
inline void SearchRequest::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* SearchRequest::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.SearchRequest.tags)
  return _s;
}
inline const std::string& SearchRequest::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.tags)
  return _internal_tags().Get(index);
}
inline std::string* SearchRequest::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void SearchRequest::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.SearchRequest.tags)
}
inline void SearchRequest::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.SearchRequest.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SearchRequest::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.SearchRequest.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SearchRequest::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.SearchRequest.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SearchRequest::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SearchRequest::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// repeated string cat_tags = 6;
inline int SearchRequest::_internal_cat_tags_size() const {
  return _internal_cat_tags().size();
}
inline int SearchRequest::cat_tags_size() const {
  return _internal_cat_tags_size();
}
inline void SearchRequest::clear_cat_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cat_tags_.Clear();
}
inline std::string* SearchRequest::add_cat_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_cat_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.SearchRequest.cat_tags)
  return _s;
}
inline const std::string& SearchRequest::cat_tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.cat_tags)
  return _internal_cat_tags().Get(index);
}
inline std::string* SearchRequest::mutable_cat_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.cat_tags)
  return _internal_mutable_cat_tags()->Mutable(index);
}
inline void SearchRequest::set_cat_tags(int index, const std::string& value) {
  _internal_mutable_cat_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::set_cat_tags(int index, std::string&& value) {
  _internal_mutable_cat_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::set_cat_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_cat_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::set_cat_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_cat_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::set_cat_tags(int index, absl::string_view value) {
  _internal_mutable_cat_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::add_cat_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cat_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::add_cat_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cat_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::add_cat_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cat_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::add_cat_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cat_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.SearchRequest.cat_tags)
}
inline void SearchRequest::add_cat_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cat_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.SearchRequest.cat_tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SearchRequest::cat_tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.SearchRequest.cat_tags)
  return _internal_cat_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SearchRequest::mutable_cat_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.SearchRequest.cat_tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cat_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SearchRequest::_internal_cat_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cat_tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SearchRequest::_internal_mutable_cat_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cat_tags_;
}

// optional uint32 from = 7;
inline bool SearchRequest::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SearchRequest::clear_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t SearchRequest::from() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.from)
  return _internal_from();
}
inline void SearchRequest::set_from(::uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.from)
}
inline ::uint32_t SearchRequest::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_;
}
inline void SearchRequest::_internal_set_from(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.from_ = value;
}

// optional uint32 to = 8;
inline bool SearchRequest::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void SearchRequest::clear_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t SearchRequest::to() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.to)
  return _internal_to();
}
inline void SearchRequest::set_to(::uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.to)
}
inline ::uint32_t SearchRequest::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_;
}
inline void SearchRequest::_internal_set_to(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.to_ = value;
}

// optional string owner = 9;
inline bool SearchRequest::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SearchRequest::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SearchRequest::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_owner(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.owner)
}
inline std::string* SearchRequest::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.owner)
  return _s;
}
inline const std::string& SearchRequest::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_.Get();
}
inline void SearchRequest::_internal_set_owner(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owner_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.owner_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SearchRequest.owner)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SearchRequest::set_allocated_owner(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SearchRequest.owner)
}

// optional string creator = 10;
inline bool SearchRequest::has_creator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SearchRequest::clear_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SearchRequest::creator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_creator(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.creator)
}
inline std::string* SearchRequest::mutable_creator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.creator)
  return _s;
}
inline const std::string& SearchRequest::_internal_creator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.creator_.Get();
}
inline void SearchRequest::_internal_set_creator(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.creator_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.creator_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SearchRequest.creator)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.creator_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.creator_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SearchRequest::set_allocated_creator(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.creator_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SearchRequest.creator)
}

// repeated string coll = 11;
inline int SearchRequest::_internal_coll_size() const {
  return _internal_coll().size();
}
inline int SearchRequest::coll_size() const {
  return _internal_coll_size();
}
inline void SearchRequest::clear_coll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coll_.Clear();
}
inline std::string* SearchRequest::add_coll()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_coll()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.SearchRequest.coll)
  return _s;
}
inline const std::string& SearchRequest::coll(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.coll)
  return _internal_coll().Get(index);
}
inline std::string* SearchRequest::mutable_coll(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.coll)
  return _internal_mutable_coll()->Mutable(index);
}
inline void SearchRequest::set_coll(int index, const std::string& value) {
  _internal_mutable_coll()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::set_coll(int index, std::string&& value) {
  _internal_mutable_coll()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::set_coll(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_coll()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::set_coll(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_coll()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::set_coll(int index, absl::string_view value) {
  _internal_mutable_coll()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::add_coll(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_coll()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::add_coll(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_coll()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::add_coll(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_coll()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::add_coll(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_coll()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.SearchRequest.coll)
}
inline void SearchRequest::add_coll(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_coll()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.SearchRequest.coll)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SearchRequest::coll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.SearchRequest.coll)
  return _internal_coll();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SearchRequest::mutable_coll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.SearchRequest.coll)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_coll();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SearchRequest::_internal_coll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coll_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SearchRequest::_internal_mutable_coll() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.coll_;
}

// optional string sch_id = 12;
inline bool SearchRequest::has_sch_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SearchRequest::clear_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sch_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SearchRequest::sch_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.sch_id)
  return _internal_sch_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_sch_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sch_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.sch_id)
}
inline std::string* SearchRequest::mutable_sch_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sch_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.sch_id)
  return _s;
}
inline const std::string& SearchRequest::_internal_sch_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sch_id_.Get();
}
inline void SearchRequest::_internal_set_sch_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sch_id_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.sch_id_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SearchRequest.sch_id)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.sch_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sch_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SearchRequest::set_allocated_sch_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.sch_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sch_id_.IsDefault()) {
          _impl_.sch_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SearchRequest.sch_id)
}

// optional string meta = 13;
inline bool SearchRequest::has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SearchRequest::clear_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.meta_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SearchRequest::meta() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.meta)
  return _internal_meta();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_meta(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.meta_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.meta)
}
inline std::string* SearchRequest::mutable_meta() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SearchRequest.meta)
  return _s;
}
inline const std::string& SearchRequest::_internal_meta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.meta_.Get();
}
inline void SearchRequest::_internal_set_meta(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.meta_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.meta_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SearchRequest.meta)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.meta_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.meta_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SearchRequest::set_allocated_meta(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.meta_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.meta_.IsDefault()) {
          _impl_.meta_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SearchRequest.meta)
}

// optional bool meta_err = 14;
inline bool SearchRequest::has_meta_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void SearchRequest::clear_meta_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.meta_err_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool SearchRequest::meta_err() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.meta_err)
  return _internal_meta_err();
}
inline void SearchRequest::set_meta_err(bool value) {
  _internal_set_meta_err(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.meta_err)
}
inline bool SearchRequest::_internal_meta_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.meta_err_;
}
inline void SearchRequest::_internal_set_meta_err(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.meta_err_ = value;
}

// optional .SDMS.SortOption sort = 15;
inline bool SearchRequest::has_sort() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void SearchRequest::clear_sort() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sort_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::SDMS::SortOption SearchRequest::sort() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.sort)
  return _internal_sort();
}
inline void SearchRequest::set_sort(::SDMS::SortOption value) {
  _internal_set_sort(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.sort)
}
inline ::SDMS::SortOption SearchRequest::_internal_sort() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::SortOption>(_impl_.sort_);
}
inline void SearchRequest::_internal_set_sort(::SDMS::SortOption value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::SortOption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.sort_ = value;
}

// optional bool sort_rev = 16;
inline bool SearchRequest::has_sort_rev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void SearchRequest::clear_sort_rev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sort_rev_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool SearchRequest::sort_rev() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.sort_rev)
  return _internal_sort_rev();
}
inline void SearchRequest::set_sort_rev(bool value) {
  _internal_set_sort_rev(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.sort_rev)
}
inline bool SearchRequest::_internal_sort_rev() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sort_rev_;
}
inline void SearchRequest::_internal_set_sort_rev(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.sort_rev_ = value;
}

// optional uint32 offset = 17;
inline bool SearchRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void SearchRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t SearchRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.offset)
  return _internal_offset();
}
inline void SearchRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.offset)
}
inline ::uint32_t SearchRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void SearchRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.offset_ = value;
}

// optional uint32 count = 18;
inline bool SearchRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void SearchRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint32_t SearchRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SearchRequest.count)
  return _internal_count();
}
inline void SearchRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SearchRequest.count)
}
inline ::uint32_t SearchRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void SearchRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// CollViewRequest

// required string id = 1;
inline bool CollViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollViewRequest.id)
}
inline std::string* CollViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollViewRequest.id)
  return _s;
}
inline const std::string& CollViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CollViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CollViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CollViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollViewRequest.id)
}

// -------------------------------------------------------------------

// CollDataReply

// repeated .SDMS.CollData coll = 1;
inline int CollDataReply::_internal_coll_size() const {
  return _internal_coll().size();
}
inline int CollDataReply::coll_size() const {
  return _internal_coll_size();
}
inline ::SDMS::CollData* CollDataReply::mutable_coll(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollDataReply.coll)
  return _internal_mutable_coll()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::CollData>* CollDataReply::mutable_coll()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollDataReply.coll)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_coll();
}
inline const ::SDMS::CollData& CollDataReply::coll(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollDataReply.coll)
  return _internal_coll().Get(index);
}
inline ::SDMS::CollData* CollDataReply::add_coll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::CollData* _add = _internal_mutable_coll()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollDataReply.coll)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::CollData>& CollDataReply::coll() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollDataReply.coll)
  return _internal_coll();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::CollData>&
CollDataReply::_internal_coll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coll_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::CollData>*
CollDataReply::_internal_mutable_coll() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.coll_;
}

// repeated .SDMS.ListingData update = 2;
inline int CollDataReply::_internal_update_size() const {
  return _internal_update().size();
}
inline int CollDataReply::update_size() const {
  return _internal_update_size();
}
inline ::SDMS::ListingData* CollDataReply::mutable_update(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollDataReply.update)
  return _internal_mutable_update()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* CollDataReply::mutable_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollDataReply.update)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_update();
}
inline const ::SDMS::ListingData& CollDataReply::update(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollDataReply.update)
  return _internal_update().Get(index);
}
inline ::SDMS::ListingData* CollDataReply::add_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::ListingData* _add = _internal_mutable_update()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollDataReply.update)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& CollDataReply::update() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollDataReply.update)
  return _internal_update();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>&
CollDataReply::_internal_update() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>*
CollDataReply::_internal_mutable_update() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.update_;
}

// -------------------------------------------------------------------

// CollReadRequest

// required string id = 1;
inline bool CollReadRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollReadRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollReadRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollReadRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollReadRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollReadRequest.id)
}
inline std::string* CollReadRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollReadRequest.id)
  return _s;
}
inline const std::string& CollReadRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CollReadRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CollReadRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CollReadRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollReadRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollReadRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollReadRequest.id)
}

// optional bool details = 3;
inline bool CollReadRequest::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollReadRequest::clear_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.details_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CollReadRequest::details() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollReadRequest.details)
  return _internal_details();
}
inline void CollReadRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollReadRequest.details)
}
inline bool CollReadRequest::_internal_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.details_;
}
inline void CollReadRequest::_internal_set_details(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.details_ = value;
}

// optional uint32 offset = 4;
inline bool CollReadRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CollReadRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t CollReadRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollReadRequest.offset)
  return _internal_offset();
}
inline void CollReadRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollReadRequest.offset)
}
inline ::uint32_t CollReadRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void CollReadRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.offset_ = value;
}

// optional uint32 count = 5;
inline bool CollReadRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CollReadRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t CollReadRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollReadRequest.count)
  return _internal_count();
}
inline void CollReadRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollReadRequest.count)
}
inline ::uint32_t CollReadRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void CollReadRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// CollCreateRequest

// optional string title = 1;
inline bool CollCreateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollCreateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollCreateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollCreateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollCreateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollCreateRequest.title)
}
inline std::string* CollCreateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollCreateRequest.title)
  return _s;
}
inline const std::string& CollCreateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void CollCreateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* CollCreateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* CollCreateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollCreateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollCreateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollCreateRequest.title)
}

// optional string desc = 2;
inline bool CollCreateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollCreateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CollCreateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollCreateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollCreateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollCreateRequest.desc)
}
inline std::string* CollCreateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollCreateRequest.desc)
  return _s;
}
inline const std::string& CollCreateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void CollCreateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* CollCreateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* CollCreateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollCreateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollCreateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollCreateRequest.desc)
}

// optional string alias = 3;
inline bool CollCreateRequest::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CollCreateRequest::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CollCreateRequest::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollCreateRequest.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollCreateRequest::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollCreateRequest.alias)
}
inline std::string* CollCreateRequest::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollCreateRequest.alias)
  return _s;
}
inline const std::string& CollCreateRequest::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void CollCreateRequest::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* CollCreateRequest::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* CollCreateRequest::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollCreateRequest.alias)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.alias_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollCreateRequest::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollCreateRequest.alias)
}

// optional string parent_id = 4;
inline bool CollCreateRequest::has_parent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CollCreateRequest::clear_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CollCreateRequest::parent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollCreateRequest.parent_id)
  return _internal_parent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollCreateRequest::set_parent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.parent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollCreateRequest.parent_id)
}
inline std::string* CollCreateRequest::mutable_parent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollCreateRequest.parent_id)
  return _s;
}
inline const std::string& CollCreateRequest::_internal_parent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_id_.Get();
}
inline void CollCreateRequest::_internal_set_parent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.parent_id_.Set(value, GetArena());
}
inline std::string* CollCreateRequest::_internal_mutable_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.parent_id_.Mutable( GetArena());
}
inline std::string* CollCreateRequest::release_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollCreateRequest.parent_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.parent_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollCreateRequest::set_allocated_parent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.parent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_id_.IsDefault()) {
          _impl_.parent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollCreateRequest.parent_id)
}

// optional string topic = 6;
inline bool CollCreateRequest::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CollCreateRequest::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CollCreateRequest::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollCreateRequest.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollCreateRequest::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollCreateRequest.topic)
}
inline std::string* CollCreateRequest::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollCreateRequest.topic)
  return _s;
}
inline const std::string& CollCreateRequest::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CollCreateRequest::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CollCreateRequest::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CollCreateRequest::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollCreateRequest.topic)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollCreateRequest::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollCreateRequest.topic)
}

// repeated string tags = 7;
inline int CollCreateRequest::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int CollCreateRequest::tags_size() const {
  return _internal_tags_size();
}
inline void CollCreateRequest::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* CollCreateRequest::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.CollCreateRequest.tags)
  return _s;
}
inline const std::string& CollCreateRequest::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollCreateRequest.tags)
  return _internal_tags().Get(index);
}
inline std::string* CollCreateRequest::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollCreateRequest.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void CollCreateRequest::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.CollCreateRequest.tags)
}
inline void CollCreateRequest::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.CollCreateRequest.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollCreateRequest::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollCreateRequest.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollCreateRequest::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollCreateRequest.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollCreateRequest::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollCreateRequest::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// CollUpdateRequest

// required string id = 1;
inline bool CollUpdateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollUpdateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollUpdateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollUpdateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollUpdateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollUpdateRequest.id)
}
inline std::string* CollUpdateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollUpdateRequest.id)
  return _s;
}
inline const std::string& CollUpdateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CollUpdateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CollUpdateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CollUpdateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollUpdateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollUpdateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollUpdateRequest.id)
}

// optional string title = 2;
inline bool CollUpdateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollUpdateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CollUpdateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollUpdateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollUpdateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollUpdateRequest.title)
}
inline std::string* CollUpdateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollUpdateRequest.title)
  return _s;
}
inline const std::string& CollUpdateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void CollUpdateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* CollUpdateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* CollUpdateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollUpdateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollUpdateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollUpdateRequest.title)
}

// optional string desc = 3;
inline bool CollUpdateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CollUpdateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CollUpdateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollUpdateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollUpdateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollUpdateRequest.desc)
}
inline std::string* CollUpdateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollUpdateRequest.desc)
  return _s;
}
inline const std::string& CollUpdateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void CollUpdateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* CollUpdateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* CollUpdateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollUpdateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollUpdateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollUpdateRequest.desc)
}

// optional string alias = 4;
inline bool CollUpdateRequest::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CollUpdateRequest::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CollUpdateRequest::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollUpdateRequest.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollUpdateRequest::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollUpdateRequest.alias)
}
inline std::string* CollUpdateRequest::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollUpdateRequest.alias)
  return _s;
}
inline const std::string& CollUpdateRequest::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void CollUpdateRequest::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* CollUpdateRequest::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* CollUpdateRequest::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollUpdateRequest.alias)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.alias_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollUpdateRequest::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollUpdateRequest.alias)
}

// optional string topic = 6;
inline bool CollUpdateRequest::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CollUpdateRequest::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CollUpdateRequest::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollUpdateRequest.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollUpdateRequest::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollUpdateRequest.topic)
}
inline std::string* CollUpdateRequest::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollUpdateRequest.topic)
  return _s;
}
inline const std::string& CollUpdateRequest::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CollUpdateRequest::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CollUpdateRequest::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CollUpdateRequest::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollUpdateRequest.topic)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollUpdateRequest::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollUpdateRequest.topic)
}

// repeated string tags = 7;
inline int CollUpdateRequest::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int CollUpdateRequest::tags_size() const {
  return _internal_tags_size();
}
inline void CollUpdateRequest::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* CollUpdateRequest::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.CollUpdateRequest.tags)
  return _s;
}
inline const std::string& CollUpdateRequest::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollUpdateRequest.tags)
  return _internal_tags().Get(index);
}
inline std::string* CollUpdateRequest::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollUpdateRequest.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void CollUpdateRequest::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.CollUpdateRequest.tags)
}
inline void CollUpdateRequest::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.CollUpdateRequest.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollUpdateRequest::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollUpdateRequest.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollUpdateRequest::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollUpdateRequest.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollUpdateRequest::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollUpdateRequest::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// optional bool tags_clear = 8;
inline bool CollUpdateRequest::has_tags_clear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CollUpdateRequest::clear_tags_clear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_clear_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool CollUpdateRequest::tags_clear() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollUpdateRequest.tags_clear)
  return _internal_tags_clear();
}
inline void CollUpdateRequest::set_tags_clear(bool value) {
  _internal_set_tags_clear(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollUpdateRequest.tags_clear)
}
inline bool CollUpdateRequest::_internal_tags_clear() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_clear_;
}
inline void CollUpdateRequest::_internal_set_tags_clear(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tags_clear_ = value;
}

// -------------------------------------------------------------------

// CollDeleteRequest

// repeated string id = 1;
inline int CollDeleteRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int CollDeleteRequest::id_size() const {
  return _internal_id_size();
}
inline void CollDeleteRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* CollDeleteRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.CollDeleteRequest.id)
  return _s;
}
inline const std::string& CollDeleteRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollDeleteRequest.id)
  return _internal_id().Get(index);
}
inline std::string* CollDeleteRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollDeleteRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void CollDeleteRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.CollDeleteRequest.id)
}
inline void CollDeleteRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.CollDeleteRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollDeleteRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollDeleteRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollDeleteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollDeleteRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollDeleteRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollDeleteRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// CollWriteRequest

// required string id = 1;
inline bool CollWriteRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollWriteRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollWriteRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollWriteRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollWriteRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollWriteRequest.id)
}
inline std::string* CollWriteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollWriteRequest.id)
  return _s;
}
inline const std::string& CollWriteRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CollWriteRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CollWriteRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CollWriteRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollWriteRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollWriteRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollWriteRequest.id)
}

// repeated string add = 2;
inline int CollWriteRequest::_internal_add_size() const {
  return _internal_add().size();
}
inline int CollWriteRequest::add_size() const {
  return _internal_add_size();
}
inline void CollWriteRequest::clear_add() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_.Clear();
}
inline std::string* CollWriteRequest::add_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_add()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.CollWriteRequest.add)
  return _s;
}
inline const std::string& CollWriteRequest::add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollWriteRequest.add)
  return _internal_add().Get(index);
}
inline std::string* CollWriteRequest::mutable_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollWriteRequest.add)
  return _internal_mutable_add()->Mutable(index);
}
inline void CollWriteRequest::set_add(int index, const std::string& value) {
  _internal_mutable_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::set_add(int index, std::string&& value) {
  _internal_mutable_add()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::set_add(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::set_add(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_add()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::set_add(int index, absl::string_view value) {
  _internal_mutable_add()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::add_add(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::add_add(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::add_add(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::add_add(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.CollWriteRequest.add)
}
inline void CollWriteRequest::add_add(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.CollWriteRequest.add)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollWriteRequest::add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollWriteRequest.add)
  return _internal_add();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollWriteRequest::mutable_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollWriteRequest.add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_add();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollWriteRequest::_internal_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollWriteRequest::_internal_mutable_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.add_;
}

// repeated string rem = 3;
inline int CollWriteRequest::_internal_rem_size() const {
  return _internal_rem().size();
}
inline int CollWriteRequest::rem_size() const {
  return _internal_rem_size();
}
inline void CollWriteRequest::clear_rem() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rem_.Clear();
}
inline std::string* CollWriteRequest::add_rem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_rem()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.CollWriteRequest.rem)
  return _s;
}
inline const std::string& CollWriteRequest::rem(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollWriteRequest.rem)
  return _internal_rem().Get(index);
}
inline std::string* CollWriteRequest::mutable_rem(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollWriteRequest.rem)
  return _internal_mutable_rem()->Mutable(index);
}
inline void CollWriteRequest::set_rem(int index, const std::string& value) {
  _internal_mutable_rem()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::set_rem(int index, std::string&& value) {
  _internal_mutable_rem()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::set_rem(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_rem()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::set_rem(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_rem()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::set_rem(int index, absl::string_view value) {
  _internal_mutable_rem()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::add_rem(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::add_rem(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::add_rem(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::add_rem(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.CollWriteRequest.rem)
}
inline void CollWriteRequest::add_rem(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.CollWriteRequest.rem)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollWriteRequest::rem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollWriteRequest.rem)
  return _internal_rem();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollWriteRequest::mutable_rem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollWriteRequest.rem)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rem();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollWriteRequest::_internal_rem() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rem_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollWriteRequest::_internal_mutable_rem() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rem_;
}

// optional bool rem_all = 4;
inline bool CollWriteRequest::has_rem_all() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollWriteRequest::clear_rem_all() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rem_all_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CollWriteRequest::rem_all() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollWriteRequest.rem_all)
  return _internal_rem_all();
}
inline void CollWriteRequest::set_rem_all(bool value) {
  _internal_set_rem_all(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollWriteRequest.rem_all)
}
inline bool CollWriteRequest::_internal_rem_all() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rem_all_;
}
inline void CollWriteRequest::_internal_set_rem_all(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rem_all_ = value;
}

// -------------------------------------------------------------------

// CollMoveRequest

// required string src_id = 1;
inline bool CollMoveRequest::has_src_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollMoveRequest::clear_src_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.src_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollMoveRequest::src_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollMoveRequest.src_id)
  return _internal_src_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollMoveRequest::set_src_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.src_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollMoveRequest.src_id)
}
inline std::string* CollMoveRequest::mutable_src_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_src_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollMoveRequest.src_id)
  return _s;
}
inline const std::string& CollMoveRequest::_internal_src_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.src_id_.Get();
}
inline void CollMoveRequest::_internal_set_src_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.src_id_.Set(value, GetArena());
}
inline std::string* CollMoveRequest::_internal_mutable_src_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.src_id_.Mutable( GetArena());
}
inline std::string* CollMoveRequest::release_src_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollMoveRequest.src_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.src_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollMoveRequest::set_allocated_src_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_id_.IsDefault()) {
          _impl_.src_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollMoveRequest.src_id)
}

// required string dst_id = 2;
inline bool CollMoveRequest::has_dst_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollMoveRequest::clear_dst_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dst_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CollMoveRequest::dst_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollMoveRequest.dst_id)
  return _internal_dst_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollMoveRequest::set_dst_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dst_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollMoveRequest.dst_id)
}
inline std::string* CollMoveRequest::mutable_dst_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dst_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollMoveRequest.dst_id)
  return _s;
}
inline const std::string& CollMoveRequest::_internal_dst_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dst_id_.Get();
}
inline void CollMoveRequest::_internal_set_dst_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dst_id_.Set(value, GetArena());
}
inline std::string* CollMoveRequest::_internal_mutable_dst_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dst_id_.Mutable( GetArena());
}
inline std::string* CollMoveRequest::release_dst_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollMoveRequest.dst_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dst_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollMoveRequest::set_allocated_dst_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_id_.IsDefault()) {
          _impl_.dst_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollMoveRequest.dst_id)
}

// repeated string item = 3;
inline int CollMoveRequest::_internal_item_size() const {
  return _internal_item().size();
}
inline int CollMoveRequest::item_size() const {
  return _internal_item_size();
}
inline void CollMoveRequest::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.Clear();
}
inline std::string* CollMoveRequest::add_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_item()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.CollMoveRequest.item)
  return _s;
}
inline const std::string& CollMoveRequest::item(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollMoveRequest.item)
  return _internal_item().Get(index);
}
inline std::string* CollMoveRequest::mutable_item(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollMoveRequest.item)
  return _internal_mutable_item()->Mutable(index);
}
inline void CollMoveRequest::set_item(int index, const std::string& value) {
  _internal_mutable_item()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::set_item(int index, std::string&& value) {
  _internal_mutable_item()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::set_item(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_item()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::set_item(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_item()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::set_item(int index, absl::string_view value) {
  _internal_mutable_item()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::add_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::add_item(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::add_item(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::add_item(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.CollMoveRequest.item)
}
inline void CollMoveRequest::add_item(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.CollMoveRequest.item)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollMoveRequest::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollMoveRequest.item)
  return _internal_item();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollMoveRequest::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollMoveRequest.item)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_item();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollMoveRequest::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollMoveRequest::_internal_mutable_item() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.item_;
}

// -------------------------------------------------------------------

// CollGetParentsRequest

// required string id = 1;
inline bool CollGetParentsRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollGetParentsRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollGetParentsRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollGetParentsRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollGetParentsRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollGetParentsRequest.id)
}
inline std::string* CollGetParentsRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollGetParentsRequest.id)
  return _s;
}
inline const std::string& CollGetParentsRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CollGetParentsRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CollGetParentsRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CollGetParentsRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollGetParentsRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollGetParentsRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollGetParentsRequest.id)
}

// optional bool inclusive = 2;
inline bool CollGetParentsRequest::has_inclusive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollGetParentsRequest::clear_inclusive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inclusive_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CollGetParentsRequest::inclusive() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollGetParentsRequest.inclusive)
  return _internal_inclusive();
}
inline void CollGetParentsRequest::set_inclusive(bool value) {
  _internal_set_inclusive(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollGetParentsRequest.inclusive)
}
inline bool CollGetParentsRequest::_internal_inclusive() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inclusive_;
}
inline void CollGetParentsRequest::_internal_set_inclusive(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.inclusive_ = value;
}

// -------------------------------------------------------------------

// CollPathReply

// repeated .SDMS.PathData path = 1;
inline int CollPathReply::_internal_path_size() const {
  return _internal_path().size();
}
inline int CollPathReply::path_size() const {
  return _internal_path_size();
}
inline ::SDMS::PathData* CollPathReply::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollPathReply.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::PathData>* CollPathReply::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.CollPathReply.path)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_path();
}
inline const ::SDMS::PathData& CollPathReply::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollPathReply.path)
  return _internal_path().Get(index);
}
inline ::SDMS::PathData* CollPathReply::add_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::PathData* _add = _internal_mutable_path()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.CollPathReply.path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::PathData>& CollPathReply::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.CollPathReply.path)
  return _internal_path();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::PathData>&
CollPathReply::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::PathData>*
CollPathReply::_internal_mutable_path() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// CollGetOffsetRequest

// required string id = 1;
inline bool CollGetOffsetRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollGetOffsetRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollGetOffsetRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollGetOffsetRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollGetOffsetRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollGetOffsetRequest.id)
}
inline std::string* CollGetOffsetRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollGetOffsetRequest.id)
  return _s;
}
inline const std::string& CollGetOffsetRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CollGetOffsetRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CollGetOffsetRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CollGetOffsetRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollGetOffsetRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollGetOffsetRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollGetOffsetRequest.id)
}

// required string item = 2;
inline bool CollGetOffsetRequest::has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollGetOffsetRequest::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CollGetOffsetRequest::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollGetOffsetRequest.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollGetOffsetRequest::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollGetOffsetRequest.item)
}
inline std::string* CollGetOffsetRequest::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollGetOffsetRequest.item)
  return _s;
}
inline const std::string& CollGetOffsetRequest::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void CollGetOffsetRequest::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* CollGetOffsetRequest::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* CollGetOffsetRequest::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollGetOffsetRequest.item)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.item_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.item_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollGetOffsetRequest::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollGetOffsetRequest.item)
}

// required uint32 page_sz = 3;
inline bool CollGetOffsetRequest::has_page_sz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CollGetOffsetRequest::clear_page_sz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_sz_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t CollGetOffsetRequest::page_sz() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollGetOffsetRequest.page_sz)
  return _internal_page_sz();
}
inline void CollGetOffsetRequest::set_page_sz(::uint32_t value) {
  _internal_set_page_sz(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollGetOffsetRequest.page_sz)
}
inline ::uint32_t CollGetOffsetRequest::_internal_page_sz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_sz_;
}
inline void CollGetOffsetRequest::_internal_set_page_sz(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.page_sz_ = value;
}

// -------------------------------------------------------------------

// CollGetOffsetReply

// required string id = 1;
inline bool CollGetOffsetReply::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollGetOffsetReply::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollGetOffsetReply::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollGetOffsetReply.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollGetOffsetReply::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollGetOffsetReply.id)
}
inline std::string* CollGetOffsetReply::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollGetOffsetReply.id)
  return _s;
}
inline const std::string& CollGetOffsetReply::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CollGetOffsetReply::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CollGetOffsetReply::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CollGetOffsetReply::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollGetOffsetReply.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollGetOffsetReply::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollGetOffsetReply.id)
}

// required string item = 2;
inline bool CollGetOffsetReply::has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollGetOffsetReply::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CollGetOffsetReply::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollGetOffsetReply.item)
  return _internal_item();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollGetOffsetReply::set_item(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.item_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollGetOffsetReply.item)
}
inline std::string* CollGetOffsetReply::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollGetOffsetReply.item)
  return _s;
}
inline const std::string& CollGetOffsetReply::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_.Get();
}
inline void CollGetOffsetReply::_internal_set_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.item_.Set(value, GetArena());
}
inline std::string* CollGetOffsetReply::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.item_.Mutable( GetArena());
}
inline std::string* CollGetOffsetReply::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollGetOffsetReply.item)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.item_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.item_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollGetOffsetReply::set_allocated_item(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.item_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_.IsDefault()) {
          _impl_.item_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollGetOffsetReply.item)
}

// required uint32 offset = 3;
inline bool CollGetOffsetReply::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CollGetOffsetReply::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t CollGetOffsetReply::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollGetOffsetReply.offset)
  return _internal_offset();
}
inline void CollGetOffsetReply::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollGetOffsetReply.offset)
}
inline ::uint32_t CollGetOffsetReply::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void CollGetOffsetReply::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// CollListPublishedRequest

// optional string subject = 1;
inline bool CollListPublishedRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollListPublishedRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollListPublishedRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollListPublishedRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollListPublishedRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollListPublishedRequest.subject)
}
inline std::string* CollListPublishedRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.CollListPublishedRequest.subject)
  return _s;
}
inline const std::string& CollListPublishedRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void CollListPublishedRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* CollListPublishedRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* CollListPublishedRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.CollListPublishedRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollListPublishedRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.CollListPublishedRequest.subject)
}

// optional uint32 offset = 2;
inline bool CollListPublishedRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollListPublishedRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t CollListPublishedRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollListPublishedRequest.offset)
  return _internal_offset();
}
inline void CollListPublishedRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollListPublishedRequest.offset)
}
inline ::uint32_t CollListPublishedRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void CollListPublishedRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool CollListPublishedRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CollListPublishedRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t CollListPublishedRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.CollListPublishedRequest.count)
  return _internal_count();
}
inline void CollListPublishedRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.CollListPublishedRequest.count)
}
inline ::uint32_t CollListPublishedRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void CollListPublishedRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// GroupCreateRequest

// required .SDMS.GroupData group = 1;
inline bool GroupCreateRequest::has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
  return value;
}
inline const ::SDMS::GroupData& GroupCreateRequest::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::GroupData* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::GroupData&>(::SDMS::_GroupData_default_instance_);
}
inline const ::SDMS::GroupData& GroupCreateRequest::group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupCreateRequest.group)
  return _internal_group();
}
inline void GroupCreateRequest::unsafe_arena_set_allocated_group(::SDMS::GroupData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = reinterpret_cast<::SDMS::GroupData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.GroupCreateRequest.group)
}
inline ::SDMS::GroupData* GroupCreateRequest::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::GroupData* released = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::GroupData* GroupCreateRequest::unsafe_arena_release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupCreateRequest.group)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::GroupData* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::SDMS::GroupData* GroupCreateRequest::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::GroupData>(GetArena());
    _impl_.group_ = reinterpret_cast<::SDMS::GroupData*>(p);
  }
  return _impl_.group_;
}
inline ::SDMS::GroupData* GroupCreateRequest::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::GroupData* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupCreateRequest.group)
  return _msg;
}
inline void GroupCreateRequest::set_allocated_group(::SDMS::GroupData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.group_ = reinterpret_cast<::SDMS::GroupData*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupCreateRequest.group)
}

// -------------------------------------------------------------------

// GroupUpdateRequest

// required string uid = 1;
inline bool GroupUpdateRequest::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GroupUpdateRequest::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupUpdateRequest::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupUpdateRequest.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupUpdateRequest::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupUpdateRequest.uid)
}
inline std::string* GroupUpdateRequest::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupUpdateRequest.uid)
  return _s;
}
inline const std::string& GroupUpdateRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void GroupUpdateRequest::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* GroupUpdateRequest::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* GroupUpdateRequest::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupUpdateRequest.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupUpdateRequest::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupUpdateRequest.uid)
}

// required string gid = 2;
inline bool GroupUpdateRequest::has_gid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GroupUpdateRequest::clear_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupUpdateRequest::gid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupUpdateRequest.gid)
  return _internal_gid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupUpdateRequest::set_gid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupUpdateRequest.gid)
}
inline std::string* GroupUpdateRequest::mutable_gid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupUpdateRequest.gid)
  return _s;
}
inline const std::string& GroupUpdateRequest::_internal_gid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gid_.Get();
}
inline void GroupUpdateRequest::_internal_set_gid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gid_.Set(value, GetArena());
}
inline std::string* GroupUpdateRequest::_internal_mutable_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.gid_.Mutable( GetArena());
}
inline std::string* GroupUpdateRequest::release_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupUpdateRequest.gid)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.gid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupUpdateRequest::set_allocated_gid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.gid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gid_.IsDefault()) {
          _impl_.gid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupUpdateRequest.gid)
}

// optional string title = 3;
inline bool GroupUpdateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GroupUpdateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GroupUpdateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupUpdateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupUpdateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupUpdateRequest.title)
}
inline std::string* GroupUpdateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupUpdateRequest.title)
  return _s;
}
inline const std::string& GroupUpdateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void GroupUpdateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* GroupUpdateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* GroupUpdateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupUpdateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupUpdateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupUpdateRequest.title)
}

// optional string desc = 4;
inline bool GroupUpdateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GroupUpdateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GroupUpdateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupUpdateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupUpdateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupUpdateRequest.desc)
}
inline std::string* GroupUpdateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupUpdateRequest.desc)
  return _s;
}
inline const std::string& GroupUpdateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void GroupUpdateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* GroupUpdateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* GroupUpdateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupUpdateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupUpdateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupUpdateRequest.desc)
}

// repeated string add_uid = 5;
inline int GroupUpdateRequest::_internal_add_uid_size() const {
  return _internal_add_uid().size();
}
inline int GroupUpdateRequest::add_uid_size() const {
  return _internal_add_uid_size();
}
inline void GroupUpdateRequest::clear_add_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_uid_.Clear();
}
inline std::string* GroupUpdateRequest::add_add_uid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_add_uid()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.GroupUpdateRequest.add_uid)
  return _s;
}
inline const std::string& GroupUpdateRequest::add_uid(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupUpdateRequest.add_uid)
  return _internal_add_uid().Get(index);
}
inline std::string* GroupUpdateRequest::mutable_add_uid(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupUpdateRequest.add_uid)
  return _internal_mutable_add_uid()->Mutable(index);
}
inline void GroupUpdateRequest::set_add_uid(int index, const std::string& value) {
  _internal_mutable_add_uid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::set_add_uid(int index, std::string&& value) {
  _internal_mutable_add_uid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::set_add_uid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_add_uid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::set_add_uid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_add_uid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::set_add_uid(int index, absl::string_view value) {
  _internal_mutable_add_uid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::add_add_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add_uid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::add_add_uid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add_uid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::add_add_uid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add_uid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::add_add_uid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add_uid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline void GroupUpdateRequest::add_add_uid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_add_uid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.GroupUpdateRequest.add_uid)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GroupUpdateRequest::add_uid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.GroupUpdateRequest.add_uid)
  return _internal_add_uid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GroupUpdateRequest::mutable_add_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.GroupUpdateRequest.add_uid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_add_uid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GroupUpdateRequest::_internal_add_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_uid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GroupUpdateRequest::_internal_mutable_add_uid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.add_uid_;
}

// repeated string rem_uid = 6;
inline int GroupUpdateRequest::_internal_rem_uid_size() const {
  return _internal_rem_uid().size();
}
inline int GroupUpdateRequest::rem_uid_size() const {
  return _internal_rem_uid_size();
}
inline void GroupUpdateRequest::clear_rem_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rem_uid_.Clear();
}
inline std::string* GroupUpdateRequest::add_rem_uid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_rem_uid()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.GroupUpdateRequest.rem_uid)
  return _s;
}
inline const std::string& GroupUpdateRequest::rem_uid(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupUpdateRequest.rem_uid)
  return _internal_rem_uid().Get(index);
}
inline std::string* GroupUpdateRequest::mutable_rem_uid(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupUpdateRequest.rem_uid)
  return _internal_mutable_rem_uid()->Mutable(index);
}
inline void GroupUpdateRequest::set_rem_uid(int index, const std::string& value) {
  _internal_mutable_rem_uid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::set_rem_uid(int index, std::string&& value) {
  _internal_mutable_rem_uid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::set_rem_uid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_rem_uid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::set_rem_uid(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_rem_uid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::set_rem_uid(int index, absl::string_view value) {
  _internal_mutable_rem_uid()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::add_rem_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem_uid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::add_rem_uid(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem_uid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::add_rem_uid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem_uid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::add_rem_uid(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem_uid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline void GroupUpdateRequest::add_rem_uid(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_rem_uid()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.GroupUpdateRequest.rem_uid)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GroupUpdateRequest::rem_uid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.GroupUpdateRequest.rem_uid)
  return _internal_rem_uid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GroupUpdateRequest::mutable_rem_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.GroupUpdateRequest.rem_uid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rem_uid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GroupUpdateRequest::_internal_rem_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rem_uid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GroupUpdateRequest::_internal_mutable_rem_uid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rem_uid_;
}

// -------------------------------------------------------------------

// GroupDataReply

// repeated .SDMS.GroupData group = 1;
inline int GroupDataReply::_internal_group_size() const {
  return _internal_group().size();
}
inline int GroupDataReply::group_size() const {
  return _internal_group_size();
}
inline ::SDMS::GroupData* GroupDataReply::mutable_group(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupDataReply.group)
  return _internal_mutable_group()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::GroupData>* GroupDataReply::mutable_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.GroupDataReply.group)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_group();
}
inline const ::SDMS::GroupData& GroupDataReply::group(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupDataReply.group)
  return _internal_group().Get(index);
}
inline ::SDMS::GroupData* GroupDataReply::add_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::GroupData* _add = _internal_mutable_group()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.GroupDataReply.group)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::GroupData>& GroupDataReply::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.GroupDataReply.group)
  return _internal_group();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::GroupData>&
GroupDataReply::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::GroupData>*
GroupDataReply::_internal_mutable_group() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.group_;
}

// -------------------------------------------------------------------

// GroupDeleteRequest

// required string uid = 1;
inline bool GroupDeleteRequest::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GroupDeleteRequest::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupDeleteRequest::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupDeleteRequest.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupDeleteRequest::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupDeleteRequest.uid)
}
inline std::string* GroupDeleteRequest::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupDeleteRequest.uid)
  return _s;
}
inline const std::string& GroupDeleteRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void GroupDeleteRequest::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* GroupDeleteRequest::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* GroupDeleteRequest::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupDeleteRequest.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupDeleteRequest::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupDeleteRequest.uid)
}

// required string gid = 2;
inline bool GroupDeleteRequest::has_gid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GroupDeleteRequest::clear_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupDeleteRequest::gid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupDeleteRequest.gid)
  return _internal_gid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupDeleteRequest::set_gid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupDeleteRequest.gid)
}
inline std::string* GroupDeleteRequest::mutable_gid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupDeleteRequest.gid)
  return _s;
}
inline const std::string& GroupDeleteRequest::_internal_gid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gid_.Get();
}
inline void GroupDeleteRequest::_internal_set_gid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gid_.Set(value, GetArena());
}
inline std::string* GroupDeleteRequest::_internal_mutable_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.gid_.Mutable( GetArena());
}
inline std::string* GroupDeleteRequest::release_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupDeleteRequest.gid)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.gid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupDeleteRequest::set_allocated_gid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.gid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gid_.IsDefault()) {
          _impl_.gid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupDeleteRequest.gid)
}

// -------------------------------------------------------------------

// GroupListRequest

// required string uid = 1;
inline bool GroupListRequest::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GroupListRequest::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupListRequest::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupListRequest.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupListRequest::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupListRequest.uid)
}
inline std::string* GroupListRequest::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupListRequest.uid)
  return _s;
}
inline const std::string& GroupListRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void GroupListRequest::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* GroupListRequest::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* GroupListRequest::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupListRequest.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupListRequest::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupListRequest.uid)
}

// -------------------------------------------------------------------

// GroupViewRequest

// required string uid = 1;
inline bool GroupViewRequest::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GroupViewRequest::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupViewRequest::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupViewRequest.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupViewRequest::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupViewRequest.uid)
}
inline std::string* GroupViewRequest::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupViewRequest.uid)
  return _s;
}
inline const std::string& GroupViewRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void GroupViewRequest::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* GroupViewRequest::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* GroupViewRequest::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupViewRequest.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupViewRequest::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupViewRequest.uid)
}

// required string gid = 2;
inline bool GroupViewRequest::has_gid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GroupViewRequest::clear_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupViewRequest::gid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.GroupViewRequest.gid)
  return _internal_gid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupViewRequest::set_gid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.GroupViewRequest.gid)
}
inline std::string* GroupViewRequest::mutable_gid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gid();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.GroupViewRequest.gid)
  return _s;
}
inline const std::string& GroupViewRequest::_internal_gid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gid_.Get();
}
inline void GroupViewRequest::_internal_set_gid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gid_.Set(value, GetArena());
}
inline std::string* GroupViewRequest::_internal_mutable_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.gid_.Mutable( GetArena());
}
inline std::string* GroupViewRequest::release_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.GroupViewRequest.gid)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.gid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupViewRequest::set_allocated_gid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.gid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gid_.IsDefault()) {
          _impl_.gid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.GroupViewRequest.gid)
}

// -------------------------------------------------------------------

// ACLViewRequest

// required string id = 1;
inline bool ACLViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ACLViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ACLViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ACLViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ACLViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ACLViewRequest.id)
}
inline std::string* ACLViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ACLViewRequest.id)
  return _s;
}
inline const std::string& ACLViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ACLViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ACLViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ACLViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ACLViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ACLViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ACLViewRequest.id)
}

// -------------------------------------------------------------------

// ACLUpdateRequest

// required string id = 1;
inline bool ACLUpdateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ACLUpdateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ACLUpdateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ACLUpdateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ACLUpdateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ACLUpdateRequest.id)
}
inline std::string* ACLUpdateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ACLUpdateRequest.id)
  return _s;
}
inline const std::string& ACLUpdateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ACLUpdateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ACLUpdateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ACLUpdateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ACLUpdateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ACLUpdateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ACLUpdateRequest.id)
}

// optional string rules = 2;
inline bool ACLUpdateRequest::has_rules() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ACLUpdateRequest::clear_rules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rules_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ACLUpdateRequest::rules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ACLUpdateRequest.rules)
  return _internal_rules();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ACLUpdateRequest::set_rules(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rules_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ACLUpdateRequest.rules)
}
inline std::string* ACLUpdateRequest::mutable_rules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rules();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ACLUpdateRequest.rules)
  return _s;
}
inline const std::string& ACLUpdateRequest::_internal_rules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rules_.Get();
}
inline void ACLUpdateRequest::_internal_set_rules(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rules_.Set(value, GetArena());
}
inline std::string* ACLUpdateRequest::_internal_mutable_rules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.rules_.Mutable( GetArena());
}
inline std::string* ACLUpdateRequest::release_rules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ACLUpdateRequest.rules)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.rules_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rules_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ACLUpdateRequest::set_allocated_rules(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rules_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rules_.IsDefault()) {
          _impl_.rules_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ACLUpdateRequest.rules)
}

// -------------------------------------------------------------------

// ACLSharedListRequest

// optional bool inc_users = 2;
inline bool ACLSharedListRequest::has_inc_users() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ACLSharedListRequest::clear_inc_users() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inc_users_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ACLSharedListRequest::inc_users() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ACLSharedListRequest.inc_users)
  return _internal_inc_users();
}
inline void ACLSharedListRequest::set_inc_users(bool value) {
  _internal_set_inc_users(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ACLSharedListRequest.inc_users)
}
inline bool ACLSharedListRequest::_internal_inc_users() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inc_users_;
}
inline void ACLSharedListRequest::_internal_set_inc_users(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.inc_users_ = value;
}

// optional bool inc_projects = 3;
inline bool ACLSharedListRequest::has_inc_projects() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ACLSharedListRequest::clear_inc_projects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inc_projects_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ACLSharedListRequest::inc_projects() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ACLSharedListRequest.inc_projects)
  return _internal_inc_projects();
}
inline void ACLSharedListRequest::set_inc_projects(bool value) {
  _internal_set_inc_projects(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ACLSharedListRequest.inc_projects)
}
inline bool ACLSharedListRequest::_internal_inc_projects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inc_projects_;
}
inline void ACLSharedListRequest::_internal_set_inc_projects(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.inc_projects_ = value;
}

// -------------------------------------------------------------------

// ACLSharedListItemsRequest

// required string owner = 2;
inline bool ACLSharedListItemsRequest::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ACLSharedListItemsRequest::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ACLSharedListItemsRequest::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ACLSharedListItemsRequest.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ACLSharedListItemsRequest::set_owner(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ACLSharedListItemsRequest.owner)
}
inline std::string* ACLSharedListItemsRequest::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ACLSharedListItemsRequest.owner)
  return _s;
}
inline const std::string& ACLSharedListItemsRequest::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_.Get();
}
inline void ACLSharedListItemsRequest::_internal_set_owner(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.owner_.Set(value, GetArena());
}
inline std::string* ACLSharedListItemsRequest::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.owner_.Mutable( GetArena());
}
inline std::string* ACLSharedListItemsRequest::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ACLSharedListItemsRequest.owner)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ACLSharedListItemsRequest::set_allocated_owner(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ACLSharedListItemsRequest.owner)
}

// -------------------------------------------------------------------

// ACLDataReply

// repeated .SDMS.ACLRule rule = 1;
inline int ACLDataReply::_internal_rule_size() const {
  return _internal_rule().size();
}
inline int ACLDataReply::rule_size() const {
  return _internal_rule_size();
}
inline ::SDMS::ACLRule* ACLDataReply::mutable_rule(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ACLDataReply.rule)
  return _internal_mutable_rule()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ACLRule>* ACLDataReply::mutable_rule()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ACLDataReply.rule)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rule();
}
inline const ::SDMS::ACLRule& ACLDataReply::rule(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ACLDataReply.rule)
  return _internal_rule().Get(index);
}
inline ::SDMS::ACLRule* ACLDataReply::add_rule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::ACLRule* _add = _internal_mutable_rule()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.ACLDataReply.rule)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ACLRule>& ACLDataReply::rule() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ACLDataReply.rule)
  return _internal_rule();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ACLRule>&
ACLDataReply::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ACLRule>*
ACLDataReply::_internal_mutable_rule() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rule_;
}

// -------------------------------------------------------------------

// ProjectViewRequest

// required string id = 1;
inline bool ProjectViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProjectViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectViewRequest.id)
}
inline std::string* ProjectViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectViewRequest.id)
  return _s;
}
inline const std::string& ProjectViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ProjectViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ProjectViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ProjectViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectViewRequest.id)
}

// -------------------------------------------------------------------

// ProjectDataReply

// repeated .SDMS.ProjectData proj = 1;
inline int ProjectDataReply::_internal_proj_size() const {
  return _internal_proj().size();
}
inline int ProjectDataReply::proj_size() const {
  return _internal_proj_size();
}
inline ::SDMS::ProjectData* ProjectDataReply::mutable_proj(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectDataReply.proj)
  return _internal_mutable_proj()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ProjectData>* ProjectDataReply::mutable_proj()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ProjectDataReply.proj)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_proj();
}
inline const ::SDMS::ProjectData& ProjectDataReply::proj(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectDataReply.proj)
  return _internal_proj().Get(index);
}
inline ::SDMS::ProjectData* ProjectDataReply::add_proj() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::ProjectData* _add = _internal_mutable_proj()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectDataReply.proj)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ProjectData>& ProjectDataReply::proj() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ProjectDataReply.proj)
  return _internal_proj();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ProjectData>&
ProjectDataReply::_internal_proj() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proj_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ProjectData>*
ProjectDataReply::_internal_mutable_proj() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.proj_;
}

// -------------------------------------------------------------------

// ProjectCreateRequest

// required string id = 1;
inline bool ProjectCreateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProjectCreateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectCreateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectCreateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectCreateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectCreateRequest.id)
}
inline std::string* ProjectCreateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectCreateRequest.id)
  return _s;
}
inline const std::string& ProjectCreateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ProjectCreateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ProjectCreateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ProjectCreateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectCreateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectCreateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectCreateRequest.id)
}

// optional string title = 2;
inline bool ProjectCreateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ProjectCreateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProjectCreateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectCreateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectCreateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectCreateRequest.title)
}
inline std::string* ProjectCreateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectCreateRequest.title)
  return _s;
}
inline const std::string& ProjectCreateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void ProjectCreateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* ProjectCreateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* ProjectCreateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectCreateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectCreateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectCreateRequest.title)
}

// optional string desc = 3;
inline bool ProjectCreateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ProjectCreateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProjectCreateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectCreateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectCreateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectCreateRequest.desc)
}
inline std::string* ProjectCreateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectCreateRequest.desc)
  return _s;
}
inline const std::string& ProjectCreateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void ProjectCreateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* ProjectCreateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* ProjectCreateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectCreateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectCreateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectCreateRequest.desc)
}

// repeated string admin = 4;
inline int ProjectCreateRequest::_internal_admin_size() const {
  return _internal_admin().size();
}
inline int ProjectCreateRequest::admin_size() const {
  return _internal_admin_size();
}
inline void ProjectCreateRequest::clear_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_.Clear();
}
inline std::string* ProjectCreateRequest::add_admin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_admin()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.ProjectCreateRequest.admin)
  return _s;
}
inline const std::string& ProjectCreateRequest::admin(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectCreateRequest.admin)
  return _internal_admin().Get(index);
}
inline std::string* ProjectCreateRequest::mutable_admin(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectCreateRequest.admin)
  return _internal_mutable_admin()->Mutable(index);
}
inline void ProjectCreateRequest::set_admin(int index, const std::string& value) {
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::set_admin(int index, std::string&& value) {
  _internal_mutable_admin()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::set_admin(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::set_admin(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_admin()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::set_admin(int index, absl::string_view value) {
  _internal_mutable_admin()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::add_admin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::add_admin(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::add_admin(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::add_admin(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.ProjectCreateRequest.admin)
}
inline void ProjectCreateRequest::add_admin(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.ProjectCreateRequest.admin)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectCreateRequest::admin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ProjectCreateRequest.admin)
  return _internal_admin();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectCreateRequest::mutable_admin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ProjectCreateRequest.admin)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_admin();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectCreateRequest::_internal_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectCreateRequest::_internal_mutable_admin() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.admin_;
}

// repeated string member = 5;
inline int ProjectCreateRequest::_internal_member_size() const {
  return _internal_member().size();
}
inline int ProjectCreateRequest::member_size() const {
  return _internal_member_size();
}
inline void ProjectCreateRequest::clear_member() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.member_.Clear();
}
inline std::string* ProjectCreateRequest::add_member()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_member()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.ProjectCreateRequest.member)
  return _s;
}
inline const std::string& ProjectCreateRequest::member(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectCreateRequest.member)
  return _internal_member().Get(index);
}
inline std::string* ProjectCreateRequest::mutable_member(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectCreateRequest.member)
  return _internal_mutable_member()->Mutable(index);
}
inline void ProjectCreateRequest::set_member(int index, const std::string& value) {
  _internal_mutable_member()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::set_member(int index, std::string&& value) {
  _internal_mutable_member()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::set_member(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_member()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::set_member(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_member()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::set_member(int index, absl::string_view value) {
  _internal_mutable_member()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::add_member(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::add_member(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::add_member(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::add_member(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.ProjectCreateRequest.member)
}
inline void ProjectCreateRequest::add_member(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.ProjectCreateRequest.member)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectCreateRequest::member() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ProjectCreateRequest.member)
  return _internal_member();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectCreateRequest::mutable_member() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ProjectCreateRequest.member)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_member();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectCreateRequest::_internal_member() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.member_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectCreateRequest::_internal_mutable_member() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.member_;
}

// -------------------------------------------------------------------

// ProjectUpdateRequest

// required string id = 1;
inline bool ProjectUpdateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProjectUpdateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectUpdateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectUpdateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectUpdateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.id)
}
inline std::string* ProjectUpdateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectUpdateRequest.id)
  return _s;
}
inline const std::string& ProjectUpdateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ProjectUpdateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ProjectUpdateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ProjectUpdateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectUpdateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectUpdateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectUpdateRequest.id)
}

// optional string title = 2;
inline bool ProjectUpdateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ProjectUpdateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProjectUpdateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectUpdateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectUpdateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.title)
}
inline std::string* ProjectUpdateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectUpdateRequest.title)
  return _s;
}
inline const std::string& ProjectUpdateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void ProjectUpdateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* ProjectUpdateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* ProjectUpdateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectUpdateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectUpdateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectUpdateRequest.title)
}

// optional string desc = 3;
inline bool ProjectUpdateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ProjectUpdateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProjectUpdateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectUpdateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectUpdateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.desc)
}
inline std::string* ProjectUpdateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectUpdateRequest.desc)
  return _s;
}
inline const std::string& ProjectUpdateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void ProjectUpdateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* ProjectUpdateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* ProjectUpdateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectUpdateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectUpdateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectUpdateRequest.desc)
}

// optional bool admin_set = 4 [default = false];
inline bool ProjectUpdateRequest::has_admin_set() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ProjectUpdateRequest::clear_admin_set() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_set_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ProjectUpdateRequest::admin_set() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectUpdateRequest.admin_set)
  return _internal_admin_set();
}
inline void ProjectUpdateRequest::set_admin_set(bool value) {
  _internal_set_admin_set(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.admin_set)
}
inline bool ProjectUpdateRequest::_internal_admin_set() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_set_;
}
inline void ProjectUpdateRequest::_internal_set_admin_set(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.admin_set_ = value;
}

// repeated string admin = 5;
inline int ProjectUpdateRequest::_internal_admin_size() const {
  return _internal_admin().size();
}
inline int ProjectUpdateRequest::admin_size() const {
  return _internal_admin_size();
}
inline void ProjectUpdateRequest::clear_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_.Clear();
}
inline std::string* ProjectUpdateRequest::add_admin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_admin()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.ProjectUpdateRequest.admin)
  return _s;
}
inline const std::string& ProjectUpdateRequest::admin(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectUpdateRequest.admin)
  return _internal_admin().Get(index);
}
inline std::string* ProjectUpdateRequest::mutable_admin(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectUpdateRequest.admin)
  return _internal_mutable_admin()->Mutable(index);
}
inline void ProjectUpdateRequest::set_admin(int index, const std::string& value) {
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::set_admin(int index, std::string&& value) {
  _internal_mutable_admin()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::set_admin(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::set_admin(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_admin()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::set_admin(int index, absl::string_view value) {
  _internal_mutable_admin()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::add_admin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::add_admin(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::add_admin(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::add_admin(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline void ProjectUpdateRequest::add_admin(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.ProjectUpdateRequest.admin)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectUpdateRequest::admin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ProjectUpdateRequest.admin)
  return _internal_admin();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectUpdateRequest::mutable_admin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ProjectUpdateRequest.admin)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_admin();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectUpdateRequest::_internal_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectUpdateRequest::_internal_mutable_admin() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.admin_;
}

// optional bool member_set = 6 [default = false];
inline bool ProjectUpdateRequest::has_member_set() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ProjectUpdateRequest::clear_member_set() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.member_set_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ProjectUpdateRequest::member_set() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectUpdateRequest.member_set)
  return _internal_member_set();
}
inline void ProjectUpdateRequest::set_member_set(bool value) {
  _internal_set_member_set(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.member_set)
}
inline bool ProjectUpdateRequest::_internal_member_set() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.member_set_;
}
inline void ProjectUpdateRequest::_internal_set_member_set(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.member_set_ = value;
}

// repeated string member = 7;
inline int ProjectUpdateRequest::_internal_member_size() const {
  return _internal_member().size();
}
inline int ProjectUpdateRequest::member_size() const {
  return _internal_member_size();
}
inline void ProjectUpdateRequest::clear_member() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.member_.Clear();
}
inline std::string* ProjectUpdateRequest::add_member()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_member()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.ProjectUpdateRequest.member)
  return _s;
}
inline const std::string& ProjectUpdateRequest::member(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectUpdateRequest.member)
  return _internal_member().Get(index);
}
inline std::string* ProjectUpdateRequest::mutable_member(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectUpdateRequest.member)
  return _internal_mutable_member()->Mutable(index);
}
inline void ProjectUpdateRequest::set_member(int index, const std::string& value) {
  _internal_mutable_member()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::set_member(int index, std::string&& value) {
  _internal_mutable_member()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::set_member(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_member()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::set_member(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_member()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::set_member(int index, absl::string_view value) {
  _internal_mutable_member()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::add_member(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::add_member(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::add_member(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::add_member(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.ProjectUpdateRequest.member)
}
inline void ProjectUpdateRequest::add_member(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.ProjectUpdateRequest.member)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectUpdateRequest::member() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ProjectUpdateRequest.member)
  return _internal_member();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectUpdateRequest::mutable_member() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ProjectUpdateRequest.member)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_member();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectUpdateRequest::_internal_member() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.member_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectUpdateRequest::_internal_mutable_member() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.member_;
}

// -------------------------------------------------------------------

// ProjectDeleteRequest

// repeated string id = 1;
inline int ProjectDeleteRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int ProjectDeleteRequest::id_size() const {
  return _internal_id_size();
}
inline void ProjectDeleteRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* ProjectDeleteRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.ProjectDeleteRequest.id)
  return _s;
}
inline const std::string& ProjectDeleteRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectDeleteRequest.id)
  return _internal_id().Get(index);
}
inline std::string* ProjectDeleteRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectDeleteRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void ProjectDeleteRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.ProjectDeleteRequest.id)
}
inline void ProjectDeleteRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.ProjectDeleteRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectDeleteRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ProjectDeleteRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectDeleteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ProjectDeleteRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectDeleteRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectDeleteRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// ProjectListRequest

// optional string subject = 1;
inline bool ProjectListRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProjectListRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectListRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectListRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectListRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectListRequest.subject)
}
inline std::string* ProjectListRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectListRequest.subject)
  return _s;
}
inline const std::string& ProjectListRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void ProjectListRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* ProjectListRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* ProjectListRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectListRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectListRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectListRequest.subject)
}

// optional bool as_owner = 2;
inline bool ProjectListRequest::has_as_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ProjectListRequest::clear_as_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.as_owner_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ProjectListRequest::as_owner() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectListRequest.as_owner)
  return _internal_as_owner();
}
inline void ProjectListRequest::set_as_owner(bool value) {
  _internal_set_as_owner(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectListRequest.as_owner)
}
inline bool ProjectListRequest::_internal_as_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.as_owner_;
}
inline void ProjectListRequest::_internal_set_as_owner(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.as_owner_ = value;
}

// optional bool as_admin = 3;
inline bool ProjectListRequest::has_as_admin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ProjectListRequest::clear_as_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.as_admin_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ProjectListRequest::as_admin() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectListRequest.as_admin)
  return _internal_as_admin();
}
inline void ProjectListRequest::set_as_admin(bool value) {
  _internal_set_as_admin(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectListRequest.as_admin)
}
inline bool ProjectListRequest::_internal_as_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.as_admin_;
}
inline void ProjectListRequest::_internal_set_as_admin(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.as_admin_ = value;
}

// optional bool as_member = 4;
inline bool ProjectListRequest::has_as_member() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ProjectListRequest::clear_as_member() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.as_member_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ProjectListRequest::as_member() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectListRequest.as_member)
  return _internal_as_member();
}
inline void ProjectListRequest::set_as_member(bool value) {
  _internal_set_as_member(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectListRequest.as_member)
}
inline bool ProjectListRequest::_internal_as_member() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.as_member_;
}
inline void ProjectListRequest::_internal_set_as_member(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.as_member_ = value;
}

// optional .SDMS.SortOption sort = 5;
inline bool ProjectListRequest::has_sort() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ProjectListRequest::clear_sort() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sort_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::SDMS::SortOption ProjectListRequest::sort() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectListRequest.sort)
  return _internal_sort();
}
inline void ProjectListRequest::set_sort(::SDMS::SortOption value) {
  _internal_set_sort(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectListRequest.sort)
}
inline ::SDMS::SortOption ProjectListRequest::_internal_sort() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::SortOption>(_impl_.sort_);
}
inline void ProjectListRequest::_internal_set_sort(::SDMS::SortOption value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::SortOption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sort_ = value;
}

// optional bool sort_rev = 6;
inline bool ProjectListRequest::has_sort_rev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ProjectListRequest::clear_sort_rev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sort_rev_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ProjectListRequest::sort_rev() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectListRequest.sort_rev)
  return _internal_sort_rev();
}
inline void ProjectListRequest::set_sort_rev(bool value) {
  _internal_set_sort_rev(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectListRequest.sort_rev)
}
inline bool ProjectListRequest::_internal_sort_rev() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sort_rev_;
}
inline void ProjectListRequest::_internal_set_sort_rev(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sort_rev_ = value;
}

// optional uint32 offset = 7;
inline bool ProjectListRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ProjectListRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t ProjectListRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectListRequest.offset)
  return _internal_offset();
}
inline void ProjectListRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectListRequest.offset)
}
inline ::uint32_t ProjectListRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void ProjectListRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.offset_ = value;
}

// optional uint32 count = 8;
inline bool ProjectListRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ProjectListRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t ProjectListRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectListRequest.count)
  return _internal_count();
}
inline void ProjectListRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectListRequest.count)
}
inline ::uint32_t ProjectListRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void ProjectListRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// ProjectSearchRequest

// required string text_query = 1;
inline bool ProjectSearchRequest::has_text_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProjectSearchRequest::clear_text_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectSearchRequest::text_query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectSearchRequest.text_query)
  return _internal_text_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectSearchRequest::set_text_query(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_query_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectSearchRequest.text_query)
}
inline std::string* ProjectSearchRequest::mutable_text_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text_query();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectSearchRequest.text_query)
  return _s;
}
inline const std::string& ProjectSearchRequest::_internal_text_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_query_.Get();
}
inline void ProjectSearchRequest::_internal_set_text_query(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_query_.Set(value, GetArena());
}
inline std::string* ProjectSearchRequest::_internal_mutable_text_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_query_.Mutable( GetArena());
}
inline std::string* ProjectSearchRequest::release_text_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectSearchRequest.text_query)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_query_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_query_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectSearchRequest::set_allocated_text_query(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_query_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_query_.IsDefault()) {
          _impl_.text_query_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectSearchRequest.text_query)
}

// repeated string scope = 2;
inline int ProjectSearchRequest::_internal_scope_size() const {
  return _internal_scope().size();
}
inline int ProjectSearchRequest::scope_size() const {
  return _internal_scope_size();
}
inline void ProjectSearchRequest::clear_scope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scope_.Clear();
}
inline std::string* ProjectSearchRequest::add_scope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_scope()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.ProjectSearchRequest.scope)
  return _s;
}
inline const std::string& ProjectSearchRequest::scope(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectSearchRequest.scope)
  return _internal_scope().Get(index);
}
inline std::string* ProjectSearchRequest::mutable_scope(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectSearchRequest.scope)
  return _internal_mutable_scope()->Mutable(index);
}
inline void ProjectSearchRequest::set_scope(int index, const std::string& value) {
  _internal_mutable_scope()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::set_scope(int index, std::string&& value) {
  _internal_mutable_scope()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::set_scope(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_scope()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::set_scope(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_scope()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::set_scope(int index, absl::string_view value) {
  _internal_mutable_scope()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::add_scope(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_scope()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::add_scope(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_scope()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::add_scope(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_scope()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::add_scope(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_scope()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.ProjectSearchRequest.scope)
}
inline void ProjectSearchRequest::add_scope(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_scope()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.ProjectSearchRequest.scope)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectSearchRequest::scope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.ProjectSearchRequest.scope)
  return _internal_scope();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectSearchRequest::mutable_scope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.ProjectSearchRequest.scope)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scope();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectSearchRequest::_internal_scope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scope_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectSearchRequest::_internal_mutable_scope() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scope_;
}

// -------------------------------------------------------------------

// ProjectGetRoleRequest

// required string id = 1;
inline bool ProjectGetRoleRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProjectGetRoleRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectGetRoleRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectGetRoleRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectGetRoleRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectGetRoleRequest.id)
}
inline std::string* ProjectGetRoleRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectGetRoleRequest.id)
  return _s;
}
inline const std::string& ProjectGetRoleRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ProjectGetRoleRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ProjectGetRoleRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ProjectGetRoleRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectGetRoleRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectGetRoleRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectGetRoleRequest.id)
}

// optional string subject = 2;
inline bool ProjectGetRoleRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ProjectGetRoleRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProjectGetRoleRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectGetRoleRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectGetRoleRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectGetRoleRequest.subject)
}
inline std::string* ProjectGetRoleRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.ProjectGetRoleRequest.subject)
  return _s;
}
inline const std::string& ProjectGetRoleRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void ProjectGetRoleRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* ProjectGetRoleRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* ProjectGetRoleRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.ProjectGetRoleRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectGetRoleRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.ProjectGetRoleRequest.subject)
}

// -------------------------------------------------------------------

// ProjectGetRoleReply

// required .SDMS.ProjectRole role = 1;
inline bool ProjectGetRoleReply::has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProjectGetRoleReply::clear_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SDMS::ProjectRole ProjectGetRoleReply::role() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.ProjectGetRoleReply.role)
  return _internal_role();
}
inline void ProjectGetRoleReply::set_role(::SDMS::ProjectRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.ProjectGetRoleReply.role)
}
inline ::SDMS::ProjectRole ProjectGetRoleReply::_internal_role() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::ProjectRole>(_impl_.role_);
}
inline void ProjectGetRoleReply::_internal_set_role(::SDMS::ProjectRole value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::ProjectRole_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.role_ = value;
}

// -------------------------------------------------------------------

// RepoDataDeleteRequest

// repeated .SDMS.RecordDataLocation loc = 1;
inline int RepoDataDeleteRequest::_internal_loc_size() const {
  return _internal_loc().size();
}
inline int RepoDataDeleteRequest::loc_size() const {
  return _internal_loc_size();
}
inline ::SDMS::RecordDataLocation* RepoDataDeleteRequest::mutable_loc(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoDataDeleteRequest.loc)
  return _internal_mutable_loc()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>* RepoDataDeleteRequest::mutable_loc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoDataDeleteRequest.loc)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_loc();
}
inline const ::SDMS::RecordDataLocation& RepoDataDeleteRequest::loc(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoDataDeleteRequest.loc)
  return _internal_loc().Get(index);
}
inline ::SDMS::RecordDataLocation* RepoDataDeleteRequest::add_loc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::RecordDataLocation* _add = _internal_mutable_loc()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoDataDeleteRequest.loc)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>& RepoDataDeleteRequest::loc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoDataDeleteRequest.loc)
  return _internal_loc();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>&
RepoDataDeleteRequest::_internal_loc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loc_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>*
RepoDataDeleteRequest::_internal_mutable_loc() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.loc_;
}

// -------------------------------------------------------------------

// RepoDataGetSizeRequest

// repeated .SDMS.RecordDataLocation loc = 1;
inline int RepoDataGetSizeRequest::_internal_loc_size() const {
  return _internal_loc().size();
}
inline int RepoDataGetSizeRequest::loc_size() const {
  return _internal_loc_size();
}
inline ::SDMS::RecordDataLocation* RepoDataGetSizeRequest::mutable_loc(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoDataGetSizeRequest.loc)
  return _internal_mutable_loc()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>* RepoDataGetSizeRequest::mutable_loc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoDataGetSizeRequest.loc)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_loc();
}
inline const ::SDMS::RecordDataLocation& RepoDataGetSizeRequest::loc(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoDataGetSizeRequest.loc)
  return _internal_loc().Get(index);
}
inline ::SDMS::RecordDataLocation* RepoDataGetSizeRequest::add_loc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::RecordDataLocation* _add = _internal_mutable_loc()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoDataGetSizeRequest.loc)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>& RepoDataGetSizeRequest::loc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoDataGetSizeRequest.loc)
  return _internal_loc();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>&
RepoDataGetSizeRequest::_internal_loc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loc_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>*
RepoDataGetSizeRequest::_internal_mutable_loc() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.loc_;
}

// -------------------------------------------------------------------

// RepoDataSizeReply

// repeated .SDMS.RecordDataSize size = 1;
inline int RepoDataSizeReply::_internal_size_size() const {
  return _internal_size().size();
}
inline int RepoDataSizeReply::size_size() const {
  return _internal_size_size();
}
inline ::SDMS::RecordDataSize* RepoDataSizeReply::mutable_size(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoDataSizeReply.size)
  return _internal_mutable_size()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataSize>* RepoDataSizeReply::mutable_size()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoDataSizeReply.size)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_size();
}
inline const ::SDMS::RecordDataSize& RepoDataSizeReply::size(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoDataSizeReply.size)
  return _internal_size().Get(index);
}
inline ::SDMS::RecordDataSize* RepoDataSizeReply::add_size() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::RecordDataSize* _add = _internal_mutable_size()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoDataSizeReply.size)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataSize>& RepoDataSizeReply::size() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoDataSizeReply.size)
  return _internal_size();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataSize>&
RepoDataSizeReply::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataSize>*
RepoDataSizeReply::_internal_mutable_size() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.size_;
}

// -------------------------------------------------------------------

// RepoPathCreateRequest

// required string path = 1;
inline bool RepoPathCreateRequest::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoPathCreateRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoPathCreateRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoPathCreateRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoPathCreateRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoPathCreateRequest.path)
}
inline std::string* RepoPathCreateRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoPathCreateRequest.path)
  return _s;
}
inline const std::string& RepoPathCreateRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void RepoPathCreateRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* RepoPathCreateRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* RepoPathCreateRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoPathCreateRequest.path)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoPathCreateRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoPathCreateRequest.path)
}

// -------------------------------------------------------------------

// RepoPathDeleteRequest

// required string path = 1;
inline bool RepoPathDeleteRequest::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoPathDeleteRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoPathDeleteRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoPathDeleteRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoPathDeleteRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoPathDeleteRequest.path)
}
inline std::string* RepoPathDeleteRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoPathDeleteRequest.path)
  return _s;
}
inline const std::string& RepoPathDeleteRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void RepoPathDeleteRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* RepoPathDeleteRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* RepoPathDeleteRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoPathDeleteRequest.path)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoPathDeleteRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoPathDeleteRequest.path)
}

// -------------------------------------------------------------------

// RepoListRequest

// optional bool details = 1;
inline bool RepoListRequest::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoListRequest::clear_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.details_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RepoListRequest::details() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoListRequest.details)
  return _internal_details();
}
inline void RepoListRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoListRequest.details)
}
inline bool RepoListRequest::_internal_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.details_;
}
inline void RepoListRequest::_internal_set_details(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.details_ = value;
}

// optional bool all = 2;
inline bool RepoListRequest::has_all() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoListRequest::clear_all() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.all_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RepoListRequest::all() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoListRequest.all)
  return _internal_all();
}
inline void RepoListRequest::set_all(bool value) {
  _internal_set_all(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoListRequest.all)
}
inline bool RepoListRequest::_internal_all() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.all_;
}
inline void RepoListRequest::_internal_set_all(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.all_ = value;
}

// -------------------------------------------------------------------

// RepoViewRequest

// required string id = 1;
inline bool RepoViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoViewRequest.id)
}
inline std::string* RepoViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoViewRequest.id)
  return _s;
}
inline const std::string& RepoViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RepoViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RepoViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RepoViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoViewRequest.id)
}

// -------------------------------------------------------------------

// RepoCreateRequest

// required string id = 1;
inline bool RepoCreateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoCreateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.id)
}
inline std::string* RepoCreateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.id)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RepoCreateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.id)
}

// required string title = 2;
inline bool RepoCreateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoCreateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.title)
}
inline std::string* RepoCreateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.title)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void RepoCreateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.title)
}

// optional string desc = 3;
inline bool RepoCreateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RepoCreateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.desc)
}
inline std::string* RepoCreateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.desc)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void RepoCreateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.desc)
}

// optional string domain = 5;
inline bool RepoCreateRequest::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RepoCreateRequest::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.domain)
}
inline std::string* RepoCreateRequest::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.domain)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void RepoCreateRequest::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.domain)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.domain_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.domain)
}

// required string path = 6;
inline bool RepoCreateRequest::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RepoCreateRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.path)
}
inline std::string* RepoCreateRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.path)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void RepoCreateRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.path)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.path)
}

// optional string exp_path = 7;
inline bool RepoCreateRequest::has_exp_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& RepoCreateRequest::exp_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.exp_path)
  return _internal_exp_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_exp_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.exp_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.exp_path)
}
inline std::string* RepoCreateRequest::mutable_exp_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_exp_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.exp_path)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_exp_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exp_path_.Get();
}
inline void RepoCreateRequest::_internal_set_exp_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.exp_path_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.exp_path_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.exp_path)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.exp_path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.exp_path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_exp_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.exp_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.exp_path_.IsDefault()) {
          _impl_.exp_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.exp_path)
}

// required string address = 8;
inline bool RepoCreateRequest::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& RepoCreateRequest::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.address)
}
inline std::string* RepoCreateRequest::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.address)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void RepoCreateRequest::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.address)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.address)
}

// required string endpoint = 9;
inline bool RepoCreateRequest::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.endpoint_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& RepoCreateRequest::endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.endpoint)
  return _internal_endpoint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_endpoint(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.endpoint)
}
inline std::string* RepoCreateRequest::mutable_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.endpoint)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_endpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endpoint_.Get();
}
inline void RepoCreateRequest::_internal_set_endpoint(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.endpoint_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.endpoint_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.endpoint)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.endpoint_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_endpoint(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.endpoint_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_.IsDefault()) {
          _impl_.endpoint_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.endpoint)
}

// required string pub_key = 10;
inline bool RepoCreateRequest::has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pub_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& RepoCreateRequest::pub_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.pub_key)
  return _internal_pub_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoCreateRequest::set_pub_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.pub_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.pub_key)
}
inline std::string* RepoCreateRequest::mutable_pub_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.pub_key)
  return _s;
}
inline const std::string& RepoCreateRequest::_internal_pub_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pub_key_.Get();
}
inline void RepoCreateRequest::_internal_set_pub_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.pub_key_.Set(value, GetArena());
}
inline std::string* RepoCreateRequest::_internal_mutable_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.pub_key_.Mutable( GetArena());
}
inline std::string* RepoCreateRequest::release_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoCreateRequest.pub_key)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.pub_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pub_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoCreateRequest::set_allocated_pub_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.pub_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pub_key_.IsDefault()) {
          _impl_.pub_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoCreateRequest.pub_key)
}

// required uint64 capacity = 11;
inline bool RepoCreateRequest::has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RepoCreateRequest::clear_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t RepoCreateRequest::capacity() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.capacity)
  return _internal_capacity();
}
inline void RepoCreateRequest::set_capacity(::uint64_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.capacity)
}
inline ::uint64_t RepoCreateRequest::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_;
}
inline void RepoCreateRequest::_internal_set_capacity(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.capacity_ = value;
}

// repeated string admin = 12;
inline int RepoCreateRequest::_internal_admin_size() const {
  return _internal_admin().size();
}
inline int RepoCreateRequest::admin_size() const {
  return _internal_admin_size();
}
inline void RepoCreateRequest::clear_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_.Clear();
}
inline std::string* RepoCreateRequest::add_admin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_admin()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RepoCreateRequest.admin)
  return _s;
}
inline const std::string& RepoCreateRequest::admin(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCreateRequest.admin)
  return _internal_admin().Get(index);
}
inline std::string* RepoCreateRequest::mutable_admin(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCreateRequest.admin)
  return _internal_mutable_admin()->Mutable(index);
}
inline void RepoCreateRequest::set_admin(int index, const std::string& value) {
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::set_admin(int index, std::string&& value) {
  _internal_mutable_admin()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::set_admin(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::set_admin(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_admin()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::set_admin(int index, absl::string_view value) {
  _internal_mutable_admin()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::add_admin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::add_admin(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::add_admin(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::add_admin(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RepoCreateRequest.admin)
}
inline void RepoCreateRequest::add_admin(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RepoCreateRequest.admin)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RepoCreateRequest::admin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoCreateRequest.admin)
  return _internal_admin();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RepoCreateRequest::mutable_admin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoCreateRequest.admin)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_admin();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RepoCreateRequest::_internal_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RepoCreateRequest::_internal_mutable_admin() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.admin_;
}

// -------------------------------------------------------------------

// RepoUpdateRequest

// required string id = 1;
inline bool RepoUpdateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoUpdateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.id)
}
inline std::string* RepoUpdateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.id)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RepoUpdateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.id)
}

// optional string title = 2;
inline bool RepoUpdateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoUpdateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.title)
}
inline std::string* RepoUpdateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.title)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void RepoUpdateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.title)
}

// optional string desc = 3;
inline bool RepoUpdateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RepoUpdateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.desc)
}
inline std::string* RepoUpdateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.desc)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void RepoUpdateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.desc)
}

// optional string domain = 5;
inline bool RepoUpdateRequest::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RepoUpdateRequest::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.domain)
}
inline std::string* RepoUpdateRequest::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.domain)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void RepoUpdateRequest::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.domain)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.domain_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.domain)
}

// optional string path = 6;
inline bool RepoUpdateRequest::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RepoUpdateRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.path)
}
inline std::string* RepoUpdateRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.path)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void RepoUpdateRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.path)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.path)
}

// optional string exp_path = 7;
inline bool RepoUpdateRequest::has_exp_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& RepoUpdateRequest::exp_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.exp_path)
  return _internal_exp_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_exp_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.exp_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.exp_path)
}
inline std::string* RepoUpdateRequest::mutable_exp_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_exp_path();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.exp_path)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_exp_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exp_path_.Get();
}
inline void RepoUpdateRequest::_internal_set_exp_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.exp_path_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.exp_path_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.exp_path)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.exp_path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.exp_path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_exp_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.exp_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.exp_path_.IsDefault()) {
          _impl_.exp_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.exp_path)
}

// optional string address = 8;
inline bool RepoUpdateRequest::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& RepoUpdateRequest::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.address)
}
inline std::string* RepoUpdateRequest::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.address)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void RepoUpdateRequest::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.address)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.address)
}

// optional string endpoint = 9;
inline bool RepoUpdateRequest::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.endpoint_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& RepoUpdateRequest::endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.endpoint)
  return _internal_endpoint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_endpoint(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.endpoint)
}
inline std::string* RepoUpdateRequest::mutable_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.endpoint)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_endpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endpoint_.Get();
}
inline void RepoUpdateRequest::_internal_set_endpoint(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.endpoint_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.endpoint_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.endpoint)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.endpoint_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_endpoint(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.endpoint_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_.IsDefault()) {
          _impl_.endpoint_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.endpoint)
}

// optional string pub_key = 10;
inline bool RepoUpdateRequest::has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pub_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& RepoUpdateRequest::pub_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.pub_key)
  return _internal_pub_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoUpdateRequest::set_pub_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.pub_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.pub_key)
}
inline std::string* RepoUpdateRequest::mutable_pub_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.pub_key)
  return _s;
}
inline const std::string& RepoUpdateRequest::_internal_pub_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pub_key_.Get();
}
inline void RepoUpdateRequest::_internal_set_pub_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.pub_key_.Set(value, GetArena());
}
inline std::string* RepoUpdateRequest::_internal_mutable_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.pub_key_.Mutable( GetArena());
}
inline std::string* RepoUpdateRequest::release_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoUpdateRequest.pub_key)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.pub_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pub_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoUpdateRequest::set_allocated_pub_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.pub_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pub_key_.IsDefault()) {
          _impl_.pub_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoUpdateRequest.pub_key)
}

// optional uint64 capacity = 11;
inline bool RepoUpdateRequest::has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RepoUpdateRequest::clear_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t RepoUpdateRequest::capacity() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.capacity)
  return _internal_capacity();
}
inline void RepoUpdateRequest::set_capacity(::uint64_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.capacity)
}
inline ::uint64_t RepoUpdateRequest::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_;
}
inline void RepoUpdateRequest::_internal_set_capacity(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.capacity_ = value;
}

// repeated string admin = 12;
inline int RepoUpdateRequest::_internal_admin_size() const {
  return _internal_admin().size();
}
inline int RepoUpdateRequest::admin_size() const {
  return _internal_admin_size();
}
inline void RepoUpdateRequest::clear_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_.Clear();
}
inline std::string* RepoUpdateRequest::add_admin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_admin()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RepoUpdateRequest.admin)
  return _s;
}
inline const std::string& RepoUpdateRequest::admin(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoUpdateRequest.admin)
  return _internal_admin().Get(index);
}
inline std::string* RepoUpdateRequest::mutable_admin(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoUpdateRequest.admin)
  return _internal_mutable_admin()->Mutable(index);
}
inline void RepoUpdateRequest::set_admin(int index, const std::string& value) {
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::set_admin(int index, std::string&& value) {
  _internal_mutable_admin()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::set_admin(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::set_admin(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_admin()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::set_admin(int index, absl::string_view value) {
  _internal_mutable_admin()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::add_admin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::add_admin(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::add_admin(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::add_admin(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RepoUpdateRequest.admin)
}
inline void RepoUpdateRequest::add_admin(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RepoUpdateRequest.admin)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RepoUpdateRequest::admin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoUpdateRequest.admin)
  return _internal_admin();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RepoUpdateRequest::mutable_admin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoUpdateRequest.admin)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_admin();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RepoUpdateRequest::_internal_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RepoUpdateRequest::_internal_mutable_admin() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.admin_;
}

// -------------------------------------------------------------------

// RepoDeleteRequest

// required string id = 1;
inline bool RepoDeleteRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoDeleteRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoDeleteRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoDeleteRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoDeleteRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoDeleteRequest.id)
}
inline std::string* RepoDeleteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoDeleteRequest.id)
  return _s;
}
inline const std::string& RepoDeleteRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RepoDeleteRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RepoDeleteRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RepoDeleteRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoDeleteRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoDeleteRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoDeleteRequest.id)
}

// -------------------------------------------------------------------

// RepoDataReply

// repeated .SDMS.RepoData repo = 1;
inline int RepoDataReply::_internal_repo_size() const {
  return _internal_repo().size();
}
inline int RepoDataReply::repo_size() const {
  return _internal_repo_size();
}
inline ::SDMS::RepoData* RepoDataReply::mutable_repo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoDataReply.repo)
  return _internal_mutable_repo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RepoData>* RepoDataReply::mutable_repo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoDataReply.repo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_repo();
}
inline const ::SDMS::RepoData& RepoDataReply::repo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoDataReply.repo)
  return _internal_repo().Get(index);
}
inline ::SDMS::RepoData* RepoDataReply::add_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::RepoData* _add = _internal_mutable_repo()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoDataReply.repo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RepoData>& RepoDataReply::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoDataReply.repo)
  return _internal_repo();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RepoData>&
RepoDataReply::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RepoData>*
RepoDataReply::_internal_mutable_repo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.repo_;
}

// -------------------------------------------------------------------

// RepoCalcSizeRequest

// required bool recurse = 1;
inline bool RepoCalcSizeRequest::has_recurse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoCalcSizeRequest::clear_recurse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recurse_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RepoCalcSizeRequest::recurse() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCalcSizeRequest.recurse)
  return _internal_recurse();
}
inline void RepoCalcSizeRequest::set_recurse(bool value) {
  _internal_set_recurse(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCalcSizeRequest.recurse)
}
inline bool RepoCalcSizeRequest::_internal_recurse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recurse_;
}
inline void RepoCalcSizeRequest::_internal_set_recurse(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.recurse_ = value;
}

// repeated string item = 2;
inline int RepoCalcSizeRequest::_internal_item_size() const {
  return _internal_item().size();
}
inline int RepoCalcSizeRequest::item_size() const {
  return _internal_item_size();
}
inline void RepoCalcSizeRequest::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.Clear();
}
inline std::string* RepoCalcSizeRequest::add_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_item()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.RepoCalcSizeRequest.item)
  return _s;
}
inline const std::string& RepoCalcSizeRequest::item(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCalcSizeRequest.item)
  return _internal_item().Get(index);
}
inline std::string* RepoCalcSizeRequest::mutable_item(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCalcSizeRequest.item)
  return _internal_mutable_item()->Mutable(index);
}
inline void RepoCalcSizeRequest::set_item(int index, const std::string& value) {
  _internal_mutable_item()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::set_item(int index, std::string&& value) {
  _internal_mutable_item()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::set_item(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_item()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::set_item(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_item()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::set_item(int index, absl::string_view value) {
  _internal_mutable_item()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::add_item(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::add_item(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::add_item(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::add_item(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline void RepoCalcSizeRequest::add_item(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_item()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.RepoCalcSizeRequest.item)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RepoCalcSizeRequest::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoCalcSizeRequest.item)
  return _internal_item();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RepoCalcSizeRequest::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoCalcSizeRequest.item)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_item();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RepoCalcSizeRequest::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RepoCalcSizeRequest::_internal_mutable_item() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.item_;
}

// -------------------------------------------------------------------

// RepoCalcSizeReply

// repeated .SDMS.AllocStatsData stats = 1;
inline int RepoCalcSizeReply::_internal_stats_size() const {
  return _internal_stats().size();
}
inline int RepoCalcSizeReply::stats_size() const {
  return _internal_stats_size();
}
inline ::SDMS::AllocStatsData* RepoCalcSizeReply::mutable_stats(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoCalcSizeReply.stats)
  return _internal_mutable_stats()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocStatsData>* RepoCalcSizeReply::mutable_stats()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoCalcSizeReply.stats)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_stats();
}
inline const ::SDMS::AllocStatsData& RepoCalcSizeReply::stats(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoCalcSizeReply.stats)
  return _internal_stats().Get(index);
}
inline ::SDMS::AllocStatsData* RepoCalcSizeReply::add_stats() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::AllocStatsData* _add = _internal_mutable_stats()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoCalcSizeReply.stats)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocStatsData>& RepoCalcSizeReply::stats() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoCalcSizeReply.stats)
  return _internal_stats();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocStatsData>&
RepoCalcSizeReply::_internal_stats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stats_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocStatsData>*
RepoCalcSizeReply::_internal_mutable_stats() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.stats_;
}

// -------------------------------------------------------------------

// RepoListAllocationsRequest

// required string id = 1;
inline bool RepoListAllocationsRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoListAllocationsRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoListAllocationsRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoListAllocationsRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoListAllocationsRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoListAllocationsRequest.id)
}
inline std::string* RepoListAllocationsRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoListAllocationsRequest.id)
  return _s;
}
inline const std::string& RepoListAllocationsRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RepoListAllocationsRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RepoListAllocationsRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RepoListAllocationsRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoListAllocationsRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoListAllocationsRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoListAllocationsRequest.id)
}

// -------------------------------------------------------------------

// RepoListSubjectAllocationsRequest

// optional string subject = 1;
inline bool RepoListSubjectAllocationsRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoListSubjectAllocationsRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoListSubjectAllocationsRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoListSubjectAllocationsRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoListSubjectAllocationsRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoListSubjectAllocationsRequest.subject)
}
inline std::string* RepoListSubjectAllocationsRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoListSubjectAllocationsRequest.subject)
  return _s;
}
inline const std::string& RepoListSubjectAllocationsRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void RepoListSubjectAllocationsRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* RepoListSubjectAllocationsRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* RepoListSubjectAllocationsRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoListSubjectAllocationsRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoListSubjectAllocationsRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoListSubjectAllocationsRequest.subject)
}

// optional bool stats = 2;
inline bool RepoListSubjectAllocationsRequest::has_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoListSubjectAllocationsRequest::clear_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stats_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RepoListSubjectAllocationsRequest::stats() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoListSubjectAllocationsRequest.stats)
  return _internal_stats();
}
inline void RepoListSubjectAllocationsRequest::set_stats(bool value) {
  _internal_set_stats(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoListSubjectAllocationsRequest.stats)
}
inline bool RepoListSubjectAllocationsRequest::_internal_stats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stats_;
}
inline void RepoListSubjectAllocationsRequest::_internal_set_stats(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stats_ = value;
}

// -------------------------------------------------------------------

// RepoListObjectAllocationsRequest

// required string id = 1;
inline bool RepoListObjectAllocationsRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoListObjectAllocationsRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoListObjectAllocationsRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoListObjectAllocationsRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoListObjectAllocationsRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoListObjectAllocationsRequest.id)
}
inline std::string* RepoListObjectAllocationsRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoListObjectAllocationsRequest.id)
  return _s;
}
inline const std::string& RepoListObjectAllocationsRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RepoListObjectAllocationsRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RepoListObjectAllocationsRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RepoListObjectAllocationsRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoListObjectAllocationsRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoListObjectAllocationsRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoListObjectAllocationsRequest.id)
}

// -------------------------------------------------------------------

// RepoViewAllocationRequest

// required string repo = 1;
inline bool RepoViewAllocationRequest::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoViewAllocationRequest::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoViewAllocationRequest::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoViewAllocationRequest.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoViewAllocationRequest::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoViewAllocationRequest.repo)
}
inline std::string* RepoViewAllocationRequest::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoViewAllocationRequest.repo)
  return _s;
}
inline const std::string& RepoViewAllocationRequest::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void RepoViewAllocationRequest::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* RepoViewAllocationRequest::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* RepoViewAllocationRequest::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoViewAllocationRequest.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoViewAllocationRequest::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoViewAllocationRequest.repo)
}

// required string subject = 2;
inline bool RepoViewAllocationRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoViewAllocationRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoViewAllocationRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoViewAllocationRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoViewAllocationRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoViewAllocationRequest.subject)
}
inline std::string* RepoViewAllocationRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoViewAllocationRequest.subject)
  return _s;
}
inline const std::string& RepoViewAllocationRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void RepoViewAllocationRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* RepoViewAllocationRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* RepoViewAllocationRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoViewAllocationRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoViewAllocationRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoViewAllocationRequest.subject)
}

// -------------------------------------------------------------------

// RepoAllocationsReply

// repeated .SDMS.AllocData alloc = 1;
inline int RepoAllocationsReply::_internal_alloc_size() const {
  return _internal_alloc().size();
}
inline int RepoAllocationsReply::alloc_size() const {
  return _internal_alloc_size();
}
inline ::SDMS::AllocData* RepoAllocationsReply::mutable_alloc(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationsReply.alloc)
  return _internal_mutable_alloc()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>* RepoAllocationsReply::mutable_alloc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.RepoAllocationsReply.alloc)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alloc();
}
inline const ::SDMS::AllocData& RepoAllocationsReply::alloc(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationsReply.alloc)
  return _internal_alloc().Get(index);
}
inline ::SDMS::AllocData* RepoAllocationsReply::add_alloc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::AllocData* _add = _internal_mutable_alloc()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.RepoAllocationsReply.alloc)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>& RepoAllocationsReply::alloc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.RepoAllocationsReply.alloc)
  return _internal_alloc();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>&
RepoAllocationsReply::_internal_alloc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alloc_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>*
RepoAllocationsReply::_internal_mutable_alloc() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alloc_;
}

// -------------------------------------------------------------------

// RepoAllocationStatsRequest

// required string repo = 1;
inline bool RepoAllocationStatsRequest::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoAllocationStatsRequest::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoAllocationStatsRequest::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationStatsRequest.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationStatsRequest::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationStatsRequest.repo)
}
inline std::string* RepoAllocationStatsRequest::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationStatsRequest.repo)
  return _s;
}
inline const std::string& RepoAllocationStatsRequest::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void RepoAllocationStatsRequest::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* RepoAllocationStatsRequest::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* RepoAllocationStatsRequest::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationStatsRequest.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationStatsRequest::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationStatsRequest.repo)
}

// optional string subject = 2;
inline bool RepoAllocationStatsRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoAllocationStatsRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoAllocationStatsRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationStatsRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationStatsRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationStatsRequest.subject)
}
inline std::string* RepoAllocationStatsRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationStatsRequest.subject)
  return _s;
}
inline const std::string& RepoAllocationStatsRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void RepoAllocationStatsRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* RepoAllocationStatsRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* RepoAllocationStatsRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationStatsRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationStatsRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationStatsRequest.subject)
}

// -------------------------------------------------------------------

// RepoAllocationStatsReply

// required .SDMS.AllocStatsData alloc = 1;
inline bool RepoAllocationStatsReply::has_alloc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alloc_ != nullptr);
  return value;
}
inline const ::SDMS::AllocStatsData& RepoAllocationStatsReply::_internal_alloc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::AllocStatsData* p = _impl_.alloc_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::AllocStatsData&>(::SDMS::_AllocStatsData_default_instance_);
}
inline const ::SDMS::AllocStatsData& RepoAllocationStatsReply::alloc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationStatsReply.alloc)
  return _internal_alloc();
}
inline void RepoAllocationStatsReply::unsafe_arena_set_allocated_alloc(::SDMS::AllocStatsData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.alloc_);
  }
  _impl_.alloc_ = reinterpret_cast<::SDMS::AllocStatsData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.RepoAllocationStatsReply.alloc)
}
inline ::SDMS::AllocStatsData* RepoAllocationStatsReply::release_alloc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::AllocStatsData* released = _impl_.alloc_;
  _impl_.alloc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::AllocStatsData* RepoAllocationStatsReply::unsafe_arena_release_alloc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationStatsReply.alloc)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SDMS::AllocStatsData* temp = _impl_.alloc_;
  _impl_.alloc_ = nullptr;
  return temp;
}
inline ::SDMS::AllocStatsData* RepoAllocationStatsReply::_internal_mutable_alloc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.alloc_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::AllocStatsData>(GetArena());
    _impl_.alloc_ = reinterpret_cast<::SDMS::AllocStatsData*>(p);
  }
  return _impl_.alloc_;
}
inline ::SDMS::AllocStatsData* RepoAllocationStatsReply::mutable_alloc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::AllocStatsData* _msg = _internal_mutable_alloc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationStatsReply.alloc)
  return _msg;
}
inline void RepoAllocationStatsReply::set_allocated_alloc(::SDMS::AllocStatsData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.alloc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.alloc_ = reinterpret_cast<::SDMS::AllocStatsData*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationStatsReply.alloc)
}

// -------------------------------------------------------------------

// RepoAllocationCreateRequest

// required string repo = 1;
inline bool RepoAllocationCreateRequest::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoAllocationCreateRequest::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoAllocationCreateRequest::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationCreateRequest.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationCreateRequest::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationCreateRequest.repo)
}
inline std::string* RepoAllocationCreateRequest::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationCreateRequest.repo)
  return _s;
}
inline const std::string& RepoAllocationCreateRequest::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void RepoAllocationCreateRequest::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* RepoAllocationCreateRequest::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* RepoAllocationCreateRequest::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationCreateRequest.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationCreateRequest::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationCreateRequest.repo)
}

// required string subject = 2;
inline bool RepoAllocationCreateRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoAllocationCreateRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoAllocationCreateRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationCreateRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationCreateRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationCreateRequest.subject)
}
inline std::string* RepoAllocationCreateRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationCreateRequest.subject)
  return _s;
}
inline const std::string& RepoAllocationCreateRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void RepoAllocationCreateRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* RepoAllocationCreateRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* RepoAllocationCreateRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationCreateRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationCreateRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationCreateRequest.subject)
}

// required uint64 data_limit = 3;
inline bool RepoAllocationCreateRequest::has_data_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepoAllocationCreateRequest::clear_data_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_limit_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t RepoAllocationCreateRequest::data_limit() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationCreateRequest.data_limit)
  return _internal_data_limit();
}
inline void RepoAllocationCreateRequest::set_data_limit(::uint64_t value) {
  _internal_set_data_limit(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationCreateRequest.data_limit)
}
inline ::uint64_t RepoAllocationCreateRequest::_internal_data_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_limit_;
}
inline void RepoAllocationCreateRequest::_internal_set_data_limit(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_limit_ = value;
}

// required uint32 rec_limit = 4;
inline bool RepoAllocationCreateRequest::has_rec_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepoAllocationCreateRequest::clear_rec_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rec_limit_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RepoAllocationCreateRequest::rec_limit() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationCreateRequest.rec_limit)
  return _internal_rec_limit();
}
inline void RepoAllocationCreateRequest::set_rec_limit(::uint32_t value) {
  _internal_set_rec_limit(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationCreateRequest.rec_limit)
}
inline ::uint32_t RepoAllocationCreateRequest::_internal_rec_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rec_limit_;
}
inline void RepoAllocationCreateRequest::_internal_set_rec_limit(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rec_limit_ = value;
}

// -------------------------------------------------------------------

// RepoAllocationSetRequest

// required string repo = 1;
inline bool RepoAllocationSetRequest::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoAllocationSetRequest::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoAllocationSetRequest::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationSetRequest.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationSetRequest::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationSetRequest.repo)
}
inline std::string* RepoAllocationSetRequest::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationSetRequest.repo)
  return _s;
}
inline const std::string& RepoAllocationSetRequest::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void RepoAllocationSetRequest::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* RepoAllocationSetRequest::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* RepoAllocationSetRequest::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationSetRequest.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationSetRequest::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationSetRequest.repo)
}

// required string subject = 2;
inline bool RepoAllocationSetRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoAllocationSetRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoAllocationSetRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationSetRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationSetRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationSetRequest.subject)
}
inline std::string* RepoAllocationSetRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationSetRequest.subject)
  return _s;
}
inline const std::string& RepoAllocationSetRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void RepoAllocationSetRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* RepoAllocationSetRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* RepoAllocationSetRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationSetRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationSetRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationSetRequest.subject)
}

// required uint64 data_limit = 3;
inline bool RepoAllocationSetRequest::has_data_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepoAllocationSetRequest::clear_data_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_limit_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t RepoAllocationSetRequest::data_limit() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationSetRequest.data_limit)
  return _internal_data_limit();
}
inline void RepoAllocationSetRequest::set_data_limit(::uint64_t value) {
  _internal_set_data_limit(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationSetRequest.data_limit)
}
inline ::uint64_t RepoAllocationSetRequest::_internal_data_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_limit_;
}
inline void RepoAllocationSetRequest::_internal_set_data_limit(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_limit_ = value;
}

// required uint32 rec_limit = 4;
inline bool RepoAllocationSetRequest::has_rec_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepoAllocationSetRequest::clear_rec_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rec_limit_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RepoAllocationSetRequest::rec_limit() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationSetRequest.rec_limit)
  return _internal_rec_limit();
}
inline void RepoAllocationSetRequest::set_rec_limit(::uint32_t value) {
  _internal_set_rec_limit(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationSetRequest.rec_limit)
}
inline ::uint32_t RepoAllocationSetRequest::_internal_rec_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rec_limit_;
}
inline void RepoAllocationSetRequest::_internal_set_rec_limit(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rec_limit_ = value;
}

// -------------------------------------------------------------------

// RepoAllocationSetDefaultRequest

// required string repo = 1;
inline bool RepoAllocationSetDefaultRequest::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoAllocationSetDefaultRequest::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoAllocationSetDefaultRequest::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationSetDefaultRequest.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationSetDefaultRequest::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationSetDefaultRequest.repo)
}
inline std::string* RepoAllocationSetDefaultRequest::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationSetDefaultRequest.repo)
  return _s;
}
inline const std::string& RepoAllocationSetDefaultRequest::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void RepoAllocationSetDefaultRequest::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* RepoAllocationSetDefaultRequest::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* RepoAllocationSetDefaultRequest::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationSetDefaultRequest.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationSetDefaultRequest::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationSetDefaultRequest.repo)
}

// optional string subject = 2;
inline bool RepoAllocationSetDefaultRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoAllocationSetDefaultRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoAllocationSetDefaultRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationSetDefaultRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationSetDefaultRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationSetDefaultRequest.subject)
}
inline std::string* RepoAllocationSetDefaultRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationSetDefaultRequest.subject)
  return _s;
}
inline const std::string& RepoAllocationSetDefaultRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void RepoAllocationSetDefaultRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* RepoAllocationSetDefaultRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* RepoAllocationSetDefaultRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationSetDefaultRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationSetDefaultRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationSetDefaultRequest.subject)
}

// -------------------------------------------------------------------

// RepoAllocationDeleteRequest

// required string repo = 1;
inline bool RepoAllocationDeleteRequest::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoAllocationDeleteRequest::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoAllocationDeleteRequest::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationDeleteRequest.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationDeleteRequest::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationDeleteRequest.repo)
}
inline std::string* RepoAllocationDeleteRequest::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationDeleteRequest.repo)
  return _s;
}
inline const std::string& RepoAllocationDeleteRequest::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void RepoAllocationDeleteRequest::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* RepoAllocationDeleteRequest::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* RepoAllocationDeleteRequest::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationDeleteRequest.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationDeleteRequest::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationDeleteRequest.repo)
}

// required string subject = 2;
inline bool RepoAllocationDeleteRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoAllocationDeleteRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoAllocationDeleteRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAllocationDeleteRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAllocationDeleteRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAllocationDeleteRequest.subject)
}
inline std::string* RepoAllocationDeleteRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAllocationDeleteRequest.subject)
  return _s;
}
inline const std::string& RepoAllocationDeleteRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void RepoAllocationDeleteRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* RepoAllocationDeleteRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* RepoAllocationDeleteRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAllocationDeleteRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAllocationDeleteRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAllocationDeleteRequest.subject)
}

// -------------------------------------------------------------------

// RepoAuthzRequest

// required string repo = 1;
inline bool RepoAuthzRequest::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoAuthzRequest::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoAuthzRequest::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAuthzRequest.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAuthzRequest::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAuthzRequest.repo)
}
inline std::string* RepoAuthzRequest::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAuthzRequest.repo)
  return _s;
}
inline const std::string& RepoAuthzRequest::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void RepoAuthzRequest::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* RepoAuthzRequest::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* RepoAuthzRequest::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAuthzRequest.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAuthzRequest::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAuthzRequest.repo)
}

// required string client = 2;
inline bool RepoAuthzRequest::has_client() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoAuthzRequest::clear_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoAuthzRequest::client() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAuthzRequest.client)
  return _internal_client();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAuthzRequest::set_client(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAuthzRequest.client)
}
inline std::string* RepoAuthzRequest::mutable_client() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAuthzRequest.client)
  return _s;
}
inline const std::string& RepoAuthzRequest::_internal_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_.Get();
}
inline void RepoAuthzRequest::_internal_set_client(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_.Set(value, GetArena());
}
inline std::string* RepoAuthzRequest::_internal_mutable_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.client_.Mutable( GetArena());
}
inline std::string* RepoAuthzRequest::release_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAuthzRequest.client)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.client_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAuthzRequest::set_allocated_client(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.client_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_.IsDefault()) {
          _impl_.client_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAuthzRequest.client)
}

// required string file = 3;
inline bool RepoAuthzRequest::has_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepoAuthzRequest::clear_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.file_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RepoAuthzRequest::file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAuthzRequest.file)
  return _internal_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAuthzRequest::set_file(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAuthzRequest.file)
}
inline std::string* RepoAuthzRequest::mutable_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAuthzRequest.file)
  return _s;
}
inline const std::string& RepoAuthzRequest::_internal_file() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.file_.Get();
}
inline void RepoAuthzRequest::_internal_set_file(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.file_.Set(value, GetArena());
}
inline std::string* RepoAuthzRequest::_internal_mutable_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.file_.Mutable( GetArena());
}
inline std::string* RepoAuthzRequest::release_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAuthzRequest.file)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.file_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAuthzRequest::set_allocated_file(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.file_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_.IsDefault()) {
          _impl_.file_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAuthzRequest.file)
}

// required string action = 4;
inline bool RepoAuthzRequest::has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepoAuthzRequest::clear_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RepoAuthzRequest::action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.RepoAuthzRequest.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoAuthzRequest::set_action(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.RepoAuthzRequest.action)
}
inline std::string* RepoAuthzRequest::mutable_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.RepoAuthzRequest.action)
  return _s;
}
inline const std::string& RepoAuthzRequest::_internal_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_.Get();
}
inline void RepoAuthzRequest::_internal_set_action(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.action_.Set(value, GetArena());
}
inline std::string* RepoAuthzRequest::_internal_mutable_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.action_.Mutable( GetArena());
}
inline std::string* RepoAuthzRequest::release_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.RepoAuthzRequest.action)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.action_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.action_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoAuthzRequest::set_allocated_action(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.action_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_.IsDefault()) {
          _impl_.action_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.RepoAuthzRequest.action)
}

// -------------------------------------------------------------------

// QueryCreateRequest

// required string title = 1;
inline bool QueryCreateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryCreateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryCreateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryCreateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryCreateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryCreateRequest.title)
}
inline std::string* QueryCreateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryCreateRequest.title)
  return _s;
}
inline const std::string& QueryCreateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void QueryCreateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* QueryCreateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* QueryCreateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryCreateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryCreateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryCreateRequest.title)
}

// required .SDMS.Auth.SearchRequest query = 2;
inline bool QueryCreateRequest::has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_ != nullptr);
  return value;
}
inline void QueryCreateRequest::clear_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.query_ != nullptr) _impl_.query_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SDMS::Auth::SearchRequest& QueryCreateRequest::_internal_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::Auth::SearchRequest* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::Auth::SearchRequest&>(::SDMS::Auth::_SearchRequest_default_instance_);
}
inline const ::SDMS::Auth::SearchRequest& QueryCreateRequest::query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryCreateRequest.query)
  return _internal_query();
}
inline void QueryCreateRequest::unsafe_arena_set_allocated_query(::SDMS::Auth::SearchRequest* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.QueryCreateRequest.query)
}
inline ::SDMS::Auth::SearchRequest* QueryCreateRequest::release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SDMS::Auth::SearchRequest* released = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::Auth::SearchRequest* QueryCreateRequest::unsafe_arena_release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryCreateRequest.query)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SDMS::Auth::SearchRequest* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::SDMS::Auth::SearchRequest* QueryCreateRequest::_internal_mutable_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::Auth::SearchRequest>(GetArena());
    _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(p);
  }
  return _impl_.query_;
}
inline ::SDMS::Auth::SearchRequest* QueryCreateRequest::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::Auth::SearchRequest* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryCreateRequest.query)
  return _msg;
}
inline void QueryCreateRequest::set_allocated_query(::SDMS::Auth::SearchRequest* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::SDMS::Auth::SearchRequest*>(_impl_.query_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryCreateRequest.query)
}

// -------------------------------------------------------------------

// QueryUpdateRequest

// required string id = 1;
inline bool QueryUpdateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryUpdateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryUpdateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryUpdateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUpdateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryUpdateRequest.id)
}
inline std::string* QueryUpdateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryUpdateRequest.id)
  return _s;
}
inline const std::string& QueryUpdateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void QueryUpdateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* QueryUpdateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* QueryUpdateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryUpdateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUpdateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryUpdateRequest.id)
}

// optional string title = 2;
inline bool QueryUpdateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryUpdateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryUpdateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryUpdateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUpdateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryUpdateRequest.title)
}
inline std::string* QueryUpdateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryUpdateRequest.title)
  return _s;
}
inline const std::string& QueryUpdateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void QueryUpdateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* QueryUpdateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* QueryUpdateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryUpdateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUpdateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryUpdateRequest.title)
}

// optional .SDMS.Auth.SearchRequest query = 3;
inline bool QueryUpdateRequest::has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_ != nullptr);
  return value;
}
inline void QueryUpdateRequest::clear_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.query_ != nullptr) _impl_.query_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::SDMS::Auth::SearchRequest& QueryUpdateRequest::_internal_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::Auth::SearchRequest* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::Auth::SearchRequest&>(::SDMS::Auth::_SearchRequest_default_instance_);
}
inline const ::SDMS::Auth::SearchRequest& QueryUpdateRequest::query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryUpdateRequest.query)
  return _internal_query();
}
inline void QueryUpdateRequest::unsafe_arena_set_allocated_query(::SDMS::Auth::SearchRequest* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.QueryUpdateRequest.query)
}
inline ::SDMS::Auth::SearchRequest* QueryUpdateRequest::release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SDMS::Auth::SearchRequest* released = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::Auth::SearchRequest* QueryUpdateRequest::unsafe_arena_release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryUpdateRequest.query)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SDMS::Auth::SearchRequest* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::SDMS::Auth::SearchRequest* QueryUpdateRequest::_internal_mutable_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::Auth::SearchRequest>(GetArena());
    _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(p);
  }
  return _impl_.query_;
}
inline ::SDMS::Auth::SearchRequest* QueryUpdateRequest::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::Auth::SearchRequest* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryUpdateRequest.query)
  return _msg;
}
inline void QueryUpdateRequest::set_allocated_query(::SDMS::Auth::SearchRequest* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::SDMS::Auth::SearchRequest*>(_impl_.query_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryUpdateRequest.query)
}

// -------------------------------------------------------------------

// QueryDeleteRequest

// repeated string id = 1;
inline int QueryDeleteRequest::_internal_id_size() const {
  return _internal_id().size();
}
inline int QueryDeleteRequest::id_size() const {
  return _internal_id_size();
}
inline void QueryDeleteRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.Clear();
}
inline std::string* QueryDeleteRequest::add_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.Auth.QueryDeleteRequest.id)
  return _s;
}
inline const std::string& QueryDeleteRequest::id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryDeleteRequest.id)
  return _internal_id().Get(index);
}
inline std::string* QueryDeleteRequest::mutable_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryDeleteRequest.id)
  return _internal_mutable_id()->Mutable(index);
}
inline void QueryDeleteRequest::set_id(int index, const std::string& value) {
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::set_id(int index, std::string&& value) {
  _internal_mutable_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::set_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::set_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::set_id(int index, absl::string_view value) {
  _internal_mutable_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::add_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::add_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::add_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::add_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.Auth.QueryDeleteRequest.id)
}
inline void QueryDeleteRequest::add_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.Auth.QueryDeleteRequest.id)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
QueryDeleteRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.QueryDeleteRequest.id)
  return _internal_id();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
QueryDeleteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.QueryDeleteRequest.id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_id();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
QueryDeleteRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
QueryDeleteRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// QueryListRequest

// optional uint32 offset = 1;
inline bool QueryListRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryListRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t QueryListRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryListRequest.offset)
  return _internal_offset();
}
inline void QueryListRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryListRequest.offset)
}
inline ::uint32_t QueryListRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void QueryListRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 2;
inline bool QueryListRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryListRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t QueryListRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryListRequest.count)
  return _internal_count();
}
inline void QueryListRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryListRequest.count)
}
inline ::uint32_t QueryListRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void QueryListRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// QueryViewRequest

// required string id = 1;
inline bool QueryViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryViewRequest.id)
}
inline std::string* QueryViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryViewRequest.id)
  return _s;
}
inline const std::string& QueryViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void QueryViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* QueryViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* QueryViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryViewRequest.id)
}

// -------------------------------------------------------------------

// QueryExecRequest

// required string id = 1;
inline bool QueryExecRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryExecRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryExecRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryExecRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryExecRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryExecRequest.id)
}
inline std::string* QueryExecRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryExecRequest.id)
  return _s;
}
inline const std::string& QueryExecRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void QueryExecRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* QueryExecRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* QueryExecRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryExecRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryExecRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryExecRequest.id)
}

// optional uint32 offset = 2;
inline bool QueryExecRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryExecRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t QueryExecRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryExecRequest.offset)
  return _internal_offset();
}
inline void QueryExecRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryExecRequest.offset)
}
inline ::uint32_t QueryExecRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void QueryExecRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool QueryExecRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryExecRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t QueryExecRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryExecRequest.count)
  return _internal_count();
}
inline void QueryExecRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryExecRequest.count)
}
inline ::uint32_t QueryExecRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void QueryExecRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// QueryDataReply

// required string id = 1;
inline bool QueryDataReply::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryDataReply::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryDataReply::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryDataReply.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDataReply::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryDataReply.id)
}
inline std::string* QueryDataReply::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryDataReply.id)
  return _s;
}
inline const std::string& QueryDataReply::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void QueryDataReply::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* QueryDataReply::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* QueryDataReply::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryDataReply.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryDataReply::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryDataReply.id)
}

// required string title = 2;
inline bool QueryDataReply::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryDataReply::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryDataReply::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryDataReply.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDataReply::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryDataReply.title)
}
inline std::string* QueryDataReply::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryDataReply.title)
  return _s;
}
inline const std::string& QueryDataReply::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void QueryDataReply::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* QueryDataReply::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* QueryDataReply::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryDataReply.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryDataReply::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryDataReply.title)
}

// required string owner = 4;
inline bool QueryDataReply::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryDataReply::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryDataReply::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryDataReply.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDataReply::set_owner(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryDataReply.owner)
}
inline std::string* QueryDataReply::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryDataReply.owner)
  return _s;
}
inline const std::string& QueryDataReply::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_.Get();
}
inline void QueryDataReply::_internal_set_owner(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owner_.Set(value, GetArena());
}
inline std::string* QueryDataReply::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.owner_.Mutable( GetArena());
}
inline std::string* QueryDataReply::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryDataReply.owner)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryDataReply::set_allocated_owner(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryDataReply.owner)
}

// required uint32 ct = 5;
inline bool QueryDataReply::has_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void QueryDataReply::clear_ct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ct_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t QueryDataReply::ct() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryDataReply.ct)
  return _internal_ct();
}
inline void QueryDataReply::set_ct(::uint32_t value) {
  _internal_set_ct(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryDataReply.ct)
}
inline ::uint32_t QueryDataReply::_internal_ct() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ct_;
}
inline void QueryDataReply::_internal_set_ct(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ct_ = value;
}

// required uint32 ut = 6;
inline bool QueryDataReply::has_ut() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void QueryDataReply::clear_ut() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ut_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t QueryDataReply::ut() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryDataReply.ut)
  return _internal_ut();
}
inline void QueryDataReply::set_ut(::uint32_t value) {
  _internal_set_ut(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.QueryDataReply.ut)
}
inline ::uint32_t QueryDataReply::_internal_ut() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ut_;
}
inline void QueryDataReply::_internal_set_ut(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ut_ = value;
}

// required .SDMS.Auth.SearchRequest query = 7;
inline bool QueryDataReply::has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_ != nullptr);
  return value;
}
inline void QueryDataReply::clear_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.query_ != nullptr) _impl_.query_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::SDMS::Auth::SearchRequest& QueryDataReply::_internal_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::Auth::SearchRequest* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::Auth::SearchRequest&>(::SDMS::Auth::_SearchRequest_default_instance_);
}
inline const ::SDMS::Auth::SearchRequest& QueryDataReply::query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.QueryDataReply.query)
  return _internal_query();
}
inline void QueryDataReply::unsafe_arena_set_allocated_query(::SDMS::Auth::SearchRequest* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.Auth.QueryDataReply.query)
}
inline ::SDMS::Auth::SearchRequest* QueryDataReply::release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SDMS::Auth::SearchRequest* released = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::Auth::SearchRequest* QueryDataReply::unsafe_arena_release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.QueryDataReply.query)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SDMS::Auth::SearchRequest* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::SDMS::Auth::SearchRequest* QueryDataReply::_internal_mutable_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::Auth::SearchRequest>(GetArena());
    _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(p);
  }
  return _impl_.query_;
}
inline ::SDMS::Auth::SearchRequest* QueryDataReply::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::Auth::SearchRequest* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.QueryDataReply.query)
  return _msg;
}
inline void QueryDataReply::set_allocated_query(::SDMS::Auth::SearchRequest* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::SDMS::Auth::SearchRequest*>(_impl_.query_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.query_ = reinterpret_cast<::SDMS::Auth::SearchRequest*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.QueryDataReply.query)
}

// -------------------------------------------------------------------

// NoteListBySubjectRequest

// required string subject = 1;
inline bool NoteListBySubjectRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NoteListBySubjectRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NoteListBySubjectRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteListBySubjectRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteListBySubjectRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteListBySubjectRequest.subject)
}
inline std::string* NoteListBySubjectRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteListBySubjectRequest.subject)
  return _s;
}
inline const std::string& NoteListBySubjectRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void NoteListBySubjectRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* NoteListBySubjectRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* NoteListBySubjectRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteListBySubjectRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteListBySubjectRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteListBySubjectRequest.subject)
}

// -------------------------------------------------------------------

// NoteViewRequest

// required string id = 1;
inline bool NoteViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NoteViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NoteViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteViewRequest.id)
}
inline std::string* NoteViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteViewRequest.id)
  return _s;
}
inline const std::string& NoteViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void NoteViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NoteViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NoteViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteViewRequest.id)
}

// -------------------------------------------------------------------

// NoteCreateRequest

// required .SDMS.NoteType type = 1;
inline bool NoteCreateRequest::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NoteCreateRequest::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SDMS::NoteType NoteCreateRequest::type() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteCreateRequest.type)
  return _internal_type();
}
inline void NoteCreateRequest::set_type(::SDMS::NoteType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteCreateRequest.type)
}
inline ::SDMS::NoteType NoteCreateRequest::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::NoteType>(_impl_.type_);
}
inline void NoteCreateRequest::_internal_set_type(::SDMS::NoteType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::NoteType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// required string subject = 2;
inline bool NoteCreateRequest::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NoteCreateRequest::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NoteCreateRequest::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteCreateRequest.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteCreateRequest::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteCreateRequest.subject)
}
inline std::string* NoteCreateRequest::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteCreateRequest.subject)
  return _s;
}
inline const std::string& NoteCreateRequest::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void NoteCreateRequest::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* NoteCreateRequest::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* NoteCreateRequest::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteCreateRequest.subject)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.subject_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteCreateRequest::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteCreateRequest.subject)
}

// required string title = 3;
inline bool NoteCreateRequest::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NoteCreateRequest::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NoteCreateRequest::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteCreateRequest.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteCreateRequest::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteCreateRequest.title)
}
inline std::string* NoteCreateRequest::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteCreateRequest.title)
  return _s;
}
inline const std::string& NoteCreateRequest::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void NoteCreateRequest::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* NoteCreateRequest::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* NoteCreateRequest::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteCreateRequest.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteCreateRequest::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteCreateRequest.title)
}

// required string comment = 4;
inline bool NoteCreateRequest::has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NoteCreateRequest::clear_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NoteCreateRequest::comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteCreateRequest.comment)
  return _internal_comment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteCreateRequest::set_comment(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.comment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteCreateRequest.comment)
}
inline std::string* NoteCreateRequest::mutable_comment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteCreateRequest.comment)
  return _s;
}
inline const std::string& NoteCreateRequest::_internal_comment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comment_.Get();
}
inline void NoteCreateRequest::_internal_set_comment(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.comment_.Set(value, GetArena());
}
inline std::string* NoteCreateRequest::_internal_mutable_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.comment_.Mutable( GetArena());
}
inline std::string* NoteCreateRequest::release_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteCreateRequest.comment)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.comment_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteCreateRequest::set_allocated_comment(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.comment_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comment_.IsDefault()) {
          _impl_.comment_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteCreateRequest.comment)
}

// required bool activate = 5;
inline bool NoteCreateRequest::has_activate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NoteCreateRequest::clear_activate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.activate_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool NoteCreateRequest::activate() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteCreateRequest.activate)
  return _internal_activate();
}
inline void NoteCreateRequest::set_activate(bool value) {
  _internal_set_activate(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteCreateRequest.activate)
}
inline bool NoteCreateRequest::_internal_activate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.activate_;
}
inline void NoteCreateRequest::_internal_set_activate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.activate_ = value;
}

// -------------------------------------------------------------------

// NoteUpdateRequest

// required string id = 1;
inline bool NoteUpdateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NoteUpdateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NoteUpdateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteUpdateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteUpdateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteUpdateRequest.id)
}
inline std::string* NoteUpdateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteUpdateRequest.id)
  return _s;
}
inline const std::string& NoteUpdateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void NoteUpdateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NoteUpdateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NoteUpdateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteUpdateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteUpdateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteUpdateRequest.id)
}

// required string comment = 2;
inline bool NoteUpdateRequest::has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NoteUpdateRequest::clear_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NoteUpdateRequest::comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteUpdateRequest.comment)
  return _internal_comment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteUpdateRequest::set_comment(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteUpdateRequest.comment)
}
inline std::string* NoteUpdateRequest::mutable_comment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteUpdateRequest.comment)
  return _s;
}
inline const std::string& NoteUpdateRequest::_internal_comment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comment_.Get();
}
inline void NoteUpdateRequest::_internal_set_comment(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(value, GetArena());
}
inline std::string* NoteUpdateRequest::_internal_mutable_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comment_.Mutable( GetArena());
}
inline std::string* NoteUpdateRequest::release_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteUpdateRequest.comment)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comment_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteUpdateRequest::set_allocated_comment(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comment_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comment_.IsDefault()) {
          _impl_.comment_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteUpdateRequest.comment)
}

// optional .SDMS.NoteType new_type = 3;
inline bool NoteUpdateRequest::has_new_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NoteUpdateRequest::clear_new_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SDMS::NoteType NoteUpdateRequest::new_type() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteUpdateRequest.new_type)
  return _internal_new_type();
}
inline void NoteUpdateRequest::set_new_type(::SDMS::NoteType value) {
  _internal_set_new_type(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteUpdateRequest.new_type)
}
inline ::SDMS::NoteType NoteUpdateRequest::_internal_new_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::NoteType>(_impl_.new_type_);
}
inline void NoteUpdateRequest::_internal_set_new_type(::SDMS::NoteType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::NoteType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.new_type_ = value;
}

// optional .SDMS.NoteState new_state = 4;
inline bool NoteUpdateRequest::has_new_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NoteUpdateRequest::clear_new_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::SDMS::NoteState NoteUpdateRequest::new_state() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteUpdateRequest.new_state)
  return _internal_new_state();
}
inline void NoteUpdateRequest::set_new_state(::SDMS::NoteState value) {
  _internal_set_new_state(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteUpdateRequest.new_state)
}
inline ::SDMS::NoteState NoteUpdateRequest::_internal_new_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::NoteState>(_impl_.new_state_);
}
inline void NoteUpdateRequest::_internal_set_new_state(::SDMS::NoteState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::NoteState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.new_state_ = value;
}

// optional string new_title = 5;
inline bool NoteUpdateRequest::has_new_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NoteUpdateRequest::clear_new_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NoteUpdateRequest::new_title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteUpdateRequest.new_title)
  return _internal_new_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteUpdateRequest::set_new_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.new_title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteUpdateRequest.new_title)
}
inline std::string* NoteUpdateRequest::mutable_new_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_title();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteUpdateRequest.new_title)
  return _s;
}
inline const std::string& NoteUpdateRequest::_internal_new_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_title_.Get();
}
inline void NoteUpdateRequest::_internal_set_new_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.new_title_.Set(value, GetArena());
}
inline std::string* NoteUpdateRequest::_internal_mutable_new_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.new_title_.Mutable( GetArena());
}
inline std::string* NoteUpdateRequest::release_new_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteUpdateRequest.new_title)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.new_title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteUpdateRequest::set_allocated_new_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.new_title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_title_.IsDefault()) {
          _impl_.new_title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteUpdateRequest.new_title)
}

// -------------------------------------------------------------------

// NoteCommentEditRequest

// required string id = 1;
inline bool NoteCommentEditRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NoteCommentEditRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NoteCommentEditRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteCommentEditRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteCommentEditRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteCommentEditRequest.id)
}
inline std::string* NoteCommentEditRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteCommentEditRequest.id)
  return _s;
}
inline const std::string& NoteCommentEditRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void NoteCommentEditRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NoteCommentEditRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NoteCommentEditRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteCommentEditRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteCommentEditRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteCommentEditRequest.id)
}

// required uint32 comment_idx = 2;
inline bool NoteCommentEditRequest::has_comment_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NoteCommentEditRequest::clear_comment_idx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_idx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t NoteCommentEditRequest::comment_idx() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteCommentEditRequest.comment_idx)
  return _internal_comment_idx();
}
inline void NoteCommentEditRequest::set_comment_idx(::uint32_t value) {
  _internal_set_comment_idx(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteCommentEditRequest.comment_idx)
}
inline ::uint32_t NoteCommentEditRequest::_internal_comment_idx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comment_idx_;
}
inline void NoteCommentEditRequest::_internal_set_comment_idx(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.comment_idx_ = value;
}

// required string comment = 3;
inline bool NoteCommentEditRequest::has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NoteCommentEditRequest::clear_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NoteCommentEditRequest::comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteCommentEditRequest.comment)
  return _internal_comment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteCommentEditRequest::set_comment(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.NoteCommentEditRequest.comment)
}
inline std::string* NoteCommentEditRequest::mutable_comment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteCommentEditRequest.comment)
  return _s;
}
inline const std::string& NoteCommentEditRequest::_internal_comment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comment_.Get();
}
inline void NoteCommentEditRequest::_internal_set_comment(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(value, GetArena());
}
inline std::string* NoteCommentEditRequest::_internal_mutable_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comment_.Mutable( GetArena());
}
inline std::string* NoteCommentEditRequest::release_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.NoteCommentEditRequest.comment)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comment_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteCommentEditRequest::set_allocated_comment(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comment_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comment_.IsDefault()) {
          _impl_.comment_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.NoteCommentEditRequest.comment)
}

// -------------------------------------------------------------------

// NoteDataReply

// repeated .SDMS.NoteData note = 1;
inline int NoteDataReply::_internal_note_size() const {
  return _internal_note().size();
}
inline int NoteDataReply::note_size() const {
  return _internal_note_size();
}
inline ::SDMS::NoteData* NoteDataReply::mutable_note(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteDataReply.note)
  return _internal_mutable_note()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::NoteData>* NoteDataReply::mutable_note()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.NoteDataReply.note)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_note();
}
inline const ::SDMS::NoteData& NoteDataReply::note(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteDataReply.note)
  return _internal_note().Get(index);
}
inline ::SDMS::NoteData* NoteDataReply::add_note() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::NoteData* _add = _internal_mutable_note()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.NoteDataReply.note)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::NoteData>& NoteDataReply::note() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.NoteDataReply.note)
  return _internal_note();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::NoteData>&
NoteDataReply::_internal_note() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.note_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::NoteData>*
NoteDataReply::_internal_mutable_note() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.note_;
}

// repeated .SDMS.ListingData update = 2;
inline int NoteDataReply::_internal_update_size() const {
  return _internal_update().size();
}
inline int NoteDataReply::update_size() const {
  return _internal_update_size();
}
inline ::SDMS::ListingData* NoteDataReply::mutable_update(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.NoteDataReply.update)
  return _internal_mutable_update()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* NoteDataReply::mutable_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.NoteDataReply.update)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_update();
}
inline const ::SDMS::ListingData& NoteDataReply::update(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.NoteDataReply.update)
  return _internal_update().Get(index);
}
inline ::SDMS::ListingData* NoteDataReply::add_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::ListingData* _add = _internal_mutable_update()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.NoteDataReply.update)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& NoteDataReply::update() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.NoteDataReply.update)
  return _internal_update();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>&
NoteDataReply::_internal_update() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>*
NoteDataReply::_internal_mutable_update() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.update_;
}

// -------------------------------------------------------------------

// TaskViewRequest

// required string task_id = 1;
inline bool TaskViewRequest::has_task_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TaskViewRequest::clear_task_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TaskViewRequest::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TaskViewRequest.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskViewRequest::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.TaskViewRequest.task_id)
}
inline std::string* TaskViewRequest::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.TaskViewRequest.task_id)
  return _s;
}
inline const std::string& TaskViewRequest::_internal_task_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_id_.Get();
}
inline void TaskViewRequest::_internal_set_task_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* TaskViewRequest::_internal_mutable_task_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* TaskViewRequest::release_task_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.TaskViewRequest.task_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.task_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.task_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TaskViewRequest::set_allocated_task_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.task_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_id_.IsDefault()) {
          _impl_.task_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.TaskViewRequest.task_id)
}

// -------------------------------------------------------------------

// TaskListRequest

// optional uint32 since = 1;
inline bool TaskListRequest::has_since() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TaskListRequest::clear_since() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.since_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TaskListRequest::since() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TaskListRequest.since)
  return _internal_since();
}
inline void TaskListRequest::set_since(::uint32_t value) {
  _internal_set_since(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TaskListRequest.since)
}
inline ::uint32_t TaskListRequest::_internal_since() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.since_;
}
inline void TaskListRequest::_internal_set_since(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.since_ = value;
}

// optional uint32 from = 2;
inline bool TaskListRequest::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TaskListRequest::clear_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TaskListRequest::from() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TaskListRequest.from)
  return _internal_from();
}
inline void TaskListRequest::set_from(::uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TaskListRequest.from)
}
inline ::uint32_t TaskListRequest::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_;
}
inline void TaskListRequest::_internal_set_from(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.from_ = value;
}

// optional uint32 to = 3;
inline bool TaskListRequest::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TaskListRequest::clear_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t TaskListRequest::to() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TaskListRequest.to)
  return _internal_to();
}
inline void TaskListRequest::set_to(::uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TaskListRequest.to)
}
inline ::uint32_t TaskListRequest::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_;
}
inline void TaskListRequest::_internal_set_to(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.to_ = value;
}

// repeated .SDMS.TaskStatus status = 4;
inline int TaskListRequest::_internal_status_size() const {
  return _internal_status().size();
}
inline int TaskListRequest::status_size() const {
  return _internal_status_size();
}
inline void TaskListRequest::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.Clear();
}
inline ::SDMS::TaskStatus TaskListRequest::status(int index) const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TaskListRequest.status)
  return static_cast<::SDMS::TaskStatus>(_internal_status().Get(index));
}
inline void TaskListRequest::set_status(int index, ::SDMS::TaskStatus value) {
  assert(::SDMS::TaskStatus_IsValid(value));
  _internal_mutable_status()->Set(index, value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TaskListRequest.status)
}
inline void TaskListRequest::add_status(::SDMS::TaskStatus value) {
  assert(::SDMS::TaskStatus_IsValid(value));
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_status()->Add(value);
  // @@protoc_insertion_point(field_add:SDMS.Auth.TaskListRequest.status)
}
inline const ::google::protobuf::RepeatedField<int>& TaskListRequest::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.TaskListRequest.status)
  return _internal_status();
}
inline ::google::protobuf::RepeatedField<int>* TaskListRequest::mutable_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.TaskListRequest.status)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_status();
}
inline const ::google::protobuf::RepeatedField<int>& TaskListRequest::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline ::google::protobuf::RepeatedField<int>* TaskListRequest::_internal_mutable_status() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.status_;
}

// optional uint32 offset = 5;
inline bool TaskListRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TaskListRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t TaskListRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TaskListRequest.offset)
  return _internal_offset();
}
inline void TaskListRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TaskListRequest.offset)
}
inline ::uint32_t TaskListRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void TaskListRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.offset_ = value;
}

// optional uint32 count = 6;
inline bool TaskListRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TaskListRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t TaskListRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TaskListRequest.count)
  return _internal_count();
}
inline void TaskListRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TaskListRequest.count)
}
inline ::uint32_t TaskListRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void TaskListRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// TaskDataReply

// repeated .SDMS.TaskData task = 1;
inline int TaskDataReply::_internal_task_size() const {
  return _internal_task().size();
}
inline int TaskDataReply::task_size() const {
  return _internal_task_size();
}
inline ::SDMS::TaskData* TaskDataReply::mutable_task(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.TaskDataReply.task)
  return _internal_mutable_task()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::TaskData>* TaskDataReply::mutable_task()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.TaskDataReply.task)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_task();
}
inline const ::SDMS::TaskData& TaskDataReply::task(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TaskDataReply.task)
  return _internal_task().Get(index);
}
inline ::SDMS::TaskData* TaskDataReply::add_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::TaskData* _add = _internal_mutable_task()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.TaskDataReply.task)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::TaskData>& TaskDataReply::task() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.TaskDataReply.task)
  return _internal_task();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::TaskData>&
TaskDataReply::_internal_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::TaskData>*
TaskDataReply::_internal_mutable_task() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.task_;
}

// -------------------------------------------------------------------

// TagSearchRequest

// optional string name = 1;
inline bool TagSearchRequest::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TagSearchRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TagSearchRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagSearchRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TagSearchRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.TagSearchRequest.name)
}
inline std::string* TagSearchRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.TagSearchRequest.name)
  return _s;
}
inline const std::string& TagSearchRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TagSearchRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TagSearchRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TagSearchRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.TagSearchRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TagSearchRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.TagSearchRequest.name)
}

// optional uint32 offset = 2;
inline bool TagSearchRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TagSearchRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TagSearchRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagSearchRequest.offset)
  return _internal_offset();
}
inline void TagSearchRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TagSearchRequest.offset)
}
inline ::uint32_t TagSearchRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void TagSearchRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool TagSearchRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TagSearchRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t TagSearchRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagSearchRequest.count)
  return _internal_count();
}
inline void TagSearchRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TagSearchRequest.count)
}
inline ::uint32_t TagSearchRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void TagSearchRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// TagListByCountRequest

// optional uint32 offset = 1;
inline bool TagListByCountRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TagListByCountRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TagListByCountRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagListByCountRequest.offset)
  return _internal_offset();
}
inline void TagListByCountRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TagListByCountRequest.offset)
}
inline ::uint32_t TagListByCountRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void TagListByCountRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 2;
inline bool TagListByCountRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TagListByCountRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TagListByCountRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagListByCountRequest.count)
  return _internal_count();
}
inline void TagListByCountRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TagListByCountRequest.count)
}
inline ::uint32_t TagListByCountRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void TagListByCountRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// TagDataReply

// repeated .SDMS.TagData tag = 1;
inline int TagDataReply::_internal_tag_size() const {
  return _internal_tag().size();
}
inline int TagDataReply::tag_size() const {
  return _internal_tag_size();
}
inline ::SDMS::TagData* TagDataReply::mutable_tag(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.TagDataReply.tag)
  return _internal_mutable_tag()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::TagData>* TagDataReply::mutable_tag()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.TagDataReply.tag)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tag();
}
inline const ::SDMS::TagData& TagDataReply::tag(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagDataReply.tag)
  return _internal_tag().Get(index);
}
inline ::SDMS::TagData* TagDataReply::add_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::TagData* _add = _internal_mutable_tag()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.TagDataReply.tag)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::TagData>& TagDataReply::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.TagDataReply.tag)
  return _internal_tag();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::TagData>&
TagDataReply::_internal_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tag_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::TagData>*
TagDataReply::_internal_mutable_tag() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tag_;
}

// optional uint32 offset = 2;
inline bool TagDataReply::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TagDataReply::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TagDataReply::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagDataReply.offset)
  return _internal_offset();
}
inline void TagDataReply::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TagDataReply.offset)
}
inline ::uint32_t TagDataReply::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void TagDataReply::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool TagDataReply::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TagDataReply::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TagDataReply::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagDataReply.count)
  return _internal_count();
}
inline void TagDataReply::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TagDataReply.count)
}
inline ::uint32_t TagDataReply::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void TagDataReply::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// optional uint32 total = 4;
inline bool TagDataReply::has_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TagDataReply::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t TagDataReply::total() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TagDataReply.total)
  return _internal_total();
}
inline void TagDataReply::set_total(::uint32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TagDataReply.total)
}
inline ::uint32_t TagDataReply::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void TagDataReply::_internal_set_total(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// MetadataValidateRequest

// required string metadata = 1;
inline bool MetadataValidateRequest::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MetadataValidateRequest::clear_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MetadataValidateRequest::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.MetadataValidateRequest.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetadataValidateRequest::set_metadata(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.MetadataValidateRequest.metadata)
}
inline std::string* MetadataValidateRequest::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.MetadataValidateRequest.metadata)
  return _s;
}
inline const std::string& MetadataValidateRequest::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_.Get();
}
inline void MetadataValidateRequest::_internal_set_metadata(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metadata_.Set(value, GetArena());
}
inline std::string* MetadataValidateRequest::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.metadata_.Mutable( GetArena());
}
inline std::string* MetadataValidateRequest::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.MetadataValidateRequest.metadata)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.metadata_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.metadata_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MetadataValidateRequest::set_allocated_metadata(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_.IsDefault()) {
          _impl_.metadata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.MetadataValidateRequest.metadata)
}

// required string sch_id = 2;
inline bool MetadataValidateRequest::has_sch_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MetadataValidateRequest::clear_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sch_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MetadataValidateRequest::sch_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.MetadataValidateRequest.sch_id)
  return _internal_sch_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetadataValidateRequest::set_sch_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sch_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.MetadataValidateRequest.sch_id)
}
inline std::string* MetadataValidateRequest::mutable_sch_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sch_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.MetadataValidateRequest.sch_id)
  return _s;
}
inline const std::string& MetadataValidateRequest::_internal_sch_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sch_id_.Get();
}
inline void MetadataValidateRequest::_internal_set_sch_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sch_id_.Set(value, GetArena());
}
inline std::string* MetadataValidateRequest::_internal_mutable_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sch_id_.Mutable( GetArena());
}
inline std::string* MetadataValidateRequest::release_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.MetadataValidateRequest.sch_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.sch_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sch_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MetadataValidateRequest::set_allocated_sch_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sch_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sch_id_.IsDefault()) {
          _impl_.sch_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.MetadataValidateRequest.sch_id)
}

// -------------------------------------------------------------------

// MetadataValidateReply

// optional string errors = 1;
inline bool MetadataValidateReply::has_errors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MetadataValidateReply::clear_errors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errors_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MetadataValidateReply::errors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.MetadataValidateReply.errors)
  return _internal_errors();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetadataValidateReply::set_errors(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errors_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.MetadataValidateReply.errors)
}
inline std::string* MetadataValidateReply::mutable_errors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_errors();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.MetadataValidateReply.errors)
  return _s;
}
inline const std::string& MetadataValidateReply::_internal_errors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.errors_.Get();
}
inline void MetadataValidateReply::_internal_set_errors(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errors_.Set(value, GetArena());
}
inline std::string* MetadataValidateReply::_internal_mutable_errors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errors_.Mutable( GetArena());
}
inline std::string* MetadataValidateReply::release_errors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.MetadataValidateReply.errors)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.errors_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.errors_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MetadataValidateReply::set_allocated_errors(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errors_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errors_.IsDefault()) {
          _impl_.errors_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.MetadataValidateReply.errors)
}

// -------------------------------------------------------------------

// SchemaViewRequest

// required string id = 1;
inline bool SchemaViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaViewRequest.id)
}
inline std::string* SchemaViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaViewRequest.id)
  return _s;
}
inline const std::string& SchemaViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void SchemaViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SchemaViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SchemaViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaViewRequest.id)
}

// optional bool resolve = 2;
inline bool SchemaViewRequest::has_resolve() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchemaViewRequest::clear_resolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resolve_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SchemaViewRequest::resolve() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaViewRequest.resolve)
  return _internal_resolve();
}
inline void SchemaViewRequest::set_resolve(bool value) {
  _internal_set_resolve(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaViewRequest.resolve)
}
inline bool SchemaViewRequest::_internal_resolve() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resolve_;
}
inline void SchemaViewRequest::_internal_set_resolve(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resolve_ = value;
}

// -------------------------------------------------------------------

// SchemaSearchRequest

// optional string id = 1;
inline bool SchemaSearchRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaSearchRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaSearchRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaSearchRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaSearchRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaSearchRequest.id)
}
inline std::string* SchemaSearchRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaSearchRequest.id)
  return _s;
}
inline const std::string& SchemaSearchRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void SchemaSearchRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SchemaSearchRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SchemaSearchRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaSearchRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaSearchRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaSearchRequest.id)
}

// optional string text = 2;
inline bool SchemaSearchRequest::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchemaSearchRequest::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaSearchRequest::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaSearchRequest.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaSearchRequest::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaSearchRequest.text)
}
inline std::string* SchemaSearchRequest::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaSearchRequest.text)
  return _s;
}
inline const std::string& SchemaSearchRequest::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void SchemaSearchRequest::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* SchemaSearchRequest::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* SchemaSearchRequest::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaSearchRequest.text)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.text_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaSearchRequest::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaSearchRequest.text)
}

// optional string owner = 3;
inline bool SchemaSearchRequest::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchemaSearchRequest::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SchemaSearchRequest::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaSearchRequest.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaSearchRequest::set_owner(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaSearchRequest.owner)
}
inline std::string* SchemaSearchRequest::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaSearchRequest.owner)
  return _s;
}
inline const std::string& SchemaSearchRequest::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_.Get();
}
inline void SchemaSearchRequest::_internal_set_owner(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owner_.Set(value, GetArena());
}
inline std::string* SchemaSearchRequest::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.owner_.Mutable( GetArena());
}
inline std::string* SchemaSearchRequest::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaSearchRequest.owner)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaSearchRequest::set_allocated_owner(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaSearchRequest.owner)
}

// optional .SDMS.SortOption sort = 4;
inline bool SchemaSearchRequest::has_sort() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchemaSearchRequest::clear_sort() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sort_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SDMS::SortOption SchemaSearchRequest::sort() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaSearchRequest.sort)
  return _internal_sort();
}
inline void SchemaSearchRequest::set_sort(::SDMS::SortOption value) {
  _internal_set_sort(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaSearchRequest.sort)
}
inline ::SDMS::SortOption SchemaSearchRequest::_internal_sort() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::SortOption>(_impl_.sort_);
}
inline void SchemaSearchRequest::_internal_set_sort(::SDMS::SortOption value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::SortOption_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sort_ = value;
}

// optional bool sort_rev = 5;
inline bool SchemaSearchRequest::has_sort_rev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchemaSearchRequest::clear_sort_rev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sort_rev_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SchemaSearchRequest::sort_rev() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaSearchRequest.sort_rev)
  return _internal_sort_rev();
}
inline void SchemaSearchRequest::set_sort_rev(bool value) {
  _internal_set_sort_rev(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaSearchRequest.sort_rev)
}
inline bool SchemaSearchRequest::_internal_sort_rev() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sort_rev_;
}
inline void SchemaSearchRequest::_internal_set_sort_rev(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sort_rev_ = value;
}

// optional uint32 offset = 6;
inline bool SchemaSearchRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SchemaSearchRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t SchemaSearchRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaSearchRequest.offset)
  return _internal_offset();
}
inline void SchemaSearchRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaSearchRequest.offset)
}
inline ::uint32_t SchemaSearchRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void SchemaSearchRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.offset_ = value;
}

// optional uint32 count = 7;
inline bool SchemaSearchRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SchemaSearchRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t SchemaSearchRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaSearchRequest.count)
  return _internal_count();
}
inline void SchemaSearchRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaSearchRequest.count)
}
inline ::uint32_t SchemaSearchRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void SchemaSearchRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// SchemaDataReply

// repeated .SDMS.SchemaData schema = 1;
inline int SchemaDataReply::_internal_schema_size() const {
  return _internal_schema().size();
}
inline int SchemaDataReply::schema_size() const {
  return _internal_schema_size();
}
inline ::SDMS::SchemaData* SchemaDataReply::mutable_schema(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaDataReply.schema)
  return _internal_mutable_schema()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>* SchemaDataReply::mutable_schema()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.SchemaDataReply.schema)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_schema();
}
inline const ::SDMS::SchemaData& SchemaDataReply::schema(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaDataReply.schema)
  return _internal_schema().Get(index);
}
inline ::SDMS::SchemaData* SchemaDataReply::add_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::SchemaData* _add = _internal_mutable_schema()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.SchemaDataReply.schema)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>& SchemaDataReply::schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.SchemaDataReply.schema)
  return _internal_schema();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>&
SchemaDataReply::_internal_schema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>*
SchemaDataReply::_internal_mutable_schema() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.schema_;
}

// optional uint32 offset = 2;
inline bool SchemaDataReply::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaDataReply::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t SchemaDataReply::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaDataReply.offset)
  return _internal_offset();
}
inline void SchemaDataReply::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaDataReply.offset)
}
inline ::uint32_t SchemaDataReply::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void SchemaDataReply::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool SchemaDataReply::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchemaDataReply::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t SchemaDataReply::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaDataReply.count)
  return _internal_count();
}
inline void SchemaDataReply::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaDataReply.count)
}
inline ::uint32_t SchemaDataReply::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void SchemaDataReply::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// optional uint32 total = 4;
inline bool SchemaDataReply::has_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchemaDataReply::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t SchemaDataReply::total() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaDataReply.total)
  return _internal_total();
}
inline void SchemaDataReply::set_total(::uint32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaDataReply.total)
}
inline ::uint32_t SchemaDataReply::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void SchemaDataReply::_internal_set_total(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// SchemaCreateRequest

// required string id = 1;
inline bool SchemaCreateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaCreateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaCreateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaCreateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaCreateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaCreateRequest.id)
}
inline std::string* SchemaCreateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaCreateRequest.id)
  return _s;
}
inline const std::string& SchemaCreateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void SchemaCreateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SchemaCreateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SchemaCreateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaCreateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaCreateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaCreateRequest.id)
}

// required string desc = 2;
inline bool SchemaCreateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchemaCreateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaCreateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaCreateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaCreateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaCreateRequest.desc)
}
inline std::string* SchemaCreateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaCreateRequest.desc)
  return _s;
}
inline const std::string& SchemaCreateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void SchemaCreateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* SchemaCreateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* SchemaCreateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaCreateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaCreateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaCreateRequest.desc)
}

// required bool pub = 3;
inline bool SchemaCreateRequest::has_pub() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchemaCreateRequest::clear_pub() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pub_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool SchemaCreateRequest::pub() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaCreateRequest.pub)
  return _internal_pub();
}
inline void SchemaCreateRequest::set_pub(bool value) {
  _internal_set_pub(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaCreateRequest.pub)
}
inline bool SchemaCreateRequest::_internal_pub() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pub_;
}
inline void SchemaCreateRequest::_internal_set_pub(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pub_ = value;
}

// required bool sys = 4;
inline bool SchemaCreateRequest::has_sys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchemaCreateRequest::clear_sys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sys_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SchemaCreateRequest::sys() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaCreateRequest.sys)
  return _internal_sys();
}
inline void SchemaCreateRequest::set_sys(bool value) {
  _internal_set_sys(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaCreateRequest.sys)
}
inline bool SchemaCreateRequest::_internal_sys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sys_;
}
inline void SchemaCreateRequest::_internal_set_sys(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sys_ = value;
}

// required string def = 5;
inline bool SchemaCreateRequest::has_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchemaCreateRequest::clear_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.def_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SchemaCreateRequest::def() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaCreateRequest.def)
  return _internal_def();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaCreateRequest::set_def(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.def_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaCreateRequest.def)
}
inline std::string* SchemaCreateRequest::mutable_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_def();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaCreateRequest.def)
  return _s;
}
inline const std::string& SchemaCreateRequest::_internal_def() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.def_.Get();
}
inline void SchemaCreateRequest::_internal_set_def(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.def_.Set(value, GetArena());
}
inline std::string* SchemaCreateRequest::_internal_mutable_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.def_.Mutable( GetArena());
}
inline std::string* SchemaCreateRequest::release_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaCreateRequest.def)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.def_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.def_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaCreateRequest::set_allocated_def(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.def_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.def_.IsDefault()) {
          _impl_.def_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaCreateRequest.def)
}

// -------------------------------------------------------------------

// SchemaUpdateRequest

// required string id = 1;
inline bool SchemaUpdateRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaUpdateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaUpdateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaUpdateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaUpdateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaUpdateRequest.id)
}
inline std::string* SchemaUpdateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaUpdateRequest.id)
  return _s;
}
inline const std::string& SchemaUpdateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void SchemaUpdateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SchemaUpdateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SchemaUpdateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaUpdateRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaUpdateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaUpdateRequest.id)
}

// optional string id_new = 2;
inline bool SchemaUpdateRequest::has_id_new() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchemaUpdateRequest::clear_id_new() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_new_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaUpdateRequest::id_new() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaUpdateRequest.id_new)
  return _internal_id_new();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaUpdateRequest::set_id_new(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_new_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaUpdateRequest.id_new)
}
inline std::string* SchemaUpdateRequest::mutable_id_new() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id_new();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaUpdateRequest.id_new)
  return _s;
}
inline const std::string& SchemaUpdateRequest::_internal_id_new() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_new_.Get();
}
inline void SchemaUpdateRequest::_internal_set_id_new(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_new_.Set(value, GetArena());
}
inline std::string* SchemaUpdateRequest::_internal_mutable_id_new() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.id_new_.Mutable( GetArena());
}
inline std::string* SchemaUpdateRequest::release_id_new() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaUpdateRequest.id_new)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.id_new_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_new_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaUpdateRequest::set_allocated_id_new(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.id_new_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_new_.IsDefault()) {
          _impl_.id_new_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaUpdateRequest.id_new)
}

// optional string desc = 3;
inline bool SchemaUpdateRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchemaUpdateRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SchemaUpdateRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaUpdateRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaUpdateRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaUpdateRequest.desc)
}
inline std::string* SchemaUpdateRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaUpdateRequest.desc)
  return _s;
}
inline const std::string& SchemaUpdateRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void SchemaUpdateRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* SchemaUpdateRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* SchemaUpdateRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaUpdateRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaUpdateRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaUpdateRequest.desc)
}

// optional bool pub = 4;
inline bool SchemaUpdateRequest::has_pub() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchemaUpdateRequest::clear_pub() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pub_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SchemaUpdateRequest::pub() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaUpdateRequest.pub)
  return _internal_pub();
}
inline void SchemaUpdateRequest::set_pub(bool value) {
  _internal_set_pub(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaUpdateRequest.pub)
}
inline bool SchemaUpdateRequest::_internal_pub() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pub_;
}
inline void SchemaUpdateRequest::_internal_set_pub(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pub_ = value;
}

// optional bool sys = 5;
inline bool SchemaUpdateRequest::has_sys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SchemaUpdateRequest::clear_sys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sys_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SchemaUpdateRequest::sys() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaUpdateRequest.sys)
  return _internal_sys();
}
inline void SchemaUpdateRequest::set_sys(bool value) {
  _internal_set_sys(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaUpdateRequest.sys)
}
inline bool SchemaUpdateRequest::_internal_sys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sys_;
}
inline void SchemaUpdateRequest::_internal_set_sys(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sys_ = value;
}

// optional string def = 6;
inline bool SchemaUpdateRequest::has_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchemaUpdateRequest::clear_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.def_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SchemaUpdateRequest::def() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaUpdateRequest.def)
  return _internal_def();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaUpdateRequest::set_def(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.def_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaUpdateRequest.def)
}
inline std::string* SchemaUpdateRequest::mutable_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_def();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaUpdateRequest.def)
  return _s;
}
inline const std::string& SchemaUpdateRequest::_internal_def() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.def_.Get();
}
inline void SchemaUpdateRequest::_internal_set_def(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.def_.Set(value, GetArena());
}
inline std::string* SchemaUpdateRequest::_internal_mutable_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.def_.Mutable( GetArena());
}
inline std::string* SchemaUpdateRequest::release_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaUpdateRequest.def)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.def_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.def_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaUpdateRequest::set_allocated_def(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.def_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.def_.IsDefault()) {
          _impl_.def_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaUpdateRequest.def)
}

// -------------------------------------------------------------------

// SchemaReviseRequest

// required string id = 1;
inline bool SchemaReviseRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaReviseRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaReviseRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaReviseRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaReviseRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaReviseRequest.id)
}
inline std::string* SchemaReviseRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaReviseRequest.id)
  return _s;
}
inline const std::string& SchemaReviseRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void SchemaReviseRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SchemaReviseRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SchemaReviseRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaReviseRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaReviseRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaReviseRequest.id)
}

// optional string desc = 2;
inline bool SchemaReviseRequest::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchemaReviseRequest::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaReviseRequest::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaReviseRequest.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaReviseRequest::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaReviseRequest.desc)
}
inline std::string* SchemaReviseRequest::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaReviseRequest.desc)
  return _s;
}
inline const std::string& SchemaReviseRequest::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void SchemaReviseRequest::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* SchemaReviseRequest::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* SchemaReviseRequest::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaReviseRequest.desc)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaReviseRequest::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaReviseRequest.desc)
}

// optional bool pub = 3;
inline bool SchemaReviseRequest::has_pub() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchemaReviseRequest::clear_pub() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pub_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool SchemaReviseRequest::pub() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaReviseRequest.pub)
  return _internal_pub();
}
inline void SchemaReviseRequest::set_pub(bool value) {
  _internal_set_pub(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaReviseRequest.pub)
}
inline bool SchemaReviseRequest::_internal_pub() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pub_;
}
inline void SchemaReviseRequest::_internal_set_pub(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pub_ = value;
}

// optional bool sys = 4;
inline bool SchemaReviseRequest::has_sys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchemaReviseRequest::clear_sys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sys_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SchemaReviseRequest::sys() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaReviseRequest.sys)
  return _internal_sys();
}
inline void SchemaReviseRequest::set_sys(bool value) {
  _internal_set_sys(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaReviseRequest.sys)
}
inline bool SchemaReviseRequest::_internal_sys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sys_;
}
inline void SchemaReviseRequest::_internal_set_sys(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sys_ = value;
}

// optional string def = 5;
inline bool SchemaReviseRequest::has_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchemaReviseRequest::clear_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.def_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SchemaReviseRequest::def() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaReviseRequest.def)
  return _internal_def();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaReviseRequest::set_def(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.def_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaReviseRequest.def)
}
inline std::string* SchemaReviseRequest::mutable_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_def();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaReviseRequest.def)
  return _s;
}
inline const std::string& SchemaReviseRequest::_internal_def() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.def_.Get();
}
inline void SchemaReviseRequest::_internal_set_def(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.def_.Set(value, GetArena());
}
inline std::string* SchemaReviseRequest::_internal_mutable_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.def_.Mutable( GetArena());
}
inline std::string* SchemaReviseRequest::release_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaReviseRequest.def)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.def_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.def_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaReviseRequest::set_allocated_def(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.def_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.def_.IsDefault()) {
          _impl_.def_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaReviseRequest.def)
}

// -------------------------------------------------------------------

// SchemaDeleteRequest

// required string id = 1;
inline bool SchemaDeleteRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaDeleteRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaDeleteRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.SchemaDeleteRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaDeleteRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.SchemaDeleteRequest.id)
}
inline std::string* SchemaDeleteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.SchemaDeleteRequest.id)
  return _s;
}
inline const std::string& SchemaDeleteRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void SchemaDeleteRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SchemaDeleteRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SchemaDeleteRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.SchemaDeleteRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaDeleteRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.SchemaDeleteRequest.id)
}

// -------------------------------------------------------------------

// TopicListTopicsRequest

// optional string topic_id = 1;
inline bool TopicListTopicsRequest::has_topic_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TopicListTopicsRequest::clear_topic_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TopicListTopicsRequest::topic_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicListTopicsRequest.topic_id)
  return _internal_topic_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TopicListTopicsRequest::set_topic_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.TopicListTopicsRequest.topic_id)
}
inline std::string* TopicListTopicsRequest::mutable_topic_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.TopicListTopicsRequest.topic_id)
  return _s;
}
inline const std::string& TopicListTopicsRequest::_internal_topic_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_id_.Get();
}
inline void TopicListTopicsRequest::_internal_set_topic_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_id_.Set(value, GetArena());
}
inline std::string* TopicListTopicsRequest::_internal_mutable_topic_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_id_.Mutable( GetArena());
}
inline std::string* TopicListTopicsRequest::release_topic_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.TopicListTopicsRequest.topic_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TopicListTopicsRequest::set_allocated_topic_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_id_.IsDefault()) {
          _impl_.topic_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.TopicListTopicsRequest.topic_id)
}

// optional uint32 offset = 2;
inline bool TopicListTopicsRequest::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TopicListTopicsRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TopicListTopicsRequest::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicListTopicsRequest.offset)
  return _internal_offset();
}
inline void TopicListTopicsRequest::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TopicListTopicsRequest.offset)
}
inline ::uint32_t TopicListTopicsRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void TopicListTopicsRequest::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool TopicListTopicsRequest::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TopicListTopicsRequest::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t TopicListTopicsRequest::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicListTopicsRequest.count)
  return _internal_count();
}
inline void TopicListTopicsRequest::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TopicListTopicsRequest.count)
}
inline ::uint32_t TopicListTopicsRequest::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void TopicListTopicsRequest::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// TopicViewRequest

// required string id = 1;
inline bool TopicViewRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TopicViewRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TopicViewRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicViewRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TopicViewRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.TopicViewRequest.id)
}
inline std::string* TopicViewRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.TopicViewRequest.id)
  return _s;
}
inline const std::string& TopicViewRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void TopicViewRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* TopicViewRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* TopicViewRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.TopicViewRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TopicViewRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.TopicViewRequest.id)
}

// -------------------------------------------------------------------

// TopicSearchRequest

// optional string phrase = 1;
inline bool TopicSearchRequest::has_phrase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TopicSearchRequest::clear_phrase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phrase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TopicSearchRequest::phrase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicSearchRequest.phrase)
  return _internal_phrase();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TopicSearchRequest::set_phrase(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phrase_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.Auth.TopicSearchRequest.phrase)
}
inline std::string* TopicSearchRequest::mutable_phrase() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phrase();
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.TopicSearchRequest.phrase)
  return _s;
}
inline const std::string& TopicSearchRequest::_internal_phrase() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phrase_.Get();
}
inline void TopicSearchRequest::_internal_set_phrase(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phrase_.Set(value, GetArena());
}
inline std::string* TopicSearchRequest::_internal_mutable_phrase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phrase_.Mutable( GetArena());
}
inline std::string* TopicSearchRequest::release_phrase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.Auth.TopicSearchRequest.phrase)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.phrase_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phrase_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TopicSearchRequest::set_allocated_phrase(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phrase_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phrase_.IsDefault()) {
          _impl_.phrase_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.Auth.TopicSearchRequest.phrase)
}

// -------------------------------------------------------------------

// TopicDataReply

// repeated .SDMS.TopicData topic = 1;
inline int TopicDataReply::_internal_topic_size() const {
  return _internal_topic().size();
}
inline int TopicDataReply::topic_size() const {
  return _internal_topic_size();
}
inline ::SDMS::TopicData* TopicDataReply::mutable_topic(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.Auth.TopicDataReply.topic)
  return _internal_mutable_topic()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>* TopicDataReply::mutable_topic()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.Auth.TopicDataReply.topic)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_topic();
}
inline const ::SDMS::TopicData& TopicDataReply::topic(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicDataReply.topic)
  return _internal_topic().Get(index);
}
inline ::SDMS::TopicData* TopicDataReply::add_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::TopicData* _add = _internal_mutable_topic()->Add();
  // @@protoc_insertion_point(field_add:SDMS.Auth.TopicDataReply.topic)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>& TopicDataReply::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.Auth.TopicDataReply.topic)
  return _internal_topic();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>&
TopicDataReply::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>*
TopicDataReply::_internal_mutable_topic() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.topic_;
}

// optional uint32 offset = 2;
inline bool TopicDataReply::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TopicDataReply::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TopicDataReply::offset() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicDataReply.offset)
  return _internal_offset();
}
inline void TopicDataReply::set_offset(::uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TopicDataReply.offset)
}
inline ::uint32_t TopicDataReply::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void TopicDataReply::_internal_set_offset(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// optional uint32 count = 3;
inline bool TopicDataReply::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TopicDataReply::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TopicDataReply::count() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicDataReply.count)
  return _internal_count();
}
inline void TopicDataReply::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TopicDataReply.count)
}
inline ::uint32_t TopicDataReply::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void TopicDataReply::_internal_set_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// optional uint32 total = 4;
inline bool TopicDataReply::has_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TopicDataReply::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t TopicDataReply::total() const {
  // @@protoc_insertion_point(field_get:SDMS.Auth.TopicDataReply.total)
  return _internal_total();
}
inline void TopicDataReply::set_total(::uint32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:SDMS.Auth.TopicDataReply.total)
}
inline ::uint32_t TopicDataReply::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void TopicDataReply::_internal_set_total(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Auth
}  // namespace SDMS


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::SDMS::Auth::Protocol> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::Auth::Protocol>() {
  return ::SDMS::Auth::Protocol_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_SDMS_5fAuth_2eproto_2epb_2eh
