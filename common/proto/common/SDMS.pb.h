// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SDMS.proto
// Protobuf C++ Version: 4.25.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_SDMS_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_SDMS_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_SDMS_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_SDMS_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_SDMS_2eproto;
namespace SDMS {
class ACLRule;
struct ACLRuleDefaultTypeInternal;
extern ACLRuleDefaultTypeInternal _ACLRule_default_instance_;
class AllocData;
struct AllocDataDefaultTypeInternal;
extern AllocDataDefaultTypeInternal _AllocData_default_instance_;
class AllocStatsData;
struct AllocStatsDataDefaultTypeInternal;
extern AllocStatsDataDefaultTypeInternal _AllocStatsData_default_instance_;
class CollData;
struct CollDataDefaultTypeInternal;
extern CollDataDefaultTypeInternal _CollData_default_instance_;
class DependencyData;
struct DependencyDataDefaultTypeInternal;
extern DependencyDataDefaultTypeInternal _DependencyData_default_instance_;
class DependencySpecData;
struct DependencySpecDataDefaultTypeInternal;
extern DependencySpecDataDefaultTypeInternal _DependencySpecData_default_instance_;
class GroupData;
struct GroupDataDefaultTypeInternal;
extern GroupDataDefaultTypeInternal _GroupData_default_instance_;
class ListingData;
struct ListingDataDefaultTypeInternal;
extern ListingDataDefaultTypeInternal _ListingData_default_instance_;
class NoteComment;
struct NoteCommentDefaultTypeInternal;
extern NoteCommentDefaultTypeInternal _NoteComment_default_instance_;
class NoteData;
struct NoteDataDefaultTypeInternal;
extern NoteDataDefaultTypeInternal _NoteData_default_instance_;
class PathData;
struct PathDataDefaultTypeInternal;
extern PathDataDefaultTypeInternal _PathData_default_instance_;
class ProjectData;
struct ProjectDataDefaultTypeInternal;
extern ProjectDataDefaultTypeInternal _ProjectData_default_instance_;
class RecordData;
struct RecordDataDefaultTypeInternal;
extern RecordDataDefaultTypeInternal _RecordData_default_instance_;
class RecordDataLocation;
struct RecordDataLocationDefaultTypeInternal;
extern RecordDataLocationDefaultTypeInternal _RecordDataLocation_default_instance_;
class RecordDataSize;
struct RecordDataSizeDefaultTypeInternal;
extern RecordDataSizeDefaultTypeInternal _RecordDataSize_default_instance_;
class RepoData;
struct RepoDataDefaultTypeInternal;
extern RepoDataDefaultTypeInternal _RepoData_default_instance_;
class RepoRecordDataLocations;
struct RepoRecordDataLocationsDefaultTypeInternal;
extern RepoRecordDataLocationsDefaultTypeInternal _RepoRecordDataLocations_default_instance_;
class SchemaData;
struct SchemaDataDefaultTypeInternal;
extern SchemaDataDefaultTypeInternal _SchemaData_default_instance_;
class TagData;
struct TagDataDefaultTypeInternal;
extern TagDataDefaultTypeInternal _TagData_default_instance_;
class TaskData;
struct TaskDataDefaultTypeInternal;
extern TaskDataDefaultTypeInternal _TaskData_default_instance_;
class TopicData;
struct TopicDataDefaultTypeInternal;
extern TopicDataDefaultTypeInternal _TopicData_default_instance_;
class UserData;
struct UserDataDefaultTypeInternal;
extern UserDataDefaultTypeInternal _UserData_default_instance_;
}  // namespace SDMS
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace SDMS {
enum ErrorCode : int {
  ID_BAD_REQUEST = 1,
  ID_INTERNAL_ERROR = 2,
  ID_CLIENT_ERROR = 3,
  ID_SERVICE_ERROR = 4,
  ID_AUTHN_REQUIRED = 5,
  ID_AUTHN_ERROR = 6,
  ID_DEST_PATH_ERROR = 7,
  ID_DEST_FILE_ERROR = 8,
};

bool ErrorCode_IsValid(int value);
extern const uint32_t ErrorCode_internal_data_[];
constexpr ErrorCode ErrorCode_MIN = static_cast<ErrorCode>(1);
constexpr ErrorCode ErrorCode_MAX = static_cast<ErrorCode>(8);
constexpr int ErrorCode_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorCode_descriptor();
template <typename T>
const std::string& ErrorCode_Name(T value) {
  static_assert(std::is_same<T, ErrorCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorCode_Name().");
  return ErrorCode_Name(static_cast<ErrorCode>(value));
}
template <>
inline const std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorCode_descriptor,
                                                 1, 8>(
      static_cast<int>(value));
}
inline bool ErrorCode_Parse(absl::string_view name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
      ErrorCode_descriptor(), name, value);
}
enum ServiceStatus : int {
  SS_NORMAL = 0,
  SS_DEGRADED = 1,
  SS_FAILED = 2,
  SS_OFFLINE = 3,
};

bool ServiceStatus_IsValid(int value);
extern const uint32_t ServiceStatus_internal_data_[];
constexpr ServiceStatus ServiceStatus_MIN = static_cast<ServiceStatus>(0);
constexpr ServiceStatus ServiceStatus_MAX = static_cast<ServiceStatus>(3);
constexpr int ServiceStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ServiceStatus_descriptor();
template <typename T>
const std::string& ServiceStatus_Name(T value) {
  static_assert(std::is_same<T, ServiceStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ServiceStatus_Name().");
  return ServiceStatus_Name(static_cast<ServiceStatus>(value));
}
template <>
inline const std::string& ServiceStatus_Name(ServiceStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ServiceStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ServiceStatus_Parse(absl::string_view name, ServiceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceStatus>(
      ServiceStatus_descriptor(), name, value);
}
enum SearchMode : int {
  SM_DATA = 0,
  SM_COLLECTION = 1,
};

bool SearchMode_IsValid(int value);
extern const uint32_t SearchMode_internal_data_[];
constexpr SearchMode SearchMode_MIN = static_cast<SearchMode>(0);
constexpr SearchMode SearchMode_MAX = static_cast<SearchMode>(1);
constexpr int SearchMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
SearchMode_descriptor();
template <typename T>
const std::string& SearchMode_Name(T value) {
  static_assert(std::is_same<T, SearchMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SearchMode_Name().");
  return SearchMode_Name(static_cast<SearchMode>(value));
}
template <>
inline const std::string& SearchMode_Name(SearchMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SearchMode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SearchMode_Parse(absl::string_view name, SearchMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchMode>(
      SearchMode_descriptor(), name, value);
}
enum DependencyType : int {
  DEP_IS_DERIVED_FROM = 0,
  DEP_IS_COMPONENT_OF = 1,
  DEP_IS_NEW_VERSION_OF = 2,
  DEP_TYPE_COUNT = 3,
};

bool DependencyType_IsValid(int value);
extern const uint32_t DependencyType_internal_data_[];
constexpr DependencyType DependencyType_MIN = static_cast<DependencyType>(0);
constexpr DependencyType DependencyType_MAX = static_cast<DependencyType>(3);
constexpr int DependencyType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DependencyType_descriptor();
template <typename T>
const std::string& DependencyType_Name(T value) {
  static_assert(std::is_same<T, DependencyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DependencyType_Name().");
  return DependencyType_Name(static_cast<DependencyType>(value));
}
template <>
inline const std::string& DependencyType_Name(DependencyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DependencyType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DependencyType_Parse(absl::string_view name, DependencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DependencyType>(
      DependencyType_descriptor(), name, value);
}
enum DependencyDir : int {
  DEP_IN = 0,
  DEP_OUT = 1,
};

bool DependencyDir_IsValid(int value);
extern const uint32_t DependencyDir_internal_data_[];
constexpr DependencyDir DependencyDir_MIN = static_cast<DependencyDir>(0);
constexpr DependencyDir DependencyDir_MAX = static_cast<DependencyDir>(1);
constexpr int DependencyDir_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
DependencyDir_descriptor();
template <typename T>
const std::string& DependencyDir_Name(T value) {
  static_assert(std::is_same<T, DependencyDir>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DependencyDir_Name().");
  return DependencyDir_Name(static_cast<DependencyDir>(value));
}
template <>
inline const std::string& DependencyDir_Name(DependencyDir value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DependencyDir_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool DependencyDir_Parse(absl::string_view name, DependencyDir* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DependencyDir>(
      DependencyDir_descriptor(), name, value);
}
enum SortOption : int {
  SORT_ID = 0,
  SORT_TITLE = 1,
  SORT_OWNER = 2,
  SORT_TIME_CREATE = 3,
  SORT_TIME_UPDATE = 4,
  SORT_RELEVANCE = 5,
};

bool SortOption_IsValid(int value);
extern const uint32_t SortOption_internal_data_[];
constexpr SortOption SortOption_MIN = static_cast<SortOption>(0);
constexpr SortOption SortOption_MAX = static_cast<SortOption>(5);
constexpr int SortOption_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
SortOption_descriptor();
template <typename T>
const std::string& SortOption_Name(T value) {
  static_assert(std::is_same<T, SortOption>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SortOption_Name().");
  return SortOption_Name(static_cast<SortOption>(value));
}
template <>
inline const std::string& SortOption_Name(SortOption value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SortOption_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool SortOption_Parse(absl::string_view name, SortOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SortOption>(
      SortOption_descriptor(), name, value);
}
enum ProjectRole : int {
  PROJ_NO_ROLE = 0,
  PROJ_MEMBER = 1,
  PROJ_MANAGER = 2,
  PROJ_ADMIN = 3,
};

bool ProjectRole_IsValid(int value);
extern const uint32_t ProjectRole_internal_data_[];
constexpr ProjectRole ProjectRole_MIN = static_cast<ProjectRole>(0);
constexpr ProjectRole ProjectRole_MAX = static_cast<ProjectRole>(3);
constexpr int ProjectRole_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ProjectRole_descriptor();
template <typename T>
const std::string& ProjectRole_Name(T value) {
  static_assert(std::is_same<T, ProjectRole>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProjectRole_Name().");
  return ProjectRole_Name(static_cast<ProjectRole>(value));
}
template <>
inline const std::string& ProjectRole_Name(ProjectRole value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProjectRole_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ProjectRole_Parse(absl::string_view name, ProjectRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProjectRole>(
      ProjectRole_descriptor(), name, value);
}
enum NoteType : int {
  NOTE_QUESTION = 0,
  NOTE_INFO = 1,
  NOTE_WARN = 2,
  NOTE_ERROR = 3,
};

bool NoteType_IsValid(int value);
extern const uint32_t NoteType_internal_data_[];
constexpr NoteType NoteType_MIN = static_cast<NoteType>(0);
constexpr NoteType NoteType_MAX = static_cast<NoteType>(3);
constexpr int NoteType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
NoteType_descriptor();
template <typename T>
const std::string& NoteType_Name(T value) {
  static_assert(std::is_same<T, NoteType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NoteType_Name().");
  return NoteType_Name(static_cast<NoteType>(value));
}
template <>
inline const std::string& NoteType_Name(NoteType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NoteType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool NoteType_Parse(absl::string_view name, NoteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NoteType>(
      NoteType_descriptor(), name, value);
}
enum NoteState : int {
  NOTE_CLOSED = 0,
  NOTE_OPEN = 1,
  NOTE_ACTIVE = 2,
};

bool NoteState_IsValid(int value);
extern const uint32_t NoteState_internal_data_[];
constexpr NoteState NoteState_MIN = static_cast<NoteState>(0);
constexpr NoteState NoteState_MAX = static_cast<NoteState>(2);
constexpr int NoteState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
NoteState_descriptor();
template <typename T>
const std::string& NoteState_Name(T value) {
  static_assert(std::is_same<T, NoteState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NoteState_Name().");
  return NoteState_Name(static_cast<NoteState>(value));
}
template <>
inline const std::string& NoteState_Name(NoteState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NoteState_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool NoteState_Parse(absl::string_view name, NoteState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NoteState>(
      NoteState_descriptor(), name, value);
}
enum TaskType : int {
  TT_DATA_GET = 0,
  TT_DATA_PUT = 1,
  TT_DATA_DEL = 2,
  TT_REC_CHG_ALLOC = 3,
  TT_REC_CHG_OWNER = 4,
  TT_REC_DEL = 5,
  TT_ALLOC_CREATE = 6,
  TT_ALLOC_DEL = 7,
  TT_USER_DEL = 8,
  TT_PROJ_DEL = 9,
};

bool TaskType_IsValid(int value);
extern const uint32_t TaskType_internal_data_[];
constexpr TaskType TaskType_MIN = static_cast<TaskType>(0);
constexpr TaskType TaskType_MAX = static_cast<TaskType>(9);
constexpr int TaskType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
TaskType_descriptor();
template <typename T>
const std::string& TaskType_Name(T value) {
  static_assert(std::is_same<T, TaskType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskType_Name().");
  return TaskType_Name(static_cast<TaskType>(value));
}
template <>
inline const std::string& TaskType_Name(TaskType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskType_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool TaskType_Parse(absl::string_view name, TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskType>(
      TaskType_descriptor(), name, value);
}
enum TaskStatus : int {
  TS_BLOCKED = 0,
  TS_READY = 1,
  TS_RUNNING = 2,
  TS_SUCCEEDED = 3,
  TS_FAILED = 4,
};

bool TaskStatus_IsValid(int value);
extern const uint32_t TaskStatus_internal_data_[];
constexpr TaskStatus TaskStatus_MIN = static_cast<TaskStatus>(0);
constexpr TaskStatus TaskStatus_MAX = static_cast<TaskStatus>(4);
constexpr int TaskStatus_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
TaskStatus_descriptor();
template <typename T>
const std::string& TaskStatus_Name(T value) {
  static_assert(std::is_same<T, TaskStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskStatus_Name().");
  return TaskStatus_Name(static_cast<TaskStatus>(value));
}
template <>
inline const std::string& TaskStatus_Name(TaskStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskStatus_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool TaskStatus_Parse(absl::string_view name, TaskStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus>(
      TaskStatus_descriptor(), name, value);
}
enum TaskCommand : int {
  TC_STOP = 0,
  TC_RAW_DATA_TRANSFER = 1,
  TC_RAW_DATA_DELETE = 2,
  TC_RAW_DATA_UPDATE_SIZE = 3,
  TC_ALLOC_CREATE = 4,
  TC_ALLOC_DELETE = 5,
};

bool TaskCommand_IsValid(int value);
extern const uint32_t TaskCommand_internal_data_[];
constexpr TaskCommand TaskCommand_MIN = static_cast<TaskCommand>(0);
constexpr TaskCommand TaskCommand_MAX = static_cast<TaskCommand>(5);
constexpr int TaskCommand_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TaskCommand_descriptor();
template <typename T>
const std::string& TaskCommand_Name(T value) {
  static_assert(std::is_same<T, TaskCommand>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskCommand_Name().");
  return TaskCommand_Name(static_cast<TaskCommand>(value));
}
template <>
inline const std::string& TaskCommand_Name(TaskCommand value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskCommand_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TaskCommand_Parse(absl::string_view name, TaskCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskCommand>(
      TaskCommand_descriptor(), name, value);
}
enum Encryption : int {
  ENCRYPT_NONE = 0,
  ENCRYPT_AVAIL = 1,
  ENCRYPT_FORCE = 2,
};

bool Encryption_IsValid(int value);
extern const uint32_t Encryption_internal_data_[];
constexpr Encryption Encryption_MIN = static_cast<Encryption>(0);
constexpr Encryption Encryption_MAX = static_cast<Encryption>(2);
constexpr int Encryption_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Encryption_descriptor();
template <typename T>
const std::string& Encryption_Name(T value) {
  static_assert(std::is_same<T, Encryption>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Encryption_Name().");
  return Encryption_Name(static_cast<Encryption>(value));
}
template <>
inline const std::string& Encryption_Name(Encryption value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Encryption_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Encryption_Parse(absl::string_view name, Encryption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Encryption>(
      Encryption_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TopicData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.TopicData) */ {
 public:
  inline TopicData() : TopicData(nullptr) {}
  ~TopicData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TopicData(::google::protobuf::internal::ConstantInitialized);

  inline TopicData(const TopicData& from)
      : TopicData(nullptr, from) {}
  TopicData(TopicData&& from) noexcept
    : TopicData() {
    *this = ::std::move(from);
  }

  inline TopicData& operator=(const TopicData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicData& operator=(TopicData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicData* internal_default_instance() {
    return reinterpret_cast<const TopicData*>(
               &_TopicData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TopicData& a, TopicData& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopicData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopicData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TopicData& from) {
    TopicData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopicData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.TopicData";
  }
  protected:
  explicit TopicData(::google::protobuf::Arena* arena);
  TopicData(::google::protobuf::Arena* arena, const TopicData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 4,
    kCreatorFieldNumber = 5,
    kAdminFieldNumber = 6,
    kCollCntFieldNumber = 7,
  };
  // repeated .SDMS.TopicData path = 3;
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::SDMS::TopicData* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::TopicData >*
      mutable_path();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>* _internal_mutable_path();
  public:
  const ::SDMS::TopicData& path(int index) const;
  ::SDMS::TopicData* add_path();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::TopicData >&
      path() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 4;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string creator = 5;
  bool has_creator() const;
  void clear_creator() ;
  const std::string& creator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* value);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // optional bool admin = 6;
  bool has_admin() const;
  void clear_admin() ;
  bool admin() const;
  void set_admin(bool value);

  private:
  bool _internal_admin() const;
  void _internal_set_admin(bool value);

  public:
  // required uint32 coll_cnt = 7;
  bool has_coll_cnt() const;
  void clear_coll_cnt() ;
  ::uint32_t coll_cnt() const;
  void set_coll_cnt(::uint32_t value);

  private:
  ::uint32_t _internal_coll_cnt() const;
  void _internal_set_coll_cnt(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.TopicData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::TopicData > path_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr creator_;
    bool admin_;
    ::uint32_t coll_cnt_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class TaskData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.TaskData) */ {
 public:
  inline TaskData() : TaskData(nullptr) {}
  ~TaskData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskData(::google::protobuf::internal::ConstantInitialized);

  inline TaskData(const TaskData& from)
      : TaskData(nullptr, from) {}
  TaskData(TaskData&& from) noexcept
    : TaskData() {
    *this = ::std::move(from);
  }

  inline TaskData& operator=(const TaskData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskData& operator=(TaskData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskData* internal_default_instance() {
    return reinterpret_cast<const TaskData*>(
               &_TaskData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TaskData& a, TaskData& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TaskData& from) {
    TaskData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.TaskData";
  }
  protected:
  explicit TaskData(::google::protobuf::Arena* arena);
  TaskData(::google::protobuf::Arena* arena, const TaskData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kClientFieldNumber = 4,
    kMsgFieldNumber = 7,
    kSourceFieldNumber = 10,
    kDestFieldNumber = 11,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 3,
    kStepFieldNumber = 5,
    kStepsFieldNumber = 6,
    kCtFieldNumber = 8,
    kUtFieldNumber = 9,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string client = 4;
  bool has_client() const;
  void clear_client() ;
  const std::string& client() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client(Arg_&& arg, Args_... args);
  std::string* mutable_client();
  PROTOBUF_NODISCARD std::string* release_client();
  void set_allocated_client(std::string* value);

  private:
  const std::string& _internal_client() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client(
      const std::string& value);
  std::string* _internal_mutable_client();

  public:
  // required string msg = 7;
  bool has_msg() const;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* value);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // optional string source = 10;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* value);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // optional string dest = 11;
  bool has_dest() const;
  void clear_dest() ;
  const std::string& dest() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dest(Arg_&& arg, Args_... args);
  std::string* mutable_dest();
  PROTOBUF_NODISCARD std::string* release_dest();
  void set_allocated_dest(std::string* value);

  private:
  const std::string& _internal_dest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest(
      const std::string& value);
  std::string* _internal_mutable_dest();

  public:
  // required .SDMS.TaskType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::SDMS::TaskType type() const;
  void set_type(::SDMS::TaskType value);

  private:
  ::SDMS::TaskType _internal_type() const;
  void _internal_set_type(::SDMS::TaskType value);

  public:
  // required .SDMS.TaskStatus status = 3;
  bool has_status() const;
  void clear_status() ;
  ::SDMS::TaskStatus status() const;
  void set_status(::SDMS::TaskStatus value);

  private:
  ::SDMS::TaskStatus _internal_status() const;
  void _internal_set_status(::SDMS::TaskStatus value);

  public:
  // required uint32 step = 5;
  bool has_step() const;
  void clear_step() ;
  ::uint32_t step() const;
  void set_step(::uint32_t value);

  private:
  ::uint32_t _internal_step() const;
  void _internal_set_step(::uint32_t value);

  public:
  // required uint32 steps = 6;
  bool has_steps() const;
  void clear_steps() ;
  ::uint32_t steps() const;
  void set_steps(::uint32_t value);

  private:
  ::uint32_t _internal_steps() const;
  void _internal_set_steps(::uint32_t value);

  public:
  // required uint32 ct = 8;
  bool has_ct() const;
  void clear_ct() ;
  ::uint32_t ct() const;
  void set_ct(::uint32_t value);

  private:
  ::uint32_t _internal_ct() const;
  void _internal_set_ct(::uint32_t value);

  public:
  // required uint32 ut = 9;
  bool has_ut() const;
  void clear_ut() ;
  ::uint32_t ut() const;
  void set_ut(::uint32_t value);

  private:
  ::uint32_t _internal_ut() const;
  void _internal_set_ut(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.TaskData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 2,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr client_;
    ::google::protobuf::internal::ArenaStringPtr msg_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr dest_;
    int type_;
    int status_;
    ::uint32_t step_;
    ::uint32_t steps_;
    ::uint32_t ct_;
    ::uint32_t ut_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class TagData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.TagData) */ {
 public:
  inline TagData() : TagData(nullptr) {}
  ~TagData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TagData(::google::protobuf::internal::ConstantInitialized);

  inline TagData(const TagData& from)
      : TagData(nullptr, from) {}
  TagData(TagData&& from) noexcept
    : TagData() {
    *this = ::std::move(from);
  }

  inline TagData& operator=(const TagData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagData& operator=(TagData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagData* internal_default_instance() {
    return reinterpret_cast<const TagData*>(
               &_TagData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TagData& a, TagData& b) {
    a.Swap(&b);
  }
  inline void Swap(TagData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TagData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TagData& from) {
    TagData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TagData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.TagData";
  }
  protected:
  explicit TagData(::google::protobuf::Arena* arena);
  TagData(::google::protobuf::Arena* arena, const TagData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required uint64 count = 2;
  bool has_count() const;
  void clear_count() ;
  ::uint64_t count() const;
  void set_count(::uint64_t value);

  private:
  ::uint64_t _internal_count() const;
  void _internal_set_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.TagData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      25, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint64_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class SchemaData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.SchemaData) */ {
 public:
  inline SchemaData() : SchemaData(nullptr) {}
  ~SchemaData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaData(::google::protobuf::internal::ConstantInitialized);

  inline SchemaData(const SchemaData& from)
      : SchemaData(nullptr, from) {}
  SchemaData(SchemaData&& from) noexcept
    : SchemaData() {
    *this = ::std::move(from);
  }

  inline SchemaData& operator=(const SchemaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaData& operator=(SchemaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaData* internal_default_instance() {
    return reinterpret_cast<const SchemaData*>(
               &_SchemaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SchemaData& a, SchemaData& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SchemaData& from) {
    SchemaData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SchemaData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.SchemaData";
  }
  protected:
  explicit SchemaData(::google::protobuf::Arena* arena);
  SchemaData(::google::protobuf::Arena* arena, const SchemaData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsesFieldNumber = 11,
    kUsedByFieldNumber = 12,
    kIdFieldNumber = 1,
    kOwnIdFieldNumber = 6,
    kOwnNmFieldNumber = 7,
    kDescFieldNumber = 8,
    kDefFieldNumber = 10,
    kVerFieldNumber = 2,
    kCntFieldNumber = 4,
    kDeprFieldNumber = 3,
    kRefFieldNumber = 5,
    kPubFieldNumber = 9,
  };
  // repeated .SDMS.SchemaData uses = 11;
  int uses_size() const;
  private:
  int _internal_uses_size() const;

  public:
  void clear_uses() ;
  ::SDMS::SchemaData* mutable_uses(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData >*
      mutable_uses();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>& _internal_uses() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>* _internal_mutable_uses();
  public:
  const ::SDMS::SchemaData& uses(int index) const;
  ::SDMS::SchemaData* add_uses();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData >&
      uses() const;
  // repeated .SDMS.SchemaData used_by = 12;
  int used_by_size() const;
  private:
  int _internal_used_by_size() const;

  public:
  void clear_used_by() ;
  ::SDMS::SchemaData* mutable_used_by(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData >*
      mutable_used_by();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>& _internal_used_by() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>* _internal_mutable_used_by();
  public:
  const ::SDMS::SchemaData& used_by(int index) const;
  ::SDMS::SchemaData* add_used_by();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData >&
      used_by() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string own_id = 6;
  bool has_own_id() const;
  void clear_own_id() ;
  const std::string& own_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_own_id(Arg_&& arg, Args_... args);
  std::string* mutable_own_id();
  PROTOBUF_NODISCARD std::string* release_own_id();
  void set_allocated_own_id(std::string* value);

  private:
  const std::string& _internal_own_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_own_id(
      const std::string& value);
  std::string* _internal_mutable_own_id();

  public:
  // optional string own_nm = 7;
  bool has_own_nm() const;
  void clear_own_nm() ;
  const std::string& own_nm() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_own_nm(Arg_&& arg, Args_... args);
  std::string* mutable_own_nm();
  PROTOBUF_NODISCARD std::string* release_own_nm();
  void set_allocated_own_nm(std::string* value);

  private:
  const std::string& _internal_own_nm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_own_nm(
      const std::string& value);
  std::string* _internal_mutable_own_nm();

  public:
  // optional string desc = 8;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string def = 10;
  bool has_def() const;
  void clear_def() ;
  const std::string& def() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_def(Arg_&& arg, Args_... args);
  std::string* mutable_def();
  PROTOBUF_NODISCARD std::string* release_def();
  void set_allocated_def(std::string* value);

  private:
  const std::string& _internal_def() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_def(
      const std::string& value);
  std::string* _internal_mutable_def();

  public:
  // required uint32 ver = 2;
  bool has_ver() const;
  void clear_ver() ;
  ::uint32_t ver() const;
  void set_ver(::uint32_t value);

  private:
  ::uint32_t _internal_ver() const;
  void _internal_set_ver(::uint32_t value);

  public:
  // optional uint32 cnt = 4;
  bool has_cnt() const;
  void clear_cnt() ;
  ::uint32_t cnt() const;
  void set_cnt(::uint32_t value);

  private:
  ::uint32_t _internal_cnt() const;
  void _internal_set_cnt(::uint32_t value);

  public:
  // optional bool depr = 3;
  bool has_depr() const;
  void clear_depr() ;
  bool depr() const;
  void set_depr(bool value);

  private:
  bool _internal_depr() const;
  void _internal_set_depr(bool value);

  public:
  // optional bool ref = 5;
  bool has_ref() const;
  void clear_ref() ;
  bool ref() const;
  void set_ref(bool value);

  private:
  bool _internal_ref() const;
  void _internal_set_ref(bool value);

  public:
  // optional bool pub = 9;
  bool has_pub() const;
  void clear_pub() ;
  bool pub() const;
  void set_pub(bool value);

  private:
  bool _internal_pub() const;
  void _internal_set_pub(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.SchemaData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 2,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData > uses_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::SchemaData > used_by_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr own_id_;
    ::google::protobuf::internal::ArenaStringPtr own_nm_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr def_;
    ::uint32_t ver_;
    ::uint32_t cnt_;
    bool depr_;
    bool ref_;
    bool pub_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class RepoData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.RepoData) */ {
 public:
  inline RepoData() : RepoData(nullptr) {}
  ~RepoData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoData(::google::protobuf::internal::ConstantInitialized);

  inline RepoData(const RepoData& from)
      : RepoData(nullptr, from) {}
  RepoData(RepoData&& from) noexcept
    : RepoData() {
    *this = ::std::move(from);
  }

  inline RepoData& operator=(const RepoData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoData& operator=(RepoData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoData* internal_default_instance() {
    return reinterpret_cast<const RepoData*>(
               &_RepoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RepoData& a, RepoData& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoData& from) {
    RepoData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.RepoData";
  }
  protected:
  explicit RepoData(::google::protobuf::Arena* arena);
  RepoData(::google::protobuf::Arena* arena, const RepoData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminFieldNumber = 11,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 3,
    kPubKeyFieldNumber = 5,
    kAddressFieldNumber = 6,
    kEndpointFieldNumber = 7,
    kPathFieldNumber = 8,
    kDomainFieldNumber = 9,
    kExpPathFieldNumber = 10,
    kCapacityFieldNumber = 4,
  };
  // repeated string admin = 11;
  int admin_size() const;
  private:
  int _internal_admin_size() const;

  public:
  void clear_admin() ;
  const std::string& admin(int index) const;
  std::string* mutable_admin(int index);
  void set_admin(int index, const std::string& value);
  void set_admin(int index, std::string&& value);
  void set_admin(int index, const char* value);
  void set_admin(int index, const char* value, std::size_t size);
  void set_admin(int index, absl::string_view value);
  std::string* add_admin();
  void add_admin(const std::string& value);
  void add_admin(std::string&& value);
  void add_admin(const char* value);
  void add_admin(const char* value, std::size_t size);
  void add_admin(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_admin();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_admin();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string pub_key = 5;
  bool has_pub_key() const;
  void clear_pub_key() ;
  const std::string& pub_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pub_key(Arg_&& arg, Args_... args);
  std::string* mutable_pub_key();
  PROTOBUF_NODISCARD std::string* release_pub_key();
  void set_allocated_pub_key(std::string* value);

  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(
      const std::string& value);
  std::string* _internal_mutable_pub_key();

  public:
  // optional string address = 6;
  bool has_address() const;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // optional string endpoint = 7;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const std::string& endpoint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* value);

  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(
      const std::string& value);
  std::string* _internal_mutable_endpoint();

  public:
  // optional string path = 8;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional string domain = 9;
  bool has_domain() const;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // optional string exp_path = 10;
  bool has_exp_path() const;
  void clear_exp_path() ;
  const std::string& exp_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_exp_path(Arg_&& arg, Args_... args);
  std::string* mutable_exp_path();
  PROTOBUF_NODISCARD std::string* release_exp_path();
  void set_allocated_exp_path(std::string* value);

  private:
  const std::string& _internal_exp_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exp_path(
      const std::string& value);
  std::string* _internal_mutable_exp_path();

  public:
  // optional uint64 capacity = 4;
  bool has_capacity() const;
  void clear_capacity() ;
  ::uint64_t capacity() const;
  void set_capacity(::uint64_t value);

  private:
  ::uint64_t _internal_capacity() const;
  void _internal_set_capacity(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.RepoData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      86, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> admin_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr pub_key_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr endpoint_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::google::protobuf::internal::ArenaStringPtr exp_path_;
    ::uint64_t capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class RecordDataSize final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.RecordDataSize) */ {
 public:
  inline RecordDataSize() : RecordDataSize(nullptr) {}
  ~RecordDataSize() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordDataSize(::google::protobuf::internal::ConstantInitialized);

  inline RecordDataSize(const RecordDataSize& from)
      : RecordDataSize(nullptr, from) {}
  RecordDataSize(RecordDataSize&& from) noexcept
    : RecordDataSize() {
    *this = ::std::move(from);
  }

  inline RecordDataSize& operator=(const RecordDataSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDataSize& operator=(RecordDataSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDataSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDataSize* internal_default_instance() {
    return reinterpret_cast<const RecordDataSize*>(
               &_RecordDataSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RecordDataSize& a, RecordDataSize& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDataSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDataSize* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordDataSize* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordDataSize>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordDataSize& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordDataSize& from) {
    RecordDataSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordDataSize* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.RecordDataSize";
  }
  protected:
  explicit RecordDataSize(::google::protobuf::Arena* arena);
  RecordDataSize(::google::protobuf::Arena* arena, const RecordDataSize& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required double size = 2;
  bool has_size() const;
  void clear_size() ;
  double size() const;
  void set_size(double value);

  private:
  double _internal_size() const;
  void _internal_set_size(double value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.RecordDataSize)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    double size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class RecordDataLocation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.RecordDataLocation) */ {
 public:
  inline RecordDataLocation() : RecordDataLocation(nullptr) {}
  ~RecordDataLocation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordDataLocation(::google::protobuf::internal::ConstantInitialized);

  inline RecordDataLocation(const RecordDataLocation& from)
      : RecordDataLocation(nullptr, from) {}
  RecordDataLocation(RecordDataLocation&& from) noexcept
    : RecordDataLocation() {
    *this = ::std::move(from);
  }

  inline RecordDataLocation& operator=(const RecordDataLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordDataLocation& operator=(RecordDataLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordDataLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordDataLocation* internal_default_instance() {
    return reinterpret_cast<const RecordDataLocation*>(
               &_RecordDataLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RecordDataLocation& a, RecordDataLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordDataLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordDataLocation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordDataLocation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordDataLocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordDataLocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordDataLocation& from) {
    RecordDataLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordDataLocation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.RecordDataLocation";
  }
  protected:
  explicit RecordDataLocation(::google::protobuf::Arena* arena);
  RecordDataLocation(::google::protobuf::Arena* arena, const RecordDataLocation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string path = 2;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.RecordDataLocation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class NoteComment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.NoteComment) */ {
 public:
  inline NoteComment() : NoteComment(nullptr) {}
  ~NoteComment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoteComment(::google::protobuf::internal::ConstantInitialized);

  inline NoteComment(const NoteComment& from)
      : NoteComment(nullptr, from) {}
  NoteComment(NoteComment&& from) noexcept
    : NoteComment() {
    *this = ::std::move(from);
  }

  inline NoteComment& operator=(const NoteComment& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteComment& operator=(NoteComment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteComment& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteComment* internal_default_instance() {
    return reinterpret_cast<const NoteComment*>(
               &_NoteComment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NoteComment& a, NoteComment& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteComment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteComment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteComment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoteComment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteComment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoteComment& from) {
    NoteComment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoteComment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.NoteComment";
  }
  protected:
  explicit NoteComment(::google::protobuf::Arena* arena);
  NoteComment(::google::protobuf::Arena* arena, const NoteComment& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kCommentFieldNumber = 3,
    kTimeFieldNumber = 2,
    kTypeFieldNumber = 4,
    kStateFieldNumber = 5,
  };
  // required string user = 1;
  bool has_user() const;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // required string comment = 3;
  bool has_comment() const;
  void clear_comment() ;
  const std::string& comment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comment(Arg_&& arg, Args_... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* value);

  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(
      const std::string& value);
  std::string* _internal_mutable_comment();

  public:
  // required uint32 time = 2;
  bool has_time() const;
  void clear_time() ;
  ::uint32_t time() const;
  void set_time(::uint32_t value);

  private:
  ::uint32_t _internal_time() const;
  void _internal_set_time(::uint32_t value);

  public:
  // optional .SDMS.NoteType type = 4;
  bool has_type() const;
  void clear_type() ;
  ::SDMS::NoteType type() const;
  void set_type(::SDMS::NoteType value);

  private:
  ::SDMS::NoteType _internal_type() const;
  void _internal_set_type(::SDMS::NoteType value);

  public:
  // optional .SDMS.NoteState state = 5;
  bool has_state() const;
  void clear_state() ;
  ::SDMS::NoteState state() const;
  void set_state(::SDMS::NoteState value);

  private:
  ::SDMS::NoteState _internal_state() const;
  void _internal_set_state(::SDMS::NoteState value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.NoteComment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::google::protobuf::internal::ArenaStringPtr comment_;
    ::uint32_t time_;
    int type_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class GroupData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.GroupData) */ {
 public:
  inline GroupData() : GroupData(nullptr) {}
  ~GroupData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupData(::google::protobuf::internal::ConstantInitialized);

  inline GroupData(const GroupData& from)
      : GroupData(nullptr, from) {}
  GroupData(GroupData&& from) noexcept
    : GroupData() {
    *this = ::std::move(from);
  }

  inline GroupData& operator=(const GroupData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupData& operator=(GroupData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupData* internal_default_instance() {
    return reinterpret_cast<const GroupData*>(
               &_GroupData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GroupData& a, GroupData& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupData& from) {
    GroupData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.GroupData";
  }
  protected:
  explicit GroupData(::google::protobuf::Arena* arena);
  GroupData(::google::protobuf::Arena* arena, const GroupData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 5,
    kUidFieldNumber = 1,
    kGidFieldNumber = 2,
    kTitleFieldNumber = 3,
    kDescFieldNumber = 4,
  };
  // repeated string member = 5;
  int member_size() const;
  private:
  int _internal_member_size() const;

  public:
  void clear_member() ;
  const std::string& member(int index) const;
  std::string* mutable_member(int index);
  void set_member(int index, const std::string& value);
  void set_member(int index, std::string&& value);
  void set_member(int index, const char* value);
  void set_member(int index, const char* value, std::size_t size);
  void set_member(int index, absl::string_view value);
  std::string* add_member();
  void add_member(const std::string& value);
  void add_member(std::string&& value);
  void add_member(const char* value);
  void add_member(const char* value, std::size_t size);
  void add_member(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& member() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_member();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_member() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_member();

  public:
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // required string gid = 2;
  bool has_gid() const;
  void clear_gid() ;
  const std::string& gid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gid(Arg_&& arg, Args_... args);
  std::string* mutable_gid();
  PROTOBUF_NODISCARD std::string* release_gid();
  void set_allocated_gid(std::string* value);

  private:
  const std::string& _internal_gid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gid(
      const std::string& value);
  std::string* _internal_mutable_gid();

  public:
  // optional string title = 3;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 4;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.GroupData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> member_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr gid_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class DependencySpecData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.DependencySpecData) */ {
 public:
  inline DependencySpecData() : DependencySpecData(nullptr) {}
  ~DependencySpecData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DependencySpecData(::google::protobuf::internal::ConstantInitialized);

  inline DependencySpecData(const DependencySpecData& from)
      : DependencySpecData(nullptr, from) {}
  DependencySpecData(DependencySpecData&& from) noexcept
    : DependencySpecData() {
    *this = ::std::move(from);
  }

  inline DependencySpecData& operator=(const DependencySpecData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DependencySpecData& operator=(DependencySpecData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DependencySpecData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DependencySpecData* internal_default_instance() {
    return reinterpret_cast<const DependencySpecData*>(
               &_DependencySpecData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DependencySpecData& a, DependencySpecData& b) {
    a.Swap(&b);
  }
  inline void Swap(DependencySpecData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DependencySpecData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DependencySpecData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DependencySpecData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DependencySpecData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DependencySpecData& from) {
    DependencySpecData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DependencySpecData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.DependencySpecData";
  }
  protected:
  explicit DependencySpecData(::google::protobuf::Arena* arena);
  DependencySpecData(::google::protobuf::Arena* arena, const DependencySpecData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required .SDMS.DependencyType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::SDMS::DependencyType type() const;
  void set_type(::SDMS::DependencyType value);

  private:
  ::SDMS::DependencyType _internal_type() const;
  void _internal_set_type(::SDMS::DependencyType value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.DependencySpecData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class DependencyData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.DependencyData) */ {
 public:
  inline DependencyData() : DependencyData(nullptr) {}
  ~DependencyData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DependencyData(::google::protobuf::internal::ConstantInitialized);

  inline DependencyData(const DependencyData& from)
      : DependencyData(nullptr, from) {}
  DependencyData(DependencyData&& from) noexcept
    : DependencyData() {
    *this = ::std::move(from);
  }

  inline DependencyData& operator=(const DependencyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DependencyData& operator=(DependencyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DependencyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DependencyData* internal_default_instance() {
    return reinterpret_cast<const DependencyData*>(
               &_DependencyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DependencyData& a, DependencyData& b) {
    a.Swap(&b);
  }
  inline void Swap(DependencyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DependencyData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DependencyData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DependencyData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DependencyData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DependencyData& from) {
    DependencyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DependencyData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.DependencyData";
  }
  protected:
  explicit DependencyData(::google::protobuf::Arena* arena);
  DependencyData(::google::protobuf::Arena* arena, const DependencyData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAliasFieldNumber = 2,
    kNotesFieldNumber = 3,
    kTypeFieldNumber = 4,
    kDirFieldNumber = 5,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string alias = 2;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional uint32 notes = 3;
  bool has_notes() const;
  void clear_notes() ;
  ::uint32_t notes() const;
  void set_notes(::uint32_t value);

  private:
  ::uint32_t _internal_notes() const;
  void _internal_set_notes(::uint32_t value);

  public:
  // required .SDMS.DependencyType type = 4;
  bool has_type() const;
  void clear_type() ;
  ::SDMS::DependencyType type() const;
  void set_type(::SDMS::DependencyType value);

  private:
  ::SDMS::DependencyType _internal_type() const;
  void _internal_set_type(::SDMS::DependencyType value);

  public:
  // required .SDMS.DependencyDir dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  ::SDMS::DependencyDir dir() const;
  void set_dir(::SDMS::DependencyDir value);

  private:
  ::SDMS::DependencyDir _internal_dir() const;
  void _internal_set_dir(::SDMS::DependencyDir value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.DependencyData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::uint32_t notes_;
    int type_;
    int dir_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class CollData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.CollData) */ {
 public:
  inline CollData() : CollData(nullptr) {}
  ~CollData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollData(::google::protobuf::internal::ConstantInitialized);

  inline CollData(const CollData& from)
      : CollData(nullptr, from) {}
  CollData(CollData&& from) noexcept
    : CollData() {
    *this = ::std::move(from);
  }

  inline CollData& operator=(const CollData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollData& operator=(CollData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollData* internal_default_instance() {
    return reinterpret_cast<const CollData*>(
               &_CollData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CollData& a, CollData& b) {
    a.Swap(&b);
  }
  inline void Swap(CollData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollData& from) {
    CollData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.CollData";
  }
  protected:
  explicit CollData(::google::protobuf::Arena* arena);
  CollData(::google::protobuf::Arena* arena, const CollData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 5,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kAliasFieldNumber = 3,
    kDescFieldNumber = 4,
    kTopicFieldNumber = 6,
    kOwnerFieldNumber = 7,
    kCreatorFieldNumber = 8,
    kParentIdFieldNumber = 11,
    kCtFieldNumber = 9,
    kUtFieldNumber = 10,
    kNotesFieldNumber = 12,
  };
  // repeated string tags = 5;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string alias = 3;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional string desc = 4;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string topic = 6;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // optional string owner = 7;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* value);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // optional string creator = 8;
  bool has_creator() const;
  void clear_creator() ;
  const std::string& creator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* value);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // optional string parent_id = 11;
  bool has_parent_id() const;
  void clear_parent_id() ;
  const std::string& parent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* value);

  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(
      const std::string& value);
  std::string* _internal_mutable_parent_id();

  public:
  // optional uint32 ct = 9;
  bool has_ct() const;
  void clear_ct() ;
  ::uint32_t ct() const;
  void set_ct(::uint32_t value);

  private:
  ::uint32_t _internal_ct() const;
  void _internal_set_ct(::uint32_t value);

  public:
  // optional uint32 ut = 10;
  bool has_ut() const;
  void clear_ut() ;
  ::uint32_t ut() const;
  void set_ut(::uint32_t value);

  private:
  ::uint32_t _internal_ut() const;
  void _internal_set_ut(::uint32_t value);

  public:
  // optional uint32 notes = 12;
  bool has_notes() const;
  void clear_notes() ;
  ::uint32_t notes() const;
  void set_notes(::uint32_t value);

  private:
  ::uint32_t _internal_notes() const;
  void _internal_set_notes(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.CollData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    ::google::protobuf::internal::ArenaStringPtr creator_;
    ::google::protobuf::internal::ArenaStringPtr parent_id_;
    ::uint32_t ct_;
    ::uint32_t ut_;
    ::uint32_t notes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class AllocStatsData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.AllocStatsData) */ {
 public:
  inline AllocStatsData() : AllocStatsData(nullptr) {}
  ~AllocStatsData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocStatsData(::google::protobuf::internal::ConstantInitialized);

  inline AllocStatsData(const AllocStatsData& from)
      : AllocStatsData(nullptr, from) {}
  AllocStatsData(AllocStatsData&& from) noexcept
    : AllocStatsData() {
    *this = ::std::move(from);
  }

  inline AllocStatsData& operator=(const AllocStatsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocStatsData& operator=(AllocStatsData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocStatsData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocStatsData* internal_default_instance() {
    return reinterpret_cast<const AllocStatsData*>(
               &_AllocStatsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AllocStatsData& a, AllocStatsData& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocStatsData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocStatsData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocStatsData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocStatsData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllocStatsData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AllocStatsData& from) {
    AllocStatsData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AllocStatsData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.AllocStatsData";
  }
  protected:
  explicit AllocStatsData(::google::protobuf::Arena* arena);
  AllocStatsData(::google::protobuf::Arena* arena, const AllocStatsData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistogramFieldNumber = 5,
    kRepoFieldNumber = 1,
    kRecCountFieldNumber = 2,
    kFileCountFieldNumber = 3,
    kDataSizeFieldNumber = 4,
  };
  // repeated uint32 histogram = 5;
  int histogram_size() const;
  private:
  int _internal_histogram_size() const;

  public:
  void clear_histogram() ;
  ::uint32_t histogram(int index) const;
  void set_histogram(int index, ::uint32_t value);
  void add_histogram(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& histogram() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_histogram();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_histogram() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_histogram();

  public:
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // required uint32 rec_count = 2;
  bool has_rec_count() const;
  void clear_rec_count() ;
  ::uint32_t rec_count() const;
  void set_rec_count(::uint32_t value);

  private:
  ::uint32_t _internal_rec_count() const;
  void _internal_set_rec_count(::uint32_t value);

  public:
  // required uint32 file_count = 3;
  bool has_file_count() const;
  void clear_file_count() ;
  ::uint32_t file_count() const;
  void set_file_count(::uint32_t value);

  private:
  ::uint32_t _internal_file_count() const;
  void _internal_set_file_count(::uint32_t value);

  public:
  // required uint64 data_size = 4;
  bool has_data_size() const;
  void clear_data_size() ;
  ::uint64_t data_size() const;
  void set_data_size(::uint64_t value);

  private:
  ::uint64_t _internal_data_size() const;
  void _internal_set_data_size(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.AllocStatsData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> histogram_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::uint32_t rec_count_;
    ::uint32_t file_count_;
    ::uint64_t data_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class ACLRule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.ACLRule) */ {
 public:
  inline ACLRule() : ACLRule(nullptr) {}
  ~ACLRule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ACLRule(::google::protobuf::internal::ConstantInitialized);

  inline ACLRule(const ACLRule& from)
      : ACLRule(nullptr, from) {}
  ACLRule(ACLRule&& from) noexcept
    : ACLRule() {
    *this = ::std::move(from);
  }

  inline ACLRule& operator=(const ACLRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACLRule& operator=(ACLRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACLRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACLRule* internal_default_instance() {
    return reinterpret_cast<const ACLRule*>(
               &_ACLRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ACLRule& a, ACLRule& b) {
    a.Swap(&b);
  }
  inline void Swap(ACLRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACLRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACLRule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACLRule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACLRule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ACLRule& from) {
    ACLRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ACLRule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.ACLRule";
  }
  protected:
  explicit ACLRule(::google::protobuf::Arena* arena);
  ACLRule(::google::protobuf::Arena* arena, const ACLRule& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kGrantFieldNumber = 2,
    kInhgrantFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional uint32 grant = 2;
  bool has_grant() const;
  void clear_grant() ;
  ::uint32_t grant() const;
  void set_grant(::uint32_t value);

  private:
  ::uint32_t _internal_grant() const;
  void _internal_set_grant(::uint32_t value);

  public:
  // optional uint32 inhgrant = 3;
  bool has_inhgrant() const;
  void clear_inhgrant() ;
  ::uint32_t inhgrant() const;
  void set_inhgrant(::uint32_t value);

  private:
  ::uint32_t _internal_inhgrant() const;
  void _internal_set_inhgrant(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.ACLRule)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      23, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::uint32_t grant_;
    ::uint32_t inhgrant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class RepoRecordDataLocations final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.RepoRecordDataLocations) */ {
 public:
  inline RepoRecordDataLocations() : RepoRecordDataLocations(nullptr) {}
  ~RepoRecordDataLocations() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepoRecordDataLocations(::google::protobuf::internal::ConstantInitialized);

  inline RepoRecordDataLocations(const RepoRecordDataLocations& from)
      : RepoRecordDataLocations(nullptr, from) {}
  RepoRecordDataLocations(RepoRecordDataLocations&& from) noexcept
    : RepoRecordDataLocations() {
    *this = ::std::move(from);
  }

  inline RepoRecordDataLocations& operator=(const RepoRecordDataLocations& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepoRecordDataLocations& operator=(RepoRecordDataLocations&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepoRecordDataLocations& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepoRecordDataLocations* internal_default_instance() {
    return reinterpret_cast<const RepoRecordDataLocations*>(
               &_RepoRecordDataLocations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RepoRecordDataLocations& a, RepoRecordDataLocations& b) {
    a.Swap(&b);
  }
  inline void Swap(RepoRecordDataLocations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepoRecordDataLocations* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepoRecordDataLocations* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepoRecordDataLocations>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepoRecordDataLocations& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepoRecordDataLocations& from) {
    RepoRecordDataLocations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepoRecordDataLocations* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.RepoRecordDataLocations";
  }
  protected:
  explicit RepoRecordDataLocations(::google::protobuf::Arena* arena);
  RepoRecordDataLocations(::google::protobuf::Arena* arena, const RepoRecordDataLocations& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocFieldNumber = 2,
    kRepoIdFieldNumber = 1,
  };
  // repeated .SDMS.RecordDataLocation loc = 2;
  int loc_size() const;
  private:
  int _internal_loc_size() const;

  public:
  void clear_loc() ;
  ::SDMS::RecordDataLocation* mutable_loc(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation >*
      mutable_loc();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>& _internal_loc() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>* _internal_mutable_loc();
  public:
  const ::SDMS::RecordDataLocation& loc(int index) const;
  ::SDMS::RecordDataLocation* add_loc();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation >&
      loc() const;
  // required string repo_id = 1;
  bool has_repo_id() const;
  void clear_repo_id() ;
  const std::string& repo_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo_id(Arg_&& arg, Args_... args);
  std::string* mutable_repo_id();
  PROTOBUF_NODISCARD std::string* release_repo_id();
  void set_allocated_repo_id(std::string* value);

  private:
  const std::string& _internal_repo_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo_id(
      const std::string& value);
  std::string* _internal_mutable_repo_id();

  public:
  // @@protoc_insertion_point(class_scope:SDMS.RepoRecordDataLocations)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::RecordDataLocation > loc_;
    ::google::protobuf::internal::ArenaStringPtr repo_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class RecordData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.RecordData) */ {
 public:
  inline RecordData() : RecordData(nullptr) {}
  ~RecordData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordData(::google::protobuf::internal::ConstantInitialized);

  inline RecordData(const RecordData& from)
      : RecordData(nullptr, from) {}
  RecordData(RecordData&& from) noexcept
    : RecordData() {
    *this = ::std::move(from);
  }

  inline RecordData& operator=(const RecordData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordData& operator=(RecordData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordData* internal_default_instance() {
    return reinterpret_cast<const RecordData*>(
               &_RecordData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RecordData& a, RecordData& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecordData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecordData& from) {
    RecordData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecordData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.RecordData";
  }
  protected:
  explicit RecordData(::google::protobuf::Arena* arena);
  RecordData(::google::protobuf::Arena* arena, const RecordData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 5,
    kDepsFieldNumber = 20,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kAliasFieldNumber = 3,
    kDescFieldNumber = 4,
    kMetadataFieldNumber = 6,
    kSourceFieldNumber = 8,
    kRepoIdFieldNumber = 9,
    kExtFieldNumber = 11,
    kOwnerFieldNumber = 16,
    kCreatorFieldNumber = 17,
    kParentIdFieldNumber = 19,
    kMdErrMsgFieldNumber = 22,
    kSchIdFieldNumber = 23,
    kSizeFieldNumber = 10,
    kExternalFieldNumber = 7,
    kExtAutoFieldNumber = 12,
    kLockedFieldNumber = 18,
    kCtFieldNumber = 13,
    kUtFieldNumber = 14,
    kDtFieldNumber = 15,
    kNotesFieldNumber = 21,
    kSchVerFieldNumber = 24,
  };
  // repeated string tags = 5;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // repeated .SDMS.DependencyData deps = 20;
  int deps_size() const;
  private:
  int _internal_deps_size() const;

  public:
  void clear_deps() ;
  ::SDMS::DependencyData* mutable_deps(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::DependencyData >*
      mutable_deps();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>& _internal_deps() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>* _internal_mutable_deps();
  public:
  const ::SDMS::DependencyData& deps(int index) const;
  ::SDMS::DependencyData* add_deps();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::DependencyData >&
      deps() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string alias = 3;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional string desc = 4;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string metadata = 6;
  bool has_metadata() const;
  void clear_metadata() ;
  const std::string& metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* value);

  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(
      const std::string& value);
  std::string* _internal_mutable_metadata();

  public:
  // optional string source = 8;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* value);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // optional string repo_id = 9;
  bool has_repo_id() const;
  void clear_repo_id() ;
  const std::string& repo_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo_id(Arg_&& arg, Args_... args);
  std::string* mutable_repo_id();
  PROTOBUF_NODISCARD std::string* release_repo_id();
  void set_allocated_repo_id(std::string* value);

  private:
  const std::string& _internal_repo_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo_id(
      const std::string& value);
  std::string* _internal_mutable_repo_id();

  public:
  // optional string ext = 11;
  bool has_ext() const;
  void clear_ext() ;
  const std::string& ext() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ext(Arg_&& arg, Args_... args);
  std::string* mutable_ext();
  PROTOBUF_NODISCARD std::string* release_ext();
  void set_allocated_ext(std::string* value);

  private:
  const std::string& _internal_ext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ext(
      const std::string& value);
  std::string* _internal_mutable_ext();

  public:
  // optional string owner = 16;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* value);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // optional string creator = 17;
  bool has_creator() const;
  void clear_creator() ;
  const std::string& creator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* value);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // optional string parent_id = 19;
  bool has_parent_id() const;
  void clear_parent_id() ;
  const std::string& parent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* value);

  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(
      const std::string& value);
  std::string* _internal_mutable_parent_id();

  public:
  // optional string md_err_msg = 22;
  bool has_md_err_msg() const;
  void clear_md_err_msg() ;
  const std::string& md_err_msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_md_err_msg(Arg_&& arg, Args_... args);
  std::string* mutable_md_err_msg();
  PROTOBUF_NODISCARD std::string* release_md_err_msg();
  void set_allocated_md_err_msg(std::string* value);

  private:
  const std::string& _internal_md_err_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md_err_msg(
      const std::string& value);
  std::string* _internal_mutable_md_err_msg();

  public:
  // optional string sch_id = 23;
  bool has_sch_id() const;
  void clear_sch_id() ;
  const std::string& sch_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sch_id(Arg_&& arg, Args_... args);
  std::string* mutable_sch_id();
  PROTOBUF_NODISCARD std::string* release_sch_id();
  void set_allocated_sch_id(std::string* value);

  private:
  const std::string& _internal_sch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sch_id(
      const std::string& value);
  std::string* _internal_mutable_sch_id();

  public:
  // optional double size = 10;
  bool has_size() const;
  void clear_size() ;
  double size() const;
  void set_size(double value);

  private:
  double _internal_size() const;
  void _internal_set_size(double value);

  public:
  // optional bool external = 7;
  bool has_external() const;
  void clear_external() ;
  bool external() const;
  void set_external(bool value);

  private:
  bool _internal_external() const;
  void _internal_set_external(bool value);

  public:
  // optional bool ext_auto = 12;
  bool has_ext_auto() const;
  void clear_ext_auto() ;
  bool ext_auto() const;
  void set_ext_auto(bool value);

  private:
  bool _internal_ext_auto() const;
  void _internal_set_ext_auto(bool value);

  public:
  // optional bool locked = 18;
  bool has_locked() const;
  void clear_locked() ;
  bool locked() const;
  void set_locked(bool value);

  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);

  public:
  // optional uint32 ct = 13;
  bool has_ct() const;
  void clear_ct() ;
  ::uint32_t ct() const;
  void set_ct(::uint32_t value);

  private:
  ::uint32_t _internal_ct() const;
  void _internal_set_ct(::uint32_t value);

  public:
  // optional uint32 ut = 14;
  bool has_ut() const;
  void clear_ut() ;
  ::uint32_t ut() const;
  void set_ut(::uint32_t value);

  private:
  ::uint32_t _internal_ut() const;
  void _internal_set_ut(::uint32_t value);

  public:
  // optional uint32 dt = 15;
  bool has_dt() const;
  void clear_dt() ;
  ::uint32_t dt() const;
  void set_dt(::uint32_t value);

  private:
  ::uint32_t _internal_dt() const;
  void _internal_set_dt(::uint32_t value);

  public:
  // optional uint32 notes = 21;
  bool has_notes() const;
  void clear_notes() ;
  ::uint32_t notes() const;
  void set_notes(::uint32_t value);

  private:
  ::uint32_t _internal_notes() const;
  void _internal_set_notes(::uint32_t value);

  public:
  // optional uint32 sch_ver = 24;
  bool has_sch_ver() const;
  void clear_sch_ver() ;
  ::uint32_t sch_ver() const;
  void set_sch_ver(::uint32_t value);

  private:
  ::uint32_t _internal_sch_ver() const;
  void _internal_set_sch_ver(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.RecordData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 24, 1,
      129, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::DependencyData > deps_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr metadata_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr repo_id_;
    ::google::protobuf::internal::ArenaStringPtr ext_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    ::google::protobuf::internal::ArenaStringPtr creator_;
    ::google::protobuf::internal::ArenaStringPtr parent_id_;
    ::google::protobuf::internal::ArenaStringPtr md_err_msg_;
    ::google::protobuf::internal::ArenaStringPtr sch_id_;
    double size_;
    bool external_;
    bool ext_auto_;
    bool locked_;
    ::uint32_t ct_;
    ::uint32_t ut_;
    ::uint32_t dt_;
    ::uint32_t notes_;
    ::uint32_t sch_ver_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class NoteData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.NoteData) */ {
 public:
  inline NoteData() : NoteData(nullptr) {}
  ~NoteData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoteData(::google::protobuf::internal::ConstantInitialized);

  inline NoteData(const NoteData& from)
      : NoteData(nullptr, from) {}
  NoteData(NoteData&& from) noexcept
    : NoteData() {
    *this = ::std::move(from);
  }

  inline NoteData& operator=(const NoteData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteData& operator=(NoteData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteData& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteData* internal_default_instance() {
    return reinterpret_cast<const NoteData*>(
               &_NoteData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(NoteData& a, NoteData& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoteData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoteData& from) {
    NoteData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoteData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.NoteData";
  }
  protected:
  explicit NoteData(::google::protobuf::Arena* arena);
  NoteData(::google::protobuf::Arena* arena, const NoteData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentFieldNumber = 6,
    kIdFieldNumber = 1,
    kSubjectIdFieldNumber = 4,
    kTitleFieldNumber = 5,
    kParentIdFieldNumber = 9,
    kTypeFieldNumber = 2,
    kStateFieldNumber = 3,
    kCtFieldNumber = 7,
    kUtFieldNumber = 8,
    kHasChildFieldNumber = 10,
  };
  // repeated .SDMS.NoteComment comment = 6;
  int comment_size() const;
  private:
  int _internal_comment_size() const;

  public:
  void clear_comment() ;
  ::SDMS::NoteComment* mutable_comment(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::NoteComment >*
      mutable_comment();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::NoteComment>& _internal_comment() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::NoteComment>* _internal_mutable_comment();
  public:
  const ::SDMS::NoteComment& comment(int index) const;
  ::SDMS::NoteComment* add_comment();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::NoteComment >&
      comment() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string subject_id = 4;
  bool has_subject_id() const;
  void clear_subject_id() ;
  const std::string& subject_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject_id(Arg_&& arg, Args_... args);
  std::string* mutable_subject_id();
  PROTOBUF_NODISCARD std::string* release_subject_id();
  void set_allocated_subject_id(std::string* value);

  private:
  const std::string& _internal_subject_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject_id(
      const std::string& value);
  std::string* _internal_mutable_subject_id();

  public:
  // required string title = 5;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string parent_id = 9;
  bool has_parent_id() const;
  void clear_parent_id() ;
  const std::string& parent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* value);

  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(
      const std::string& value);
  std::string* _internal_mutable_parent_id();

  public:
  // required .SDMS.NoteType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::SDMS::NoteType type() const;
  void set_type(::SDMS::NoteType value);

  private:
  ::SDMS::NoteType _internal_type() const;
  void _internal_set_type(::SDMS::NoteType value);

  public:
  // required .SDMS.NoteState state = 3;
  bool has_state() const;
  void clear_state() ;
  ::SDMS::NoteState state() const;
  void set_state(::SDMS::NoteState value);

  private:
  ::SDMS::NoteState _internal_state() const;
  void _internal_set_state(::SDMS::NoteState value);

  public:
  // required uint32 ct = 7;
  bool has_ct() const;
  void clear_ct() ;
  ::uint32_t ct() const;
  void set_ct(::uint32_t value);

  private:
  ::uint32_t _internal_ct() const;
  void _internal_set_ct(::uint32_t value);

  public:
  // required uint32 ut = 8;
  bool has_ut() const;
  void clear_ut() ;
  ::uint32_t ut() const;
  void set_ut(::uint32_t value);

  private:
  ::uint32_t _internal_ut() const;
  void _internal_set_ut(::uint32_t value);

  public:
  // optional bool has_child = 10;
  bool has_has_child() const;
  void clear_has_child() ;
  bool has_child() const;
  void set_has_child(bool value);

  private:
  bool _internal_has_child() const;
  void _internal_set_has_child(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.NoteData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 3,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::NoteComment > comment_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr subject_id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr parent_id_;
    int type_;
    int state_;
    ::uint32_t ct_;
    ::uint32_t ut_;
    bool has_child_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class ListingData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.ListingData) */ {
 public:
  inline ListingData() : ListingData(nullptr) {}
  ~ListingData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListingData(::google::protobuf::internal::ConstantInitialized);

  inline ListingData(const ListingData& from)
      : ListingData(nullptr, from) {}
  ListingData(ListingData&& from) noexcept
    : ListingData() {
    *this = ::std::move(from);
  }

  inline ListingData& operator=(const ListingData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListingData& operator=(ListingData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListingData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListingData* internal_default_instance() {
    return reinterpret_cast<const ListingData*>(
               &_ListingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListingData& a, ListingData& b) {
    a.Swap(&b);
  }
  inline void Swap(ListingData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListingData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListingData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListingData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListingData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListingData& from) {
    ListingData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListingData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.ListingData";
  }
  protected:
  explicit ListingData(::google::protobuf::Arena* arena);
  ListingData(::google::protobuf::Arena* arena, const ListingData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepFieldNumber = 12,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kAliasFieldNumber = 3,
    kOwnerFieldNumber = 5,
    kCreatorFieldNumber = 6,
    kOwnerNameFieldNumber = 13,
    kDescFieldNumber = 14,
    kSizeFieldNumber = 7,
    kLockedFieldNumber = 4,
    kExternalFieldNumber = 8,
    kDepsAvailFieldNumber = 11,
    kNotesFieldNumber = 9,
    kGenFieldNumber = 10,
  };
  // repeated .SDMS.DependencyData dep = 12;
  int dep_size() const;
  private:
  int _internal_dep_size() const;

  public:
  void clear_dep() ;
  ::SDMS::DependencyData* mutable_dep(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::DependencyData >*
      mutable_dep();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>& _internal_dep() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>* _internal_mutable_dep();
  public:
  const ::SDMS::DependencyData& dep(int index) const;
  ::SDMS::DependencyData* add_dep();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::DependencyData >&
      dep() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string alias = 3;
  bool has_alias() const;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // optional string owner = 5;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* value);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // optional string creator = 6;
  bool has_creator() const;
  void clear_creator() ;
  const std::string& creator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* value);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // optional string owner_name = 13;
  bool has_owner_name() const;
  void clear_owner_name() ;
  const std::string& owner_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner_name(Arg_&& arg, Args_... args);
  std::string* mutable_owner_name();
  PROTOBUF_NODISCARD std::string* release_owner_name();
  void set_allocated_owner_name(std::string* value);

  private:
  const std::string& _internal_owner_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_name(
      const std::string& value);
  std::string* _internal_mutable_owner_name();

  public:
  // optional string desc = 14;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional double size = 7;
  bool has_size() const;
  void clear_size() ;
  double size() const;
  void set_size(double value);

  private:
  double _internal_size() const;
  void _internal_set_size(double value);

  public:
  // optional bool locked = 4;
  bool has_locked() const;
  void clear_locked() ;
  bool locked() const;
  void set_locked(bool value);

  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);

  public:
  // optional bool external = 8;
  bool has_external() const;
  void clear_external() ;
  bool external() const;
  void set_external(bool value);

  private:
  bool _internal_external() const;
  void _internal_set_external(bool value);

  public:
  // optional bool deps_avail = 11;
  bool has_deps_avail() const;
  void clear_deps_avail() ;
  bool deps_avail() const;
  void set_deps_avail(bool value);

  private:
  bool _internal_deps_avail() const;
  void _internal_set_deps_avail(bool value);

  public:
  // optional uint32 notes = 9;
  bool has_notes() const;
  void clear_notes() ;
  ::uint32_t notes() const;
  void set_notes(::uint32_t value);

  private:
  ::uint32_t _internal_notes() const;
  void _internal_set_notes(::uint32_t value);

  public:
  // optional int32 gen = 10;
  bool has_gen() const;
  void clear_gen() ;
  ::int32_t gen() const;
  void set_gen(::int32_t value);

  private:
  ::int32_t _internal_gen() const;
  void _internal_set_gen(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.ListingData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 1,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::DependencyData > dep_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    ::google::protobuf::internal::ArenaStringPtr creator_;
    ::google::protobuf::internal::ArenaStringPtr owner_name_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    double size_;
    bool locked_;
    bool external_;
    bool deps_avail_;
    ::uint32_t notes_;
    ::int32_t gen_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class AllocData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.AllocData) */ {
 public:
  inline AllocData() : AllocData(nullptr) {}
  ~AllocData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocData(::google::protobuf::internal::ConstantInitialized);

  inline AllocData(const AllocData& from)
      : AllocData(nullptr, from) {}
  AllocData(AllocData&& from) noexcept
    : AllocData() {
    *this = ::std::move(from);
  }

  inline AllocData& operator=(const AllocData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocData& operator=(AllocData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocData* internal_default_instance() {
    return reinterpret_cast<const AllocData*>(
               &_AllocData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AllocData& a, AllocData& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllocData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AllocData& from) {
    AllocData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AllocData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.AllocData";
  }
  protected:
  explicit AllocData(::google::protobuf::Arena* arena);
  AllocData(::google::protobuf::Arena* arena, const AllocData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepoFieldNumber = 1,
    kPathFieldNumber = 6,
    kIdFieldNumber = 7,
    kStatsFieldNumber = 9,
    kDataLimitFieldNumber = 2,
    kDataSizeFieldNumber = 3,
    kRecLimitFieldNumber = 4,
    kRecCountFieldNumber = 5,
    kIsDefFieldNumber = 8,
  };
  // required string repo = 1;
  bool has_repo() const;
  void clear_repo() ;
  const std::string& repo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo(Arg_&& arg, Args_... args);
  std::string* mutable_repo();
  PROTOBUF_NODISCARD std::string* release_repo();
  void set_allocated_repo(std::string* value);

  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(
      const std::string& value);
  std::string* _internal_mutable_repo();

  public:
  // required string path = 6;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional string id = 7;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .SDMS.AllocStatsData stats = 9;
  bool has_stats() const;
  void clear_stats() ;
  const ::SDMS::AllocStatsData& stats() const;
  PROTOBUF_NODISCARD ::SDMS::AllocStatsData* release_stats();
  ::SDMS::AllocStatsData* mutable_stats();
  void set_allocated_stats(::SDMS::AllocStatsData* value);
  void unsafe_arena_set_allocated_stats(::SDMS::AllocStatsData* value);
  ::SDMS::AllocStatsData* unsafe_arena_release_stats();

  private:
  const ::SDMS::AllocStatsData& _internal_stats() const;
  ::SDMS::AllocStatsData* _internal_mutable_stats();

  public:
  // required uint64 data_limit = 2;
  bool has_data_limit() const;
  void clear_data_limit() ;
  ::uint64_t data_limit() const;
  void set_data_limit(::uint64_t value);

  private:
  ::uint64_t _internal_data_limit() const;
  void _internal_set_data_limit(::uint64_t value);

  public:
  // required uint64 data_size = 3;
  bool has_data_size() const;
  void clear_data_size() ;
  ::uint64_t data_size() const;
  void set_data_size(::uint64_t value);

  private:
  ::uint64_t _internal_data_size() const;
  void _internal_set_data_size(::uint64_t value);

  public:
  // required uint32 rec_limit = 4;
  bool has_rec_limit() const;
  void clear_rec_limit() ;
  ::uint32_t rec_limit() const;
  void set_rec_limit(::uint32_t value);

  private:
  ::uint32_t _internal_rec_limit() const;
  void _internal_set_rec_limit(::uint32_t value);

  public:
  // required uint32 rec_count = 5;
  bool has_rec_count() const;
  void clear_rec_count() ;
  ::uint32_t rec_count() const;
  void set_rec_count(::uint32_t value);

  private:
  ::uint32_t _internal_rec_count() const;
  void _internal_set_rec_count(::uint32_t value);

  public:
  // optional bool is_def = 8;
  bool has_is_def() const;
  void clear_is_def() ;
  bool is_def() const;
  void set_is_def(bool value);

  private:
  bool _internal_is_def() const;
  void _internal_set_is_def(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.AllocData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr repo_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::SDMS::AllocStatsData* stats_;
    ::uint64_t data_limit_;
    ::uint64_t data_size_;
    ::uint32_t rec_limit_;
    ::uint32_t rec_count_;
    bool is_def_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class UserData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.UserData) */ {
 public:
  inline UserData() : UserData(nullptr) {}
  ~UserData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserData(::google::protobuf::internal::ConstantInitialized);

  inline UserData(const UserData& from)
      : UserData(nullptr, from) {}
  UserData(UserData&& from) noexcept
    : UserData() {
    *this = ::std::move(from);
  }

  inline UserData& operator=(const UserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserData& operator=(UserData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserData& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserData* internal_default_instance() {
    return reinterpret_cast<const UserData*>(
               &_UserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserData& a, UserData& b) {
    a.Swap(&b);
  }
  inline void Swap(UserData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserData& from) {
    UserData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.UserData";
  }
  protected:
  explicit UserData(::google::protobuf::Arena* arena);
  UserData(::google::protobuf::Arena* arena, const UserData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentFieldNumber = 8,
    kAllocFieldNumber = 9,
    kUidFieldNumber = 1,
    kNameLastFieldNumber = 2,
    kNameFirstFieldNumber = 3,
    kEmailFieldNumber = 4,
    kOptionsFieldNumber = 5,
    kIsAdminFieldNumber = 6,
    kIsRepoAdminFieldNumber = 7,
  };
  // repeated string ident = 8;
  int ident_size() const;
  private:
  int _internal_ident_size() const;

  public:
  void clear_ident() ;
  const std::string& ident(int index) const;
  std::string* mutable_ident(int index);
  void set_ident(int index, const std::string& value);
  void set_ident(int index, std::string&& value);
  void set_ident(int index, const char* value);
  void set_ident(int index, const char* value, std::size_t size);
  void set_ident(int index, absl::string_view value);
  std::string* add_ident();
  void add_ident(const std::string& value);
  void add_ident(std::string&& value);
  void add_ident(const char* value);
  void add_ident(const char* value, std::size_t size);
  void add_ident(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& ident() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_ident();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_ident() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_ident();

  public:
  // repeated .SDMS.AllocData alloc = 9;
  int alloc_size() const;
  private:
  int _internal_alloc_size() const;

  public:
  void clear_alloc() ;
  ::SDMS::AllocData* mutable_alloc(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData >*
      mutable_alloc();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>& _internal_alloc() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>* _internal_mutable_alloc();
  public:
  const ::SDMS::AllocData& alloc(int index) const;
  ::SDMS::AllocData* add_alloc();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData >&
      alloc() const;
  // required string uid = 1;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // required string name_last = 2;
  bool has_name_last() const;
  void clear_name_last() ;
  const std::string& name_last() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name_last(Arg_&& arg, Args_... args);
  std::string* mutable_name_last();
  PROTOBUF_NODISCARD std::string* release_name_last();
  void set_allocated_name_last(std::string* value);

  private:
  const std::string& _internal_name_last() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_last(
      const std::string& value);
  std::string* _internal_mutable_name_last();

  public:
  // required string name_first = 3;
  bool has_name_first() const;
  void clear_name_first() ;
  const std::string& name_first() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name_first(Arg_&& arg, Args_... args);
  std::string* mutable_name_first();
  PROTOBUF_NODISCARD std::string* release_name_first();
  void set_allocated_name_first(std::string* value);

  private:
  const std::string& _internal_name_first() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_first(
      const std::string& value);
  std::string* _internal_mutable_name_first();

  public:
  // optional string email = 4;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // optional string options = 5;
  bool has_options() const;
  void clear_options() ;
  const std::string& options() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_options(Arg_&& arg, Args_... args);
  std::string* mutable_options();
  PROTOBUF_NODISCARD std::string* release_options();
  void set_allocated_options(std::string* value);

  private:
  const std::string& _internal_options() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_options(
      const std::string& value);
  std::string* _internal_mutable_options();

  public:
  // optional bool is_admin = 6;
  bool has_is_admin() const;
  void clear_is_admin() ;
  bool is_admin() const;
  void set_is_admin(bool value);

  private:
  bool _internal_is_admin() const;
  void _internal_set_is_admin(bool value);

  public:
  // optional bool is_repo_admin = 7;
  bool has_is_repo_admin() const;
  void clear_is_repo_admin() ;
  bool is_repo_admin() const;
  void set_is_repo_admin(bool value);

  private:
  bool _internal_is_repo_admin() const;
  void _internal_set_is_repo_admin(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.UserData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      69, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> ident_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData > alloc_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr name_last_;
    ::google::protobuf::internal::ArenaStringPtr name_first_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr options_;
    bool is_admin_;
    bool is_repo_admin_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class ProjectData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.ProjectData) */ {
 public:
  inline ProjectData() : ProjectData(nullptr) {}
  ~ProjectData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectData(::google::protobuf::internal::ConstantInitialized);

  inline ProjectData(const ProjectData& from)
      : ProjectData(nullptr, from) {}
  ProjectData(ProjectData&& from) noexcept
    : ProjectData() {
    *this = ::std::move(from);
  }

  inline ProjectData& operator=(const ProjectData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectData& operator=(ProjectData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectData* internal_default_instance() {
    return reinterpret_cast<const ProjectData*>(
               &_ProjectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProjectData& a, ProjectData& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProjectData& from) {
    ProjectData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.ProjectData";
  }
  protected:
  explicit ProjectData(::google::protobuf::Arena* arena);
  ProjectData(::google::protobuf::Arena* arena, const ProjectData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminFieldNumber = 7,
    kMemberFieldNumber = 8,
    kAllocFieldNumber = 9,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescFieldNumber = 3,
    kOwnerFieldNumber = 4,
    kCtFieldNumber = 5,
    kUtFieldNumber = 6,
  };
  // repeated string admin = 7;
  int admin_size() const;
  private:
  int _internal_admin_size() const;

  public:
  void clear_admin() ;
  const std::string& admin(int index) const;
  std::string* mutable_admin(int index);
  void set_admin(int index, const std::string& value);
  void set_admin(int index, std::string&& value);
  void set_admin(int index, const char* value);
  void set_admin(int index, const char* value, std::size_t size);
  void set_admin(int index, absl::string_view value);
  std::string* add_admin();
  void add_admin(const std::string& value);
  void add_admin(std::string&& value);
  void add_admin(const char* value);
  void add_admin(const char* value, std::size_t size);
  void add_admin(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_admin();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_admin() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_admin();

  public:
  // repeated string member = 8;
  int member_size() const;
  private:
  int _internal_member_size() const;

  public:
  void clear_member() ;
  const std::string& member(int index) const;
  std::string* mutable_member(int index);
  void set_member(int index, const std::string& value);
  void set_member(int index, std::string&& value);
  void set_member(int index, const char* value);
  void set_member(int index, const char* value, std::size_t size);
  void set_member(int index, absl::string_view value);
  std::string* add_member();
  void add_member(const std::string& value);
  void add_member(std::string&& value);
  void add_member(const char* value);
  void add_member(const char* value, std::size_t size);
  void add_member(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& member() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_member();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_member() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_member();

  public:
  // repeated .SDMS.AllocData alloc = 9;
  int alloc_size() const;
  private:
  int _internal_alloc_size() const;

  public:
  void clear_alloc() ;
  ::SDMS::AllocData* mutable_alloc(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData >*
      mutable_alloc();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>& _internal_alloc() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>* _internal_mutable_alloc();
  public:
  const ::SDMS::AllocData& alloc(int index) const;
  ::SDMS::AllocData* add_alloc();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData >&
      alloc() const;
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // optional string owner = 4;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* value);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // optional uint32 ct = 5;
  bool has_ct() const;
  void clear_ct() ;
  ::uint32_t ct() const;
  void set_ct(::uint32_t value);

  private:
  ::uint32_t _internal_ct() const;
  void _internal_set_ct(::uint32_t value);

  public:
  // optional uint32 ut = 6;
  bool has_ut() const;
  void clear_ut() ;
  ::uint32_t ut() const;
  void set_ut(::uint32_t value);

  private:
  ::uint32_t _internal_ut() const;
  void _internal_set_ut(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SDMS.ProjectData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> admin_;
    ::google::protobuf::RepeatedPtrField<std::string> member_;
    ::google::protobuf::RepeatedPtrField< ::SDMS::AllocData > alloc_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    ::uint32_t ct_;
    ::uint32_t ut_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};// -------------------------------------------------------------------

class PathData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SDMS.PathData) */ {
 public:
  inline PathData() : PathData(nullptr) {}
  ~PathData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PathData(::google::protobuf::internal::ConstantInitialized);

  inline PathData(const PathData& from)
      : PathData(nullptr, from) {}
  PathData(PathData&& from) noexcept
    : PathData() {
    *this = ::std::move(from);
  }

  inline PathData& operator=(const PathData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathData& operator=(PathData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathData* internal_default_instance() {
    return reinterpret_cast<const PathData*>(
               &_PathData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PathData& a, PathData& b) {
    a.Swap(&b);
  }
  inline void Swap(PathData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PathData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PathData& from) {
    PathData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PathData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SDMS.PathData";
  }
  protected:
  explicit PathData(::google::protobuf::Arena* arena);
  PathData(::google::protobuf::Arena* arena, const PathData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // repeated .SDMS.ListingData item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;

  public:
  void clear_item() ;
  ::SDMS::ListingData* mutable_item(int index);
  ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >*
      mutable_item();
  private:
  const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& _internal_item() const;
  ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* _internal_mutable_item();
  public:
  const ::SDMS::ListingData& item(int index) const;
  ::SDMS::ListingData* add_item();
  const ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData >&
      item() const;
  // @@protoc_insertion_point(class_scope:SDMS.PathData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::SDMS::ListingData > item_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SDMS_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AllocStatsData

// required string repo = 1;
inline bool AllocStatsData::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AllocStatsData::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllocStatsData::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.AllocStatsData.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocStatsData::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.AllocStatsData.repo)
}
inline std::string* AllocStatsData::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.AllocStatsData.repo)
  return _s;
}
inline const std::string& AllocStatsData::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void AllocStatsData::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* AllocStatsData::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* AllocStatsData::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.AllocStatsData.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AllocStatsData::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.AllocStatsData.repo)
}

// required uint32 rec_count = 2;
inline bool AllocStatsData::has_rec_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AllocStatsData::clear_rec_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rec_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AllocStatsData::rec_count() const {
  // @@protoc_insertion_point(field_get:SDMS.AllocStatsData.rec_count)
  return _internal_rec_count();
}
inline void AllocStatsData::set_rec_count(::uint32_t value) {
  _internal_set_rec_count(value);
  // @@protoc_insertion_point(field_set:SDMS.AllocStatsData.rec_count)
}
inline ::uint32_t AllocStatsData::_internal_rec_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rec_count_;
}
inline void AllocStatsData::_internal_set_rec_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rec_count_ = value;
}

// required uint32 file_count = 3;
inline bool AllocStatsData::has_file_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AllocStatsData::clear_file_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.file_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t AllocStatsData::file_count() const {
  // @@protoc_insertion_point(field_get:SDMS.AllocStatsData.file_count)
  return _internal_file_count();
}
inline void AllocStatsData::set_file_count(::uint32_t value) {
  _internal_set_file_count(value);
  // @@protoc_insertion_point(field_set:SDMS.AllocStatsData.file_count)
}
inline ::uint32_t AllocStatsData::_internal_file_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.file_count_;
}
inline void AllocStatsData::_internal_set_file_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.file_count_ = value;
}

// required uint64 data_size = 4;
inline bool AllocStatsData::has_data_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AllocStatsData::clear_data_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t AllocStatsData::data_size() const {
  // @@protoc_insertion_point(field_get:SDMS.AllocStatsData.data_size)
  return _internal_data_size();
}
inline void AllocStatsData::set_data_size(::uint64_t value) {
  _internal_set_data_size(value);
  // @@protoc_insertion_point(field_set:SDMS.AllocStatsData.data_size)
}
inline ::uint64_t AllocStatsData::_internal_data_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_size_;
}
inline void AllocStatsData::_internal_set_data_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.data_size_ = value;
}

// repeated uint32 histogram = 5;
inline int AllocStatsData::_internal_histogram_size() const {
  return _internal_histogram().size();
}
inline int AllocStatsData::histogram_size() const {
  return _internal_histogram_size();
}
inline void AllocStatsData::clear_histogram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.histogram_.Clear();
}
inline ::uint32_t AllocStatsData::histogram(int index) const {
  // @@protoc_insertion_point(field_get:SDMS.AllocStatsData.histogram)
  return _internal_histogram().Get(index);
}
inline void AllocStatsData::set_histogram(int index, ::uint32_t value) {
  _internal_mutable_histogram()->Set(index, value);
  // @@protoc_insertion_point(field_set:SDMS.AllocStatsData.histogram)
}
inline void AllocStatsData::add_histogram(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_histogram()->Add(value);
  // @@protoc_insertion_point(field_add:SDMS.AllocStatsData.histogram)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& AllocStatsData::histogram() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.AllocStatsData.histogram)
  return _internal_histogram();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* AllocStatsData::mutable_histogram()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.AllocStatsData.histogram)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_histogram();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& AllocStatsData::_internal_histogram()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.histogram_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* AllocStatsData::_internal_mutable_histogram() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.histogram_;
}

// -------------------------------------------------------------------

// AllocData

// required string repo = 1;
inline bool AllocData::has_repo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AllocData::clear_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllocData::repo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.repo)
  return _internal_repo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocData::set_repo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.AllocData.repo)
}
inline std::string* AllocData::mutable_repo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:SDMS.AllocData.repo)
  return _s;
}
inline const std::string& AllocData::_internal_repo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_.Get();
}
inline void AllocData::_internal_set_repo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_.Set(value, GetArena());
}
inline std::string* AllocData::_internal_mutable_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_.Mutable( GetArena());
}
inline std::string* AllocData::release_repo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.AllocData.repo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AllocData::set_allocated_repo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_.IsDefault()) {
          _impl_.repo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.AllocData.repo)
}

// required uint64 data_limit = 2;
inline bool AllocData::has_data_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AllocData::clear_data_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_limit_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t AllocData::data_limit() const {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.data_limit)
  return _internal_data_limit();
}
inline void AllocData::set_data_limit(::uint64_t value) {
  _internal_set_data_limit(value);
  // @@protoc_insertion_point(field_set:SDMS.AllocData.data_limit)
}
inline ::uint64_t AllocData::_internal_data_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_limit_;
}
inline void AllocData::_internal_set_data_limit(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.data_limit_ = value;
}

// required uint64 data_size = 3;
inline bool AllocData::has_data_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void AllocData::clear_data_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t AllocData::data_size() const {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.data_size)
  return _internal_data_size();
}
inline void AllocData::set_data_size(::uint64_t value) {
  _internal_set_data_size(value);
  // @@protoc_insertion_point(field_set:SDMS.AllocData.data_size)
}
inline ::uint64_t AllocData::_internal_data_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_size_;
}
inline void AllocData::_internal_set_data_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.data_size_ = value;
}

// required uint32 rec_limit = 4;
inline bool AllocData::has_rec_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void AllocData::clear_rec_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rec_limit_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t AllocData::rec_limit() const {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.rec_limit)
  return _internal_rec_limit();
}
inline void AllocData::set_rec_limit(::uint32_t value) {
  _internal_set_rec_limit(value);
  // @@protoc_insertion_point(field_set:SDMS.AllocData.rec_limit)
}
inline ::uint32_t AllocData::_internal_rec_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rec_limit_;
}
inline void AllocData::_internal_set_rec_limit(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.rec_limit_ = value;
}

// required uint32 rec_count = 5;
inline bool AllocData::has_rec_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void AllocData::clear_rec_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rec_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t AllocData::rec_count() const {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.rec_count)
  return _internal_rec_count();
}
inline void AllocData::set_rec_count(::uint32_t value) {
  _internal_set_rec_count(value);
  // @@protoc_insertion_point(field_set:SDMS.AllocData.rec_count)
}
inline ::uint32_t AllocData::_internal_rec_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rec_count_;
}
inline void AllocData::_internal_set_rec_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.rec_count_ = value;
}

// required string path = 6;
inline bool AllocData::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AllocData::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AllocData::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocData::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.AllocData.path)
}
inline std::string* AllocData::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.AllocData.path)
  return _s;
}
inline const std::string& AllocData::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void AllocData::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* AllocData::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* AllocData::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.AllocData.path)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AllocData::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.AllocData.path)
}

// optional string id = 7;
inline bool AllocData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AllocData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AllocData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.AllocData.id)
}
inline std::string* AllocData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.AllocData.id)
  return _s;
}
inline const std::string& AllocData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void AllocData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* AllocData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* AllocData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.AllocData.id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AllocData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.AllocData.id)
}

// optional bool is_def = 8;
inline bool AllocData::has_is_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void AllocData::clear_is_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_def_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool AllocData::is_def() const {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.is_def)
  return _internal_is_def();
}
inline void AllocData::set_is_def(bool value) {
  _internal_set_is_def(value);
  // @@protoc_insertion_point(field_set:SDMS.AllocData.is_def)
}
inline bool AllocData::_internal_is_def() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_def_;
}
inline void AllocData::_internal_set_is_def(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.is_def_ = value;
}

// optional .SDMS.AllocStatsData stats = 9;
inline bool AllocData::has_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stats_ != nullptr);
  return value;
}
inline void AllocData::clear_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stats_ != nullptr) _impl_.stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::SDMS::AllocStatsData& AllocData::_internal_stats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SDMS::AllocStatsData* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::SDMS::AllocStatsData&>(::SDMS::_AllocStatsData_default_instance_);
}
inline const ::SDMS::AllocStatsData& AllocData::stats() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.AllocData.stats)
  return _internal_stats();
}
inline void AllocData::unsafe_arena_set_allocated_stats(::SDMS::AllocStatsData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = reinterpret_cast<::SDMS::AllocStatsData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SDMS.AllocData.stats)
}
inline ::SDMS::AllocStatsData* AllocData::release_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SDMS::AllocStatsData* released = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SDMS::AllocStatsData* AllocData::unsafe_arena_release_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.AllocData.stats)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SDMS::AllocStatsData* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::SDMS::AllocStatsData* AllocData::_internal_mutable_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::SDMS::AllocStatsData>(GetArena());
    _impl_.stats_ = reinterpret_cast<::SDMS::AllocStatsData*>(p);
  }
  return _impl_.stats_;
}
inline ::SDMS::AllocStatsData* AllocData::mutable_stats() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SDMS::AllocStatsData* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:SDMS.AllocData.stats)
  return _msg;
}
inline void AllocData::set_allocated_stats(::SDMS::AllocStatsData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::SDMS::AllocStatsData*>(_impl_.stats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::SDMS::AllocStatsData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.stats_ = reinterpret_cast<::SDMS::AllocStatsData*>(value);
  // @@protoc_insertion_point(field_set_allocated:SDMS.AllocData.stats)
}

// -------------------------------------------------------------------

// DependencyData

// required string id = 1;
inline bool DependencyData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DependencyData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DependencyData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.DependencyData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DependencyData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.DependencyData.id)
}
inline std::string* DependencyData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.DependencyData.id)
  return _s;
}
inline const std::string& DependencyData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DependencyData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DependencyData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DependencyData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.DependencyData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DependencyData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.DependencyData.id)
}

// optional string alias = 2;
inline bool DependencyData::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DependencyData::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DependencyData::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.DependencyData.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DependencyData::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.DependencyData.alias)
}
inline std::string* DependencyData::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:SDMS.DependencyData.alias)
  return _s;
}
inline const std::string& DependencyData::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void DependencyData::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* DependencyData::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* DependencyData::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.DependencyData.alias)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.alias_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DependencyData::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.DependencyData.alias)
}

// optional uint32 notes = 3;
inline bool DependencyData::has_notes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DependencyData::clear_notes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t DependencyData::notes() const {
  // @@protoc_insertion_point(field_get:SDMS.DependencyData.notes)
  return _internal_notes();
}
inline void DependencyData::set_notes(::uint32_t value) {
  _internal_set_notes(value);
  // @@protoc_insertion_point(field_set:SDMS.DependencyData.notes)
}
inline ::uint32_t DependencyData::_internal_notes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notes_;
}
inline void DependencyData::_internal_set_notes(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.notes_ = value;
}

// required .SDMS.DependencyType type = 4;
inline bool DependencyData::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DependencyData::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SDMS::DependencyType DependencyData::type() const {
  // @@protoc_insertion_point(field_get:SDMS.DependencyData.type)
  return _internal_type();
}
inline void DependencyData::set_type(::SDMS::DependencyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SDMS.DependencyData.type)
}
inline ::SDMS::DependencyType DependencyData::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::DependencyType>(_impl_.type_);
}
inline void DependencyData::_internal_set_type(::SDMS::DependencyType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::DependencyType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// required .SDMS.DependencyDir dir = 5;
inline bool DependencyData::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DependencyData::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dir_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::SDMS::DependencyDir DependencyData::dir() const {
  // @@protoc_insertion_point(field_get:SDMS.DependencyData.dir)
  return _internal_dir();
}
inline void DependencyData::set_dir(::SDMS::DependencyDir value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:SDMS.DependencyData.dir)
}
inline ::SDMS::DependencyDir DependencyData::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::DependencyDir>(_impl_.dir_);
}
inline void DependencyData::_internal_set_dir(::SDMS::DependencyDir value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::DependencyDir_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dir_ = value;
}

// -------------------------------------------------------------------

// DependencySpecData

// required string id = 1;
inline bool DependencySpecData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DependencySpecData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DependencySpecData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.DependencySpecData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DependencySpecData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.DependencySpecData.id)
}
inline std::string* DependencySpecData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.DependencySpecData.id)
  return _s;
}
inline const std::string& DependencySpecData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DependencySpecData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DependencySpecData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DependencySpecData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.DependencySpecData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DependencySpecData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.DependencySpecData.id)
}

// required .SDMS.DependencyType type = 2;
inline bool DependencySpecData::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DependencySpecData::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SDMS::DependencyType DependencySpecData::type() const {
  // @@protoc_insertion_point(field_get:SDMS.DependencySpecData.type)
  return _internal_type();
}
inline void DependencySpecData::set_type(::SDMS::DependencyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SDMS.DependencySpecData.type)
}
inline ::SDMS::DependencyType DependencySpecData::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::DependencyType>(_impl_.type_);
}
inline void DependencySpecData::_internal_set_type(::SDMS::DependencyType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::DependencyType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// UserData

// required string uid = 1;
inline bool UserData::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserData::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserData::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.UserData.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserData::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.UserData.uid)
}
inline std::string* UserData::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.UserData.uid)
  return _s;
}
inline const std::string& UserData::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void UserData::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* UserData::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* UserData::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.UserData.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserData::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.UserData.uid)
}

// required string name_last = 2;
inline bool UserData::has_name_last() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserData::clear_name_last() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_last_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserData::name_last() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.UserData.name_last)
  return _internal_name_last();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserData::set_name_last(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_last_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.UserData.name_last)
}
inline std::string* UserData::mutable_name_last() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name_last();
  // @@protoc_insertion_point(field_mutable:SDMS.UserData.name_last)
  return _s;
}
inline const std::string& UserData::_internal_name_last() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_last_.Get();
}
inline void UserData::_internal_set_name_last(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_last_.Set(value, GetArena());
}
inline std::string* UserData::_internal_mutable_name_last() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_last_.Mutable( GetArena());
}
inline std::string* UserData::release_name_last() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.UserData.name_last)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_last_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_last_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserData::set_allocated_name_last(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_last_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_last_.IsDefault()) {
          _impl_.name_last_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.UserData.name_last)
}

// required string name_first = 3;
inline bool UserData::has_name_first() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserData::clear_name_first() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_first_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserData::name_first() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.UserData.name_first)
  return _internal_name_first();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserData::set_name_first(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.name_first_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.UserData.name_first)
}
inline std::string* UserData::mutable_name_first() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name_first();
  // @@protoc_insertion_point(field_mutable:SDMS.UserData.name_first)
  return _s;
}
inline const std::string& UserData::_internal_name_first() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_first_.Get();
}
inline void UserData::_internal_set_name_first(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.name_first_.Set(value, GetArena());
}
inline std::string* UserData::_internal_mutable_name_first() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.name_first_.Mutable( GetArena());
}
inline std::string* UserData::release_name_first() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.UserData.name_first)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.name_first_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_first_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserData::set_allocated_name_first(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.name_first_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_first_.IsDefault()) {
          _impl_.name_first_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.UserData.name_first)
}

// optional string email = 4;
inline bool UserData::has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserData::clear_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserData::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.UserData.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserData::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.UserData.email)
}
inline std::string* UserData::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:SDMS.UserData.email)
  return _s;
}
inline const std::string& UserData::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void UserData::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* UserData::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* UserData::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.UserData.email)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.email_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserData::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.UserData.email)
}

// optional string options = 5;
inline bool UserData::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UserData::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.options_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserData::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.UserData.options)
  return _internal_options();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserData::set_options(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.options_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.UserData.options)
}
inline std::string* UserData::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:SDMS.UserData.options)
  return _s;
}
inline const std::string& UserData::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.options_.Get();
}
inline void UserData::_internal_set_options(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.options_.Set(value, GetArena());
}
inline std::string* UserData::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.options_.Mutable( GetArena());
}
inline std::string* UserData::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.UserData.options)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.options_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.options_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserData::set_allocated_options(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.options_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.options_.IsDefault()) {
          _impl_.options_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.UserData.options)
}

// optional bool is_admin = 6;
inline bool UserData::has_is_admin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserData::clear_is_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_admin_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool UserData::is_admin() const {
  // @@protoc_insertion_point(field_get:SDMS.UserData.is_admin)
  return _internal_is_admin();
}
inline void UserData::set_is_admin(bool value) {
  _internal_set_is_admin(value);
  // @@protoc_insertion_point(field_set:SDMS.UserData.is_admin)
}
inline bool UserData::_internal_is_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_admin_;
}
inline void UserData::_internal_set_is_admin(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_admin_ = value;
}

// optional bool is_repo_admin = 7;
inline bool UserData::has_is_repo_admin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UserData::clear_is_repo_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_repo_admin_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool UserData::is_repo_admin() const {
  // @@protoc_insertion_point(field_get:SDMS.UserData.is_repo_admin)
  return _internal_is_repo_admin();
}
inline void UserData::set_is_repo_admin(bool value) {
  _internal_set_is_repo_admin(value);
  // @@protoc_insertion_point(field_set:SDMS.UserData.is_repo_admin)
}
inline bool UserData::_internal_is_repo_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_repo_admin_;
}
inline void UserData::_internal_set_is_repo_admin(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_repo_admin_ = value;
}

// repeated string ident = 8;
inline int UserData::_internal_ident_size() const {
  return _internal_ident().size();
}
inline int UserData::ident_size() const {
  return _internal_ident_size();
}
inline void UserData::clear_ident() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ident_.Clear();
}
inline std::string* UserData::add_ident()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_ident()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.UserData.ident)
  return _s;
}
inline const std::string& UserData::ident(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.UserData.ident)
  return _internal_ident().Get(index);
}
inline std::string* UserData::mutable_ident(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.UserData.ident)
  return _internal_mutable_ident()->Mutable(index);
}
inline void UserData::set_ident(int index, const std::string& value) {
  _internal_mutable_ident()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.UserData.ident)
}
inline void UserData::set_ident(int index, std::string&& value) {
  _internal_mutable_ident()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.UserData.ident)
}
inline void UserData::set_ident(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ident()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.UserData.ident)
}
inline void UserData::set_ident(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_ident()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.UserData.ident)
}
inline void UserData::set_ident(int index, absl::string_view value) {
  _internal_mutable_ident()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.UserData.ident)
}
inline void UserData::add_ident(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ident()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.UserData.ident)
}
inline void UserData::add_ident(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ident()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.UserData.ident)
}
inline void UserData::add_ident(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ident()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.UserData.ident)
}
inline void UserData::add_ident(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ident()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.UserData.ident)
}
inline void UserData::add_ident(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ident()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.UserData.ident)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserData::ident() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.UserData.ident)
  return _internal_ident();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserData::mutable_ident() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.UserData.ident)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ident();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserData::_internal_ident() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ident_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserData::_internal_mutable_ident() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ident_;
}

// repeated .SDMS.AllocData alloc = 9;
inline int UserData::_internal_alloc_size() const {
  return _internal_alloc().size();
}
inline int UserData::alloc_size() const {
  return _internal_alloc_size();
}
inline void UserData::clear_alloc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alloc_.Clear();
}
inline ::SDMS::AllocData* UserData::mutable_alloc(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.UserData.alloc)
  return _internal_mutable_alloc()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>* UserData::mutable_alloc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.UserData.alloc)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alloc();
}
inline const ::SDMS::AllocData& UserData::alloc(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.UserData.alloc)
  return _internal_alloc().Get(index);
}
inline ::SDMS::AllocData* UserData::add_alloc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::AllocData* _add = _internal_mutable_alloc()->Add();
  // @@protoc_insertion_point(field_add:SDMS.UserData.alloc)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>& UserData::alloc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.UserData.alloc)
  return _internal_alloc();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>&
UserData::_internal_alloc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alloc_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>*
UserData::_internal_mutable_alloc() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alloc_;
}

// -------------------------------------------------------------------

// ProjectData

// required string id = 1;
inline bool ProjectData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProjectData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.id)
}
inline std::string* ProjectData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.ProjectData.id)
  return _s;
}
inline const std::string& ProjectData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ProjectData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ProjectData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ProjectData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ProjectData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ProjectData.id)
}

// required string title = 2;
inline bool ProjectData::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ProjectData::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProjectData::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectData::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.title)
}
inline std::string* ProjectData::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.ProjectData.title)
  return _s;
}
inline const std::string& ProjectData::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void ProjectData::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* ProjectData::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* ProjectData::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ProjectData.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectData::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ProjectData.title)
}

// optional string desc = 3;
inline bool ProjectData::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ProjectData::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProjectData::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectData::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.desc)
}
inline std::string* ProjectData::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.ProjectData.desc)
  return _s;
}
inline const std::string& ProjectData::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void ProjectData::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* ProjectData::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* ProjectData::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ProjectData.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectData::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ProjectData.desc)
}

// optional string owner = 4;
inline bool ProjectData::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ProjectData::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ProjectData::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProjectData::set_owner(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.owner)
}
inline std::string* ProjectData::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:SDMS.ProjectData.owner)
  return _s;
}
inline const std::string& ProjectData::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_.Get();
}
inline void ProjectData::_internal_set_owner(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.owner_.Set(value, GetArena());
}
inline std::string* ProjectData::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.owner_.Mutable( GetArena());
}
inline std::string* ProjectData::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ProjectData.owner)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ProjectData::set_allocated_owner(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ProjectData.owner)
}

// optional uint32 ct = 5;
inline bool ProjectData::has_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ProjectData::clear_ct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ct_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t ProjectData::ct() const {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.ct)
  return _internal_ct();
}
inline void ProjectData::set_ct(::uint32_t value) {
  _internal_set_ct(value);
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.ct)
}
inline ::uint32_t ProjectData::_internal_ct() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ct_;
}
inline void ProjectData::_internal_set_ct(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ct_ = value;
}

// optional uint32 ut = 6;
inline bool ProjectData::has_ut() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ProjectData::clear_ut() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ut_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t ProjectData::ut() const {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.ut)
  return _internal_ut();
}
inline void ProjectData::set_ut(::uint32_t value) {
  _internal_set_ut(value);
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.ut)
}
inline ::uint32_t ProjectData::_internal_ut() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ut_;
}
inline void ProjectData::_internal_set_ut(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ut_ = value;
}

// repeated string admin = 7;
inline int ProjectData::_internal_admin_size() const {
  return _internal_admin().size();
}
inline int ProjectData::admin_size() const {
  return _internal_admin_size();
}
inline void ProjectData::clear_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_.Clear();
}
inline std::string* ProjectData::add_admin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_admin()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.ProjectData.admin)
  return _s;
}
inline const std::string& ProjectData::admin(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.admin)
  return _internal_admin().Get(index);
}
inline std::string* ProjectData::mutable_admin(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.ProjectData.admin)
  return _internal_mutable_admin()->Mutable(index);
}
inline void ProjectData::set_admin(int index, const std::string& value) {
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.admin)
}
inline void ProjectData::set_admin(int index, std::string&& value) {
  _internal_mutable_admin()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.admin)
}
inline void ProjectData::set_admin(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.ProjectData.admin)
}
inline void ProjectData::set_admin(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_admin()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.ProjectData.admin)
}
inline void ProjectData::set_admin(int index, absl::string_view value) {
  _internal_mutable_admin()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.ProjectData.admin)
}
inline void ProjectData::add_admin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.ProjectData.admin)
}
inline void ProjectData::add_admin(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.ProjectData.admin)
}
inline void ProjectData::add_admin(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.ProjectData.admin)
}
inline void ProjectData::add_admin(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.ProjectData.admin)
}
inline void ProjectData::add_admin(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.ProjectData.admin)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectData::admin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.ProjectData.admin)
  return _internal_admin();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectData::mutable_admin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.ProjectData.admin)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_admin();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectData::_internal_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectData::_internal_mutable_admin() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.admin_;
}

// repeated string member = 8;
inline int ProjectData::_internal_member_size() const {
  return _internal_member().size();
}
inline int ProjectData::member_size() const {
  return _internal_member_size();
}
inline void ProjectData::clear_member() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.member_.Clear();
}
inline std::string* ProjectData::add_member()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_member()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.ProjectData.member)
  return _s;
}
inline const std::string& ProjectData::member(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.member)
  return _internal_member().Get(index);
}
inline std::string* ProjectData::mutable_member(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.ProjectData.member)
  return _internal_mutable_member()->Mutable(index);
}
inline void ProjectData::set_member(int index, const std::string& value) {
  _internal_mutable_member()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.member)
}
inline void ProjectData::set_member(int index, std::string&& value) {
  _internal_mutable_member()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.ProjectData.member)
}
inline void ProjectData::set_member(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_member()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.ProjectData.member)
}
inline void ProjectData::set_member(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_member()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.ProjectData.member)
}
inline void ProjectData::set_member(int index, absl::string_view value) {
  _internal_mutable_member()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.ProjectData.member)
}
inline void ProjectData::add_member(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.ProjectData.member)
}
inline void ProjectData::add_member(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.ProjectData.member)
}
inline void ProjectData::add_member(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.ProjectData.member)
}
inline void ProjectData::add_member(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.ProjectData.member)
}
inline void ProjectData::add_member(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.ProjectData.member)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectData::member() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.ProjectData.member)
  return _internal_member();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectData::mutable_member() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.ProjectData.member)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_member();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectData::_internal_member() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.member_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectData::_internal_mutable_member() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.member_;
}

// repeated .SDMS.AllocData alloc = 9;
inline int ProjectData::_internal_alloc_size() const {
  return _internal_alloc().size();
}
inline int ProjectData::alloc_size() const {
  return _internal_alloc_size();
}
inline void ProjectData::clear_alloc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alloc_.Clear();
}
inline ::SDMS::AllocData* ProjectData::mutable_alloc(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.ProjectData.alloc)
  return _internal_mutable_alloc()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>* ProjectData::mutable_alloc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.ProjectData.alloc)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alloc();
}
inline const ::SDMS::AllocData& ProjectData::alloc(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ProjectData.alloc)
  return _internal_alloc().Get(index);
}
inline ::SDMS::AllocData* ProjectData::add_alloc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::AllocData* _add = _internal_mutable_alloc()->Add();
  // @@protoc_insertion_point(field_add:SDMS.ProjectData.alloc)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>& ProjectData::alloc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.ProjectData.alloc)
  return _internal_alloc();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>&
ProjectData::_internal_alloc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alloc_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::AllocData>*
ProjectData::_internal_mutable_alloc() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alloc_;
}

// -------------------------------------------------------------------

// ListingData

// required string id = 1;
inline bool ListingData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ListingData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListingData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListingData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ListingData.id)
}
inline std::string* ListingData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.ListingData.id)
  return _s;
}
inline const std::string& ListingData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ListingData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ListingData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ListingData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ListingData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ListingData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ListingData.id)
}

// required string title = 2;
inline bool ListingData::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ListingData::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListingData::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListingData::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ListingData.title)
}
inline std::string* ListingData::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.ListingData.title)
  return _s;
}
inline const std::string& ListingData::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void ListingData::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* ListingData::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* ListingData::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ListingData.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ListingData::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ListingData.title)
}

// optional string alias = 3;
inline bool ListingData::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ListingData::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ListingData::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListingData::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ListingData.alias)
}
inline std::string* ListingData::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:SDMS.ListingData.alias)
  return _s;
}
inline const std::string& ListingData::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void ListingData::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* ListingData::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* ListingData::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ListingData.alias)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.alias_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ListingData::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ListingData.alias)
}

// optional bool locked = 4;
inline bool ListingData::has_locked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ListingData::clear_locked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locked_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool ListingData::locked() const {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.locked)
  return _internal_locked();
}
inline void ListingData::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:SDMS.ListingData.locked)
}
inline bool ListingData::_internal_locked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locked_;
}
inline void ListingData::_internal_set_locked(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.locked_ = value;
}

// optional string owner = 5;
inline bool ListingData::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ListingData::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ListingData::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListingData::set_owner(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ListingData.owner)
}
inline std::string* ListingData::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:SDMS.ListingData.owner)
  return _s;
}
inline const std::string& ListingData::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_.Get();
}
inline void ListingData::_internal_set_owner(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.owner_.Set(value, GetArena());
}
inline std::string* ListingData::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.owner_.Mutable( GetArena());
}
inline std::string* ListingData::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ListingData.owner)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ListingData::set_allocated_owner(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ListingData.owner)
}

// optional string creator = 6;
inline bool ListingData::has_creator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ListingData::clear_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ListingData::creator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListingData::set_creator(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ListingData.creator)
}
inline std::string* ListingData::mutable_creator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:SDMS.ListingData.creator)
  return _s;
}
inline const std::string& ListingData::_internal_creator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.creator_.Get();
}
inline void ListingData::_internal_set_creator(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.creator_.Set(value, GetArena());
}
inline std::string* ListingData::_internal_mutable_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.creator_.Mutable( GetArena());
}
inline std::string* ListingData::release_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ListingData.creator)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.creator_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.creator_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ListingData::set_allocated_creator(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.creator_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ListingData.creator)
}

// optional double size = 7;
inline bool ListingData::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ListingData::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double ListingData::size() const {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.size)
  return _internal_size();
}
inline void ListingData::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SDMS.ListingData.size)
}
inline double ListingData::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void ListingData::_internal_set_size(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.size_ = value;
}

// optional bool external = 8;
inline bool ListingData::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ListingData::clear_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.external_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool ListingData::external() const {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.external)
  return _internal_external();
}
inline void ListingData::set_external(bool value) {
  _internal_set_external(value);
  // @@protoc_insertion_point(field_set:SDMS.ListingData.external)
}
inline bool ListingData::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.external_;
}
inline void ListingData::_internal_set_external(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.external_ = value;
}

// optional uint32 notes = 9;
inline bool ListingData::has_notes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void ListingData::clear_notes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint32_t ListingData::notes() const {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.notes)
  return _internal_notes();
}
inline void ListingData::set_notes(::uint32_t value) {
  _internal_set_notes(value);
  // @@protoc_insertion_point(field_set:SDMS.ListingData.notes)
}
inline ::uint32_t ListingData::_internal_notes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notes_;
}
inline void ListingData::_internal_set_notes(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.notes_ = value;
}

// optional int32 gen = 10;
inline bool ListingData::has_gen() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void ListingData::clear_gen() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gen_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int32_t ListingData::gen() const {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.gen)
  return _internal_gen();
}
inline void ListingData::set_gen(::int32_t value) {
  _internal_set_gen(value);
  // @@protoc_insertion_point(field_set:SDMS.ListingData.gen)
}
inline ::int32_t ListingData::_internal_gen() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gen_;
}
inline void ListingData::_internal_set_gen(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.gen_ = value;
}

// optional bool deps_avail = 11;
inline bool ListingData::has_deps_avail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void ListingData::clear_deps_avail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deps_avail_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool ListingData::deps_avail() const {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.deps_avail)
  return _internal_deps_avail();
}
inline void ListingData::set_deps_avail(bool value) {
  _internal_set_deps_avail(value);
  // @@protoc_insertion_point(field_set:SDMS.ListingData.deps_avail)
}
inline bool ListingData::_internal_deps_avail() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deps_avail_;
}
inline void ListingData::_internal_set_deps_avail(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.deps_avail_ = value;
}

// repeated .SDMS.DependencyData dep = 12;
inline int ListingData::_internal_dep_size() const {
  return _internal_dep().size();
}
inline int ListingData::dep_size() const {
  return _internal_dep_size();
}
inline void ListingData::clear_dep() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dep_.Clear();
}
inline ::SDMS::DependencyData* ListingData::mutable_dep(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.ListingData.dep)
  return _internal_mutable_dep()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>* ListingData::mutable_dep()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.ListingData.dep)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dep();
}
inline const ::SDMS::DependencyData& ListingData::dep(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.dep)
  return _internal_dep().Get(index);
}
inline ::SDMS::DependencyData* ListingData::add_dep() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::DependencyData* _add = _internal_mutable_dep()->Add();
  // @@protoc_insertion_point(field_add:SDMS.ListingData.dep)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>& ListingData::dep() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.ListingData.dep)
  return _internal_dep();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>&
ListingData::_internal_dep() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dep_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>*
ListingData::_internal_mutable_dep() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dep_;
}

// optional string owner_name = 13;
inline bool ListingData::has_owner_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ListingData::clear_owner_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ListingData::owner_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.owner_name)
  return _internal_owner_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListingData::set_owner_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.owner_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ListingData.owner_name)
}
inline std::string* ListingData::mutable_owner_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner_name();
  // @@protoc_insertion_point(field_mutable:SDMS.ListingData.owner_name)
  return _s;
}
inline const std::string& ListingData::_internal_owner_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_name_.Get();
}
inline void ListingData::_internal_set_owner_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.owner_name_.Set(value, GetArena());
}
inline std::string* ListingData::_internal_mutable_owner_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.owner_name_.Mutable( GetArena());
}
inline std::string* ListingData::release_owner_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ListingData.owner_name)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.owner_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ListingData::set_allocated_owner_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.owner_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_name_.IsDefault()) {
          _impl_.owner_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ListingData.owner_name)
}

// optional string desc = 14;
inline bool ListingData::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ListingData::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ListingData::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ListingData.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListingData::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ListingData.desc)
}
inline std::string* ListingData::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.ListingData.desc)
  return _s;
}
inline const std::string& ListingData::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void ListingData::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* ListingData::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* ListingData::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ListingData.desc)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ListingData::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ListingData.desc)
}

// -------------------------------------------------------------------

// TagData

// required string name = 1;
inline bool TagData::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TagData::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TagData::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TagData.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TagData::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TagData.name)
}
inline std::string* TagData::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SDMS.TagData.name)
  return _s;
}
inline const std::string& TagData::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TagData::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TagData::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TagData::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TagData.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TagData::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TagData.name)
}

// required uint64 count = 2;
inline bool TagData::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TagData::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t TagData::count() const {
  // @@protoc_insertion_point(field_get:SDMS.TagData.count)
  return _internal_count();
}
inline void TagData::set_count(::uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SDMS.TagData.count)
}
inline ::uint64_t TagData::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void TagData::_internal_set_count(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// PathData

// repeated .SDMS.ListingData item = 1;
inline int PathData::_internal_item_size() const {
  return _internal_item().size();
}
inline int PathData::item_size() const {
  return _internal_item_size();
}
inline void PathData::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.Clear();
}
inline ::SDMS::ListingData* PathData::mutable_item(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.PathData.item)
  return _internal_mutable_item()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>* PathData::mutable_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.PathData.item)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_item();
}
inline const ::SDMS::ListingData& PathData::item(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.PathData.item)
  return _internal_item().Get(index);
}
inline ::SDMS::ListingData* PathData::add_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::ListingData* _add = _internal_mutable_item()->Add();
  // @@protoc_insertion_point(field_add:SDMS.PathData.item)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>& PathData::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.PathData.item)
  return _internal_item();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>&
PathData::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::ListingData>*
PathData::_internal_mutable_item() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.item_;
}

// -------------------------------------------------------------------

// RecordData

// required string id = 1;
inline bool RecordData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.id)
}
inline std::string* RecordData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.id)
  return _s;
}
inline const std::string& RecordData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RecordData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RecordData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.id)
}

// required string title = 2;
inline bool RecordData::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordData::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecordData::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.title)
}
inline std::string* RecordData::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.title)
  return _s;
}
inline const std::string& RecordData::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void RecordData::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* RecordData::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.title)
}

// optional string alias = 3;
inline bool RecordData::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordData::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RecordData::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.alias)
}
inline std::string* RecordData::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.alias)
  return _s;
}
inline const std::string& RecordData::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void RecordData::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* RecordData::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.alias)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.alias_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.alias)
}

// optional string desc = 4;
inline bool RecordData::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RecordData::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RecordData::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.desc)
}
inline std::string* RecordData::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.desc)
  return _s;
}
inline const std::string& RecordData::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void RecordData::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* RecordData::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.desc)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.desc)
}

// repeated string tags = 5;
inline int RecordData::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int RecordData::tags_size() const {
  return _internal_tags_size();
}
inline void RecordData::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* RecordData::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.RecordData.tags)
  return _s;
}
inline const std::string& RecordData::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.tags)
  return _internal_tags().Get(index);
}
inline std::string* RecordData::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void RecordData::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.tags)
}
inline void RecordData::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.RecordData.tags)
}
inline void RecordData::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.RecordData.tags)
}
inline void RecordData::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.RecordData.tags)
}
inline void RecordData::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.RecordData.tags)
}
inline void RecordData::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.RecordData.tags)
}
inline void RecordData::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.RecordData.tags)
}
inline void RecordData::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.RecordData.tags)
}
inline void RecordData::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.RecordData.tags)
}
inline void RecordData::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.RecordData.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordData::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.RecordData.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordData::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.RecordData.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RecordData::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RecordData::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// optional string metadata = 6;
inline bool RecordData::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RecordData::clear_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RecordData::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_metadata(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.metadata)
}
inline std::string* RecordData::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.metadata)
  return _s;
}
inline const std::string& RecordData::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_.Get();
}
inline void RecordData::_internal_set_metadata(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.metadata_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.metadata_.Mutable( GetArena());
}
inline std::string* RecordData::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.metadata)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.metadata_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.metadata_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_metadata(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.metadata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_.IsDefault()) {
          _impl_.metadata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.metadata)
}

// optional bool external = 7;
inline bool RecordData::has_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void RecordData::clear_external() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.external_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool RecordData::external() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.external)
  return _internal_external();
}
inline void RecordData::set_external(bool value) {
  _internal_set_external(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.external)
}
inline bool RecordData::_internal_external() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.external_;
}
inline void RecordData::_internal_set_external(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.external_ = value;
}

// optional string source = 8;
inline bool RecordData::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RecordData::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& RecordData::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.source)
}
inline std::string* RecordData::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.source)
  return _s;
}
inline const std::string& RecordData::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void RecordData::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.source_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.source_.Mutable( GetArena());
}
inline std::string* RecordData::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.source)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.source_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.source)
}

// optional string repo_id = 9;
inline bool RecordData::has_repo_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RecordData::clear_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& RecordData::repo_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.repo_id)
  return _internal_repo_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_repo_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.repo_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.repo_id)
}
inline std::string* RecordData::mutable_repo_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo_id();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.repo_id)
  return _s;
}
inline const std::string& RecordData::_internal_repo_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_id_.Get();
}
inline void RecordData::_internal_set_repo_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.repo_id_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.repo_id_.Mutable( GetArena());
}
inline std::string* RecordData::release_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.repo_id)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.repo_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_repo_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.repo_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_id_.IsDefault()) {
          _impl_.repo_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.repo_id)
}

// optional double size = 10;
inline bool RecordData::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void RecordData::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline double RecordData::size() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.size)
  return _internal_size();
}
inline void RecordData::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.size)
}
inline double RecordData::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void RecordData::_internal_set_size(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.size_ = value;
}

// optional string ext = 11;
inline bool RecordData::has_ext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RecordData::clear_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& RecordData::ext() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.ext)
  return _internal_ext();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_ext(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ext_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.ext)
}
inline std::string* RecordData::mutable_ext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ext();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.ext)
  return _s;
}
inline const std::string& RecordData::_internal_ext() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ext_.Get();
}
inline void RecordData::_internal_set_ext(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ext_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.ext_.Mutable( GetArena());
}
inline std::string* RecordData::release_ext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.ext)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.ext_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ext_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_ext(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.ext_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ext_.IsDefault()) {
          _impl_.ext_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.ext)
}

// optional bool ext_auto = 12;
inline bool RecordData::has_ext_auto() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void RecordData::clear_ext_auto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ext_auto_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool RecordData::ext_auto() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.ext_auto)
  return _internal_ext_auto();
}
inline void RecordData::set_ext_auto(bool value) {
  _internal_set_ext_auto(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.ext_auto)
}
inline bool RecordData::_internal_ext_auto() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ext_auto_;
}
inline void RecordData::_internal_set_ext_auto(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.ext_auto_ = value;
}

// optional uint32 ct = 13;
inline bool RecordData::has_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void RecordData::clear_ct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ct_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::uint32_t RecordData::ct() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.ct)
  return _internal_ct();
}
inline void RecordData::set_ct(::uint32_t value) {
  _internal_set_ct(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.ct)
}
inline ::uint32_t RecordData::_internal_ct() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ct_;
}
inline void RecordData::_internal_set_ct(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.ct_ = value;
}

// optional uint32 ut = 14;
inline bool RecordData::has_ut() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void RecordData::clear_ut() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ut_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::uint32_t RecordData::ut() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.ut)
  return _internal_ut();
}
inline void RecordData::set_ut(::uint32_t value) {
  _internal_set_ut(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.ut)
}
inline ::uint32_t RecordData::_internal_ut() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ut_;
}
inline void RecordData::_internal_set_ut(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.ut_ = value;
}

// optional uint32 dt = 15;
inline bool RecordData::has_dt() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void RecordData::clear_dt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::uint32_t RecordData::dt() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.dt)
  return _internal_dt();
}
inline void RecordData::set_dt(::uint32_t value) {
  _internal_set_dt(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.dt)
}
inline ::uint32_t RecordData::_internal_dt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dt_;
}
inline void RecordData::_internal_set_dt(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.dt_ = value;
}

// optional string owner = 16;
inline bool RecordData::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RecordData::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& RecordData::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_owner(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.owner)
}
inline std::string* RecordData::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.owner)
  return _s;
}
inline const std::string& RecordData::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_.Get();
}
inline void RecordData::_internal_set_owner(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.owner_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.owner_.Mutable( GetArena());
}
inline std::string* RecordData::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.owner)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_owner(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.owner)
}

// optional string creator = 17;
inline bool RecordData::has_creator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RecordData::clear_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& RecordData::creator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_creator(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.creator)
}
inline std::string* RecordData::mutable_creator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.creator)
  return _s;
}
inline const std::string& RecordData::_internal_creator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.creator_.Get();
}
inline void RecordData::_internal_set_creator(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.creator_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.creator_.Mutable( GetArena());
}
inline std::string* RecordData::release_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.creator)
  if ((_impl_._has_bits_[0] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* released = _impl_.creator_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.creator_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_creator(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.creator_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.creator)
}

// optional bool locked = 18;
inline bool RecordData::has_locked() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void RecordData::clear_locked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locked_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool RecordData::locked() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.locked)
  return _internal_locked();
}
inline void RecordData::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.locked)
}
inline bool RecordData::_internal_locked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locked_;
}
inline void RecordData::_internal_set_locked(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.locked_ = value;
}

// optional string parent_id = 19;
inline bool RecordData::has_parent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void RecordData::clear_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& RecordData::parent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.parent_id)
  return _internal_parent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_parent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.parent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.parent_id)
}
inline std::string* RecordData::mutable_parent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.parent_id)
  return _s;
}
inline const std::string& RecordData::_internal_parent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_id_.Get();
}
inline void RecordData::_internal_set_parent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.parent_id_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.parent_id_.Mutable( GetArena());
}
inline std::string* RecordData::release_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.parent_id)
  if ((_impl_._has_bits_[0] & 0x00000400u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* released = _impl_.parent_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_parent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.parent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_id_.IsDefault()) {
          _impl_.parent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.parent_id)
}

// repeated .SDMS.DependencyData deps = 20;
inline int RecordData::_internal_deps_size() const {
  return _internal_deps().size();
}
inline int RecordData::deps_size() const {
  return _internal_deps_size();
}
inline void RecordData::clear_deps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deps_.Clear();
}
inline ::SDMS::DependencyData* RecordData::mutable_deps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.deps)
  return _internal_mutable_deps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>* RecordData::mutable_deps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.RecordData.deps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_deps();
}
inline const ::SDMS::DependencyData& RecordData::deps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.deps)
  return _internal_deps().Get(index);
}
inline ::SDMS::DependencyData* RecordData::add_deps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::DependencyData* _add = _internal_mutable_deps()->Add();
  // @@protoc_insertion_point(field_add:SDMS.RecordData.deps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>& RecordData::deps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.RecordData.deps)
  return _internal_deps();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>&
RecordData::_internal_deps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deps_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::DependencyData>*
RecordData::_internal_mutable_deps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.deps_;
}

// optional uint32 notes = 21;
inline bool RecordData::has_notes() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void RecordData::clear_notes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::uint32_t RecordData::notes() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.notes)
  return _internal_notes();
}
inline void RecordData::set_notes(::uint32_t value) {
  _internal_set_notes(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.notes)
}
inline ::uint32_t RecordData::_internal_notes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notes_;
}
inline void RecordData::_internal_set_notes(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.notes_ = value;
}

// optional string md_err_msg = 22;
inline bool RecordData::has_md_err_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void RecordData::clear_md_err_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md_err_msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& RecordData::md_err_msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.md_err_msg)
  return _internal_md_err_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_md_err_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.md_err_msg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.md_err_msg)
}
inline std::string* RecordData::mutable_md_err_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_md_err_msg();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.md_err_msg)
  return _s;
}
inline const std::string& RecordData::_internal_md_err_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.md_err_msg_.Get();
}
inline void RecordData::_internal_set_md_err_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.md_err_msg_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_md_err_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.md_err_msg_.Mutable( GetArena());
}
inline std::string* RecordData::release_md_err_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.md_err_msg)
  if ((_impl_._has_bits_[0] & 0x00000800u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* released = _impl_.md_err_msg_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.md_err_msg_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_md_err_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.md_err_msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.md_err_msg_.IsDefault()) {
          _impl_.md_err_msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.md_err_msg)
}

// optional string sch_id = 23;
inline bool RecordData::has_sch_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void RecordData::clear_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sch_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& RecordData::sch_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.sch_id)
  return _internal_sch_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordData::set_sch_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.sch_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordData.sch_id)
}
inline std::string* RecordData::mutable_sch_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sch_id();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordData.sch_id)
  return _s;
}
inline const std::string& RecordData::_internal_sch_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sch_id_.Get();
}
inline void RecordData::_internal_set_sch_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.sch_id_.Set(value, GetArena());
}
inline std::string* RecordData::_internal_mutable_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.sch_id_.Mutable( GetArena());
}
inline std::string* RecordData::release_sch_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordData.sch_id)
  if ((_impl_._has_bits_[0] & 0x00001000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* released = _impl_.sch_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sch_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordData::set_allocated_sch_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.sch_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sch_id_.IsDefault()) {
          _impl_.sch_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordData.sch_id)
}

// optional uint32 sch_ver = 24;
inline bool RecordData::has_sch_ver() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void RecordData::clear_sch_ver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sch_ver_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::uint32_t RecordData::sch_ver() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordData.sch_ver)
  return _internal_sch_ver();
}
inline void RecordData::set_sch_ver(::uint32_t value) {
  _internal_set_sch_ver(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordData.sch_ver)
}
inline ::uint32_t RecordData::_internal_sch_ver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sch_ver_;
}
inline void RecordData::_internal_set_sch_ver(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.sch_ver_ = value;
}

// -------------------------------------------------------------------

// RecordDataLocation

// required string id = 1;
inline bool RecordDataLocation::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordDataLocation::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordDataLocation::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordDataLocation.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordDataLocation::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordDataLocation.id)
}
inline std::string* RecordDataLocation::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordDataLocation.id)
  return _s;
}
inline const std::string& RecordDataLocation::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RecordDataLocation::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RecordDataLocation::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RecordDataLocation::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordDataLocation.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordDataLocation::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordDataLocation.id)
}

// required string path = 2;
inline bool RecordDataLocation::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordDataLocation::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecordDataLocation::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordDataLocation.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordDataLocation::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordDataLocation.path)
}
inline std::string* RecordDataLocation::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordDataLocation.path)
  return _s;
}
inline const std::string& RecordDataLocation::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void RecordDataLocation::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* RecordDataLocation::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* RecordDataLocation::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordDataLocation.path)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordDataLocation::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordDataLocation.path)
}

// -------------------------------------------------------------------

// RepoRecordDataLocations

// required string repo_id = 1;
inline bool RepoRecordDataLocations::has_repo_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoRecordDataLocations::clear_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoRecordDataLocations::repo_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoRecordDataLocations.repo_id)
  return _internal_repo_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoRecordDataLocations::set_repo_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoRecordDataLocations.repo_id)
}
inline std::string* RepoRecordDataLocations::mutable_repo_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo_id();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoRecordDataLocations.repo_id)
  return _s;
}
inline const std::string& RepoRecordDataLocations::_internal_repo_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_id_.Get();
}
inline void RepoRecordDataLocations::_internal_set_repo_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repo_id_.Set(value, GetArena());
}
inline std::string* RepoRecordDataLocations::_internal_mutable_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.repo_id_.Mutable( GetArena());
}
inline std::string* RepoRecordDataLocations::release_repo_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoRecordDataLocations.repo_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.repo_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.repo_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoRecordDataLocations::set_allocated_repo_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.repo_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_id_.IsDefault()) {
          _impl_.repo_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoRecordDataLocations.repo_id)
}

// repeated .SDMS.RecordDataLocation loc = 2;
inline int RepoRecordDataLocations::_internal_loc_size() const {
  return _internal_loc().size();
}
inline int RepoRecordDataLocations::loc_size() const {
  return _internal_loc_size();
}
inline void RepoRecordDataLocations::clear_loc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loc_.Clear();
}
inline ::SDMS::RecordDataLocation* RepoRecordDataLocations::mutable_loc(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.RepoRecordDataLocations.loc)
  return _internal_mutable_loc()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>* RepoRecordDataLocations::mutable_loc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.RepoRecordDataLocations.loc)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_loc();
}
inline const ::SDMS::RecordDataLocation& RepoRecordDataLocations::loc(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoRecordDataLocations.loc)
  return _internal_loc().Get(index);
}
inline ::SDMS::RecordDataLocation* RepoRecordDataLocations::add_loc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::RecordDataLocation* _add = _internal_mutable_loc()->Add();
  // @@protoc_insertion_point(field_add:SDMS.RepoRecordDataLocations.loc)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>& RepoRecordDataLocations::loc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.RepoRecordDataLocations.loc)
  return _internal_loc();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>&
RepoRecordDataLocations::_internal_loc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loc_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::RecordDataLocation>*
RepoRecordDataLocations::_internal_mutable_loc() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.loc_;
}

// -------------------------------------------------------------------

// RecordDataSize

// required string id = 1;
inline bool RecordDataSize::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordDataSize::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordDataSize::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RecordDataSize.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordDataSize::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RecordDataSize.id)
}
inline std::string* RecordDataSize::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.RecordDataSize.id)
  return _s;
}
inline const std::string& RecordDataSize::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RecordDataSize::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RecordDataSize::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RecordDataSize::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RecordDataSize.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RecordDataSize::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RecordDataSize.id)
}

// required double size = 2;
inline bool RecordDataSize::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordDataSize::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double RecordDataSize::size() const {
  // @@protoc_insertion_point(field_get:SDMS.RecordDataSize.size)
  return _internal_size();
}
inline void RecordDataSize::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SDMS.RecordDataSize.size)
}
inline double RecordDataSize::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void RecordDataSize::_internal_set_size(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// CollData

// required string id = 1;
inline bool CollData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CollData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.CollData.id)
}
inline std::string* CollData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.id)
  return _s;
}
inline const std::string& CollData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CollData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CollData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CollData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.CollData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.CollData.id)
}

// required string title = 2;
inline bool CollData::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CollData::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CollData::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollData::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.CollData.title)
}
inline std::string* CollData::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.title)
  return _s;
}
inline const std::string& CollData::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void CollData::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* CollData::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* CollData::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.CollData.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollData::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.CollData.title)
}

// optional string alias = 3;
inline bool CollData::has_alias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CollData::clear_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alias_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CollData::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollData::set_alias(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.CollData.alias)
}
inline std::string* CollData::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.alias)
  return _s;
}
inline const std::string& CollData::_internal_alias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alias_.Get();
}
inline void CollData::_internal_set_alias(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* CollData::_internal_mutable_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* CollData::release_alias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.CollData.alias)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.alias_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollData::set_allocated_alias(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.CollData.alias)
}

// optional string desc = 4;
inline bool CollData::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CollData::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CollData::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollData::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.CollData.desc)
}
inline std::string* CollData::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.desc)
  return _s;
}
inline const std::string& CollData::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void CollData::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* CollData::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* CollData::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.CollData.desc)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollData::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.CollData.desc)
}

// repeated string tags = 5;
inline int CollData::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int CollData::tags_size() const {
  return _internal_tags_size();
}
inline void CollData::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* CollData::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.CollData.tags)
  return _s;
}
inline const std::string& CollData::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.tags)
  return _internal_tags().Get(index);
}
inline std::string* CollData::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void CollData::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.CollData.tags)
}
inline void CollData::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.CollData.tags)
}
inline void CollData::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.CollData.tags)
}
inline void CollData::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.CollData.tags)
}
inline void CollData::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.CollData.tags)
}
inline void CollData::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.CollData.tags)
}
inline void CollData::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.CollData.tags)
}
inline void CollData::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.CollData.tags)
}
inline void CollData::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.CollData.tags)
}
inline void CollData::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.CollData.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollData::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.CollData.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollData::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.CollData.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollData::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollData::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// optional string topic = 6;
inline bool CollData::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CollData::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CollData::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollData::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.CollData.topic)
}
inline std::string* CollData::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.topic)
  return _s;
}
inline const std::string& CollData::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CollData::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CollData::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CollData::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.CollData.topic)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollData::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.CollData.topic)
}

// optional string owner = 7;
inline bool CollData::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CollData::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CollData::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollData::set_owner(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.CollData.owner)
}
inline std::string* CollData::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.owner)
  return _s;
}
inline const std::string& CollData::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_.Get();
}
inline void CollData::_internal_set_owner(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.owner_.Set(value, GetArena());
}
inline std::string* CollData::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.owner_.Mutable( GetArena());
}
inline std::string* CollData::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.CollData.owner)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollData::set_allocated_owner(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.CollData.owner)
}

// optional string creator = 8;
inline bool CollData::has_creator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CollData::clear_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CollData::creator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollData::set_creator(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.CollData.creator)
}
inline std::string* CollData::mutable_creator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.creator)
  return _s;
}
inline const std::string& CollData::_internal_creator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.creator_.Get();
}
inline void CollData::_internal_set_creator(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.creator_.Set(value, GetArena());
}
inline std::string* CollData::_internal_mutable_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.creator_.Mutable( GetArena());
}
inline std::string* CollData::release_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.CollData.creator)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.creator_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.creator_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollData::set_allocated_creator(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.creator_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.CollData.creator)
}

// optional uint32 ct = 9;
inline bool CollData::has_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CollData::clear_ct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ct_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t CollData::ct() const {
  // @@protoc_insertion_point(field_get:SDMS.CollData.ct)
  return _internal_ct();
}
inline void CollData::set_ct(::uint32_t value) {
  _internal_set_ct(value);
  // @@protoc_insertion_point(field_set:SDMS.CollData.ct)
}
inline ::uint32_t CollData::_internal_ct() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ct_;
}
inline void CollData::_internal_set_ct(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.ct_ = value;
}

// optional uint32 ut = 10;
inline bool CollData::has_ut() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void CollData::clear_ut() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ut_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t CollData::ut() const {
  // @@protoc_insertion_point(field_get:SDMS.CollData.ut)
  return _internal_ut();
}
inline void CollData::set_ut(::uint32_t value) {
  _internal_set_ut(value);
  // @@protoc_insertion_point(field_set:SDMS.CollData.ut)
}
inline ::uint32_t CollData::_internal_ut() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ut_;
}
inline void CollData::_internal_set_ut(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.ut_ = value;
}

// optional string parent_id = 11;
inline bool CollData::has_parent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CollData::clear_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CollData::parent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.CollData.parent_id)
  return _internal_parent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollData::set_parent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.parent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.CollData.parent_id)
}
inline std::string* CollData::mutable_parent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:SDMS.CollData.parent_id)
  return _s;
}
inline const std::string& CollData::_internal_parent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_id_.Get();
}
inline void CollData::_internal_set_parent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.parent_id_.Set(value, GetArena());
}
inline std::string* CollData::_internal_mutable_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.parent_id_.Mutable( GetArena());
}
inline std::string* CollData::release_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.CollData.parent_id)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.parent_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CollData::set_allocated_parent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.parent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_id_.IsDefault()) {
          _impl_.parent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.CollData.parent_id)
}

// optional uint32 notes = 12;
inline bool CollData::has_notes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void CollData::clear_notes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t CollData::notes() const {
  // @@protoc_insertion_point(field_get:SDMS.CollData.notes)
  return _internal_notes();
}
inline void CollData::set_notes(::uint32_t value) {
  _internal_set_notes(value);
  // @@protoc_insertion_point(field_set:SDMS.CollData.notes)
}
inline ::uint32_t CollData::_internal_notes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notes_;
}
inline void CollData::_internal_set_notes(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.notes_ = value;
}

// -------------------------------------------------------------------

// GroupData

// required string uid = 1;
inline bool GroupData::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GroupData::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupData::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.GroupData.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupData::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.GroupData.uid)
}
inline std::string* GroupData::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:SDMS.GroupData.uid)
  return _s;
}
inline const std::string& GroupData::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void GroupData::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* GroupData::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* GroupData::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.GroupData.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupData::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.GroupData.uid)
}

// required string gid = 2;
inline bool GroupData::has_gid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GroupData::clear_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupData::gid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.GroupData.gid)
  return _internal_gid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupData::set_gid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.GroupData.gid)
}
inline std::string* GroupData::mutable_gid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gid();
  // @@protoc_insertion_point(field_mutable:SDMS.GroupData.gid)
  return _s;
}
inline const std::string& GroupData::_internal_gid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gid_.Get();
}
inline void GroupData::_internal_set_gid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gid_.Set(value, GetArena());
}
inline std::string* GroupData::_internal_mutable_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.gid_.Mutable( GetArena());
}
inline std::string* GroupData::release_gid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.GroupData.gid)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.gid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupData::set_allocated_gid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.gid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gid_.IsDefault()) {
          _impl_.gid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.GroupData.gid)
}

// optional string title = 3;
inline bool GroupData::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GroupData::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GroupData::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.GroupData.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupData::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.GroupData.title)
}
inline std::string* GroupData::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.GroupData.title)
  return _s;
}
inline const std::string& GroupData::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void GroupData::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* GroupData::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* GroupData::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.GroupData.title)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupData::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.GroupData.title)
}

// optional string desc = 4;
inline bool GroupData::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GroupData::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GroupData::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.GroupData.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupData::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.GroupData.desc)
}
inline std::string* GroupData::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.GroupData.desc)
  return _s;
}
inline const std::string& GroupData::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void GroupData::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* GroupData::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* GroupData::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.GroupData.desc)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GroupData::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.GroupData.desc)
}

// repeated string member = 5;
inline int GroupData::_internal_member_size() const {
  return _internal_member().size();
}
inline int GroupData::member_size() const {
  return _internal_member_size();
}
inline void GroupData::clear_member() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.member_.Clear();
}
inline std::string* GroupData::add_member()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_member()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.GroupData.member)
  return _s;
}
inline const std::string& GroupData::member(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.GroupData.member)
  return _internal_member().Get(index);
}
inline std::string* GroupData::mutable_member(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.GroupData.member)
  return _internal_mutable_member()->Mutable(index);
}
inline void GroupData::set_member(int index, const std::string& value) {
  _internal_mutable_member()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.GroupData.member)
}
inline void GroupData::set_member(int index, std::string&& value) {
  _internal_mutable_member()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.GroupData.member)
}
inline void GroupData::set_member(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_member()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.GroupData.member)
}
inline void GroupData::set_member(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_member()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.GroupData.member)
}
inline void GroupData::set_member(int index, absl::string_view value) {
  _internal_mutable_member()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.GroupData.member)
}
inline void GroupData::add_member(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.GroupData.member)
}
inline void GroupData::add_member(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.GroupData.member)
}
inline void GroupData::add_member(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.GroupData.member)
}
inline void GroupData::add_member(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.GroupData.member)
}
inline void GroupData::add_member(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_member()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.GroupData.member)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GroupData::member() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.GroupData.member)
  return _internal_member();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GroupData::mutable_member() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.GroupData.member)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_member();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GroupData::_internal_member() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.member_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GroupData::_internal_mutable_member() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.member_;
}

// -------------------------------------------------------------------

// ACLRule

// required string id = 1;
inline bool ACLRule::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ACLRule::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ACLRule::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.ACLRule.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ACLRule::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.ACLRule.id)
}
inline std::string* ACLRule::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.ACLRule.id)
  return _s;
}
inline const std::string& ACLRule::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ACLRule::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ACLRule::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ACLRule::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.ACLRule.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ACLRule::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.ACLRule.id)
}

// optional uint32 grant = 2;
inline bool ACLRule::has_grant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ACLRule::clear_grant() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.grant_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ACLRule::grant() const {
  // @@protoc_insertion_point(field_get:SDMS.ACLRule.grant)
  return _internal_grant();
}
inline void ACLRule::set_grant(::uint32_t value) {
  _internal_set_grant(value);
  // @@protoc_insertion_point(field_set:SDMS.ACLRule.grant)
}
inline ::uint32_t ACLRule::_internal_grant() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.grant_;
}
inline void ACLRule::_internal_set_grant(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.grant_ = value;
}

// optional uint32 inhgrant = 3;
inline bool ACLRule::has_inhgrant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ACLRule::clear_inhgrant() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inhgrant_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ACLRule::inhgrant() const {
  // @@protoc_insertion_point(field_get:SDMS.ACLRule.inhgrant)
  return _internal_inhgrant();
}
inline void ACLRule::set_inhgrant(::uint32_t value) {
  _internal_set_inhgrant(value);
  // @@protoc_insertion_point(field_set:SDMS.ACLRule.inhgrant)
}
inline ::uint32_t ACLRule::_internal_inhgrant() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inhgrant_;
}
inline void ACLRule::_internal_set_inhgrant(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.inhgrant_ = value;
}

// -------------------------------------------------------------------

// TopicData

// required string id = 1;
inline bool TopicData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TopicData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TopicData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TopicData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TopicData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TopicData.id)
}
inline std::string* TopicData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.TopicData.id)
  return _s;
}
inline const std::string& TopicData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void TopicData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* TopicData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* TopicData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TopicData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TopicData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TopicData.id)
}

// required string title = 2;
inline bool TopicData::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TopicData::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TopicData::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TopicData.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TopicData::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TopicData.title)
}
inline std::string* TopicData::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.TopicData.title)
  return _s;
}
inline const std::string& TopicData::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void TopicData::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* TopicData::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* TopicData::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TopicData.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TopicData::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TopicData.title)
}

// repeated .SDMS.TopicData path = 3;
inline int TopicData::_internal_path_size() const {
  return _internal_path().size();
}
inline int TopicData::path_size() const {
  return _internal_path_size();
}
inline void TopicData::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.Clear();
}
inline ::SDMS::TopicData* TopicData::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.TopicData.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>* TopicData::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.TopicData.path)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_path();
}
inline const ::SDMS::TopicData& TopicData::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TopicData.path)
  return _internal_path().Get(index);
}
inline ::SDMS::TopicData* TopicData::add_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::TopicData* _add = _internal_mutable_path()->Add();
  // @@protoc_insertion_point(field_add:SDMS.TopicData.path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>& TopicData::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.TopicData.path)
  return _internal_path();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>&
TopicData::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::TopicData>*
TopicData::_internal_mutable_path() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.path_;
}

// optional string desc = 4;
inline bool TopicData::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TopicData::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TopicData::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TopicData.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TopicData::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TopicData.desc)
}
inline std::string* TopicData::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.TopicData.desc)
  return _s;
}
inline const std::string& TopicData::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void TopicData::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* TopicData::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* TopicData::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TopicData.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TopicData::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TopicData.desc)
}

// optional string creator = 5;
inline bool TopicData::has_creator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TopicData::clear_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TopicData::creator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TopicData.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TopicData::set_creator(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TopicData.creator)
}
inline std::string* TopicData::mutable_creator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:SDMS.TopicData.creator)
  return _s;
}
inline const std::string& TopicData::_internal_creator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.creator_.Get();
}
inline void TopicData::_internal_set_creator(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.creator_.Set(value, GetArena());
}
inline std::string* TopicData::_internal_mutable_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.creator_.Mutable( GetArena());
}
inline std::string* TopicData::release_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TopicData.creator)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.creator_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.creator_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TopicData::set_allocated_creator(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.creator_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TopicData.creator)
}

// optional bool admin = 6;
inline bool TopicData::has_admin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TopicData::clear_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool TopicData::admin() const {
  // @@protoc_insertion_point(field_get:SDMS.TopicData.admin)
  return _internal_admin();
}
inline void TopicData::set_admin(bool value) {
  _internal_set_admin(value);
  // @@protoc_insertion_point(field_set:SDMS.TopicData.admin)
}
inline bool TopicData::_internal_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_;
}
inline void TopicData::_internal_set_admin(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.admin_ = value;
}

// required uint32 coll_cnt = 7;
inline bool TopicData::has_coll_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TopicData::clear_coll_cnt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coll_cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t TopicData::coll_cnt() const {
  // @@protoc_insertion_point(field_get:SDMS.TopicData.coll_cnt)
  return _internal_coll_cnt();
}
inline void TopicData::set_coll_cnt(::uint32_t value) {
  _internal_set_coll_cnt(value);
  // @@protoc_insertion_point(field_set:SDMS.TopicData.coll_cnt)
}
inline ::uint32_t TopicData::_internal_coll_cnt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coll_cnt_;
}
inline void TopicData::_internal_set_coll_cnt(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.coll_cnt_ = value;
}

// -------------------------------------------------------------------

// RepoData

// required string id = 1;
inline bool RepoData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RepoData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RepoData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.id)
}
inline std::string* RepoData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.id)
  return _s;
}
inline const std::string& RepoData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RepoData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RepoData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.id)
}

// optional string title = 2;
inline bool RepoData::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepoData::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RepoData::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.title)
}
inline std::string* RepoData::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.title)
  return _s;
}
inline const std::string& RepoData::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void RepoData::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* RepoData::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.title)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.title)
}

// optional string desc = 3;
inline bool RepoData::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepoData::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RepoData::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.desc)
}
inline std::string* RepoData::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.desc)
  return _s;
}
inline const std::string& RepoData::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void RepoData::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* RepoData::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.desc)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.desc)
}

// optional uint64 capacity = 4;
inline bool RepoData::has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RepoData::clear_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t RepoData::capacity() const {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.capacity)
  return _internal_capacity();
}
inline void RepoData::set_capacity(::uint64_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:SDMS.RepoData.capacity)
}
inline ::uint64_t RepoData::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_;
}
inline void RepoData::_internal_set_capacity(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.capacity_ = value;
}

// optional string pub_key = 5;
inline bool RepoData::has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepoData::clear_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pub_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RepoData::pub_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.pub_key)
  return _internal_pub_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_pub_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pub_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.pub_key)
}
inline std::string* RepoData::mutable_pub_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.pub_key)
  return _s;
}
inline const std::string& RepoData::_internal_pub_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pub_key_.Get();
}
inline void RepoData::_internal_set_pub_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pub_key_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.pub_key_.Mutable( GetArena());
}
inline std::string* RepoData::release_pub_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.pub_key)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.pub_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pub_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_pub_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.pub_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pub_key_.IsDefault()) {
          _impl_.pub_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.pub_key)
}

// optional string address = 6;
inline bool RepoData::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RepoData::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RepoData::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.address)
}
inline std::string* RepoData::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.address)
  return _s;
}
inline const std::string& RepoData::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void RepoData::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* RepoData::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.address)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.address)
}

// optional string endpoint = 7;
inline bool RepoData::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RepoData::clear_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.endpoint_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& RepoData::endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.endpoint)
  return _internal_endpoint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_endpoint(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.endpoint)
}
inline std::string* RepoData::mutable_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.endpoint)
  return _s;
}
inline const std::string& RepoData::_internal_endpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endpoint_.Get();
}
inline void RepoData::_internal_set_endpoint(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.endpoint_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.endpoint_.Mutable( GetArena());
}
inline std::string* RepoData::release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.endpoint)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.endpoint_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_endpoint(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.endpoint_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_.IsDefault()) {
          _impl_.endpoint_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.endpoint)
}

// optional string path = 8;
inline bool RepoData::has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RepoData::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& RepoData::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.path)
}
inline std::string* RepoData::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.path)
  return _s;
}
inline const std::string& RepoData::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void RepoData::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* RepoData::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.path)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.path)
}

// optional string domain = 9;
inline bool RepoData::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RepoData::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& RepoData::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.domain)
}
inline std::string* RepoData::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.domain)
  return _s;
}
inline const std::string& RepoData::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void RepoData::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* RepoData::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.domain)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.domain_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.domain)
}

// optional string exp_path = 10;
inline bool RepoData::has_exp_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RepoData::clear_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& RepoData::exp_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.exp_path)
  return _internal_exp_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RepoData::set_exp_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.exp_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.RepoData.exp_path)
}
inline std::string* RepoData::mutable_exp_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_exp_path();
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.exp_path)
  return _s;
}
inline const std::string& RepoData::_internal_exp_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exp_path_.Get();
}
inline void RepoData::_internal_set_exp_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.exp_path_.Set(value, GetArena());
}
inline std::string* RepoData::_internal_mutable_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.exp_path_.Mutable( GetArena());
}
inline std::string* RepoData::release_exp_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.RepoData.exp_path)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.exp_path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.exp_path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RepoData::set_allocated_exp_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.exp_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.exp_path_.IsDefault()) {
          _impl_.exp_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.RepoData.exp_path)
}

// repeated string admin = 11;
inline int RepoData::_internal_admin_size() const {
  return _internal_admin().size();
}
inline int RepoData::admin_size() const {
  return _internal_admin_size();
}
inline void RepoData::clear_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_.Clear();
}
inline std::string* RepoData::add_admin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_admin()->Add();
  // @@protoc_insertion_point(field_add_mutable:SDMS.RepoData.admin)
  return _s;
}
inline const std::string& RepoData::admin(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.RepoData.admin)
  return _internal_admin().Get(index);
}
inline std::string* RepoData::mutable_admin(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.RepoData.admin)
  return _internal_mutable_admin()->Mutable(index);
}
inline void RepoData::set_admin(int index, const std::string& value) {
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SDMS.RepoData.admin)
}
inline void RepoData::set_admin(int index, std::string&& value) {
  _internal_mutable_admin()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SDMS.RepoData.admin)
}
inline void RepoData::set_admin(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_admin()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SDMS.RepoData.admin)
}
inline void RepoData::set_admin(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_admin()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SDMS.RepoData.admin)
}
inline void RepoData::set_admin(int index, absl::string_view value) {
  _internal_mutable_admin()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SDMS.RepoData.admin)
}
inline void RepoData::add_admin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SDMS.RepoData.admin)
}
inline void RepoData::add_admin(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SDMS.RepoData.admin)
}
inline void RepoData::add_admin(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SDMS.RepoData.admin)
}
inline void RepoData::add_admin(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SDMS.RepoData.admin)
}
inline void RepoData::add_admin(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_admin()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SDMS.RepoData.admin)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RepoData::admin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.RepoData.admin)
  return _internal_admin();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RepoData::mutable_admin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.RepoData.admin)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_admin();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RepoData::_internal_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RepoData::_internal_mutable_admin() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.admin_;
}

// -------------------------------------------------------------------

// NoteComment

// required string user = 1;
inline bool NoteComment::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NoteComment::clear_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NoteComment::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.NoteComment.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteComment::set_user(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.NoteComment.user)
}
inline std::string* NoteComment::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:SDMS.NoteComment.user)
  return _s;
}
inline const std::string& NoteComment::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_.Get();
}
inline void NoteComment::_internal_set_user(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_.Set(value, GetArena());
}
inline std::string* NoteComment::_internal_mutable_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* NoteComment::release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.NoteComment.user)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.user_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteComment::set_allocated_user(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.NoteComment.user)
}

// required uint32 time = 2;
inline bool NoteComment::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NoteComment::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t NoteComment::time() const {
  // @@protoc_insertion_point(field_get:SDMS.NoteComment.time)
  return _internal_time();
}
inline void NoteComment::set_time(::uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:SDMS.NoteComment.time)
}
inline ::uint32_t NoteComment::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void NoteComment::_internal_set_time(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.time_ = value;
}

// required string comment = 3;
inline bool NoteComment::has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NoteComment::clear_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NoteComment::comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.NoteComment.comment)
  return _internal_comment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteComment::set_comment(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.NoteComment.comment)
}
inline std::string* NoteComment::mutable_comment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:SDMS.NoteComment.comment)
  return _s;
}
inline const std::string& NoteComment::_internal_comment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comment_.Get();
}
inline void NoteComment::_internal_set_comment(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(value, GetArena());
}
inline std::string* NoteComment::_internal_mutable_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comment_.Mutable( GetArena());
}
inline std::string* NoteComment::release_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.NoteComment.comment)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comment_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteComment::set_allocated_comment(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comment_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comment_.IsDefault()) {
          _impl_.comment_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.NoteComment.comment)
}

// optional .SDMS.NoteType type = 4;
inline bool NoteComment::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NoteComment::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SDMS::NoteType NoteComment::type() const {
  // @@protoc_insertion_point(field_get:SDMS.NoteComment.type)
  return _internal_type();
}
inline void NoteComment::set_type(::SDMS::NoteType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SDMS.NoteComment.type)
}
inline ::SDMS::NoteType NoteComment::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::NoteType>(_impl_.type_);
}
inline void NoteComment::_internal_set_type(::SDMS::NoteType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::NoteType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// optional .SDMS.NoteState state = 5;
inline bool NoteComment::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NoteComment::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::SDMS::NoteState NoteComment::state() const {
  // @@protoc_insertion_point(field_get:SDMS.NoteComment.state)
  return _internal_state();
}
inline void NoteComment::set_state(::SDMS::NoteState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SDMS.NoteComment.state)
}
inline ::SDMS::NoteState NoteComment::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::NoteState>(_impl_.state_);
}
inline void NoteComment::_internal_set_state(::SDMS::NoteState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::NoteState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// NoteData

// required string id = 1;
inline bool NoteData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NoteData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NoteData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.NoteData.id)
}
inline std::string* NoteData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.NoteData.id)
  return _s;
}
inline const std::string& NoteData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void NoteData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NoteData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NoteData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.NoteData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.NoteData.id)
}

// required .SDMS.NoteType type = 2;
inline bool NoteData::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NoteData::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::SDMS::NoteType NoteData::type() const {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.type)
  return _internal_type();
}
inline void NoteData::set_type(::SDMS::NoteType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SDMS.NoteData.type)
}
inline ::SDMS::NoteType NoteData::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::NoteType>(_impl_.type_);
}
inline void NoteData::_internal_set_type(::SDMS::NoteType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::NoteType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}

// required .SDMS.NoteState state = 3;
inline bool NoteData::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NoteData::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::SDMS::NoteState NoteData::state() const {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.state)
  return _internal_state();
}
inline void NoteData::set_state(::SDMS::NoteState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SDMS.NoteData.state)
}
inline ::SDMS::NoteState NoteData::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::NoteState>(_impl_.state_);
}
inline void NoteData::_internal_set_state(::SDMS::NoteState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::NoteState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.state_ = value;
}

// required string subject_id = 4;
inline bool NoteData::has_subject_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NoteData::clear_subject_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NoteData::subject_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.subject_id)
  return _internal_subject_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteData::set_subject_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.NoteData.subject_id)
}
inline std::string* NoteData::mutable_subject_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject_id();
  // @@protoc_insertion_point(field_mutable:SDMS.NoteData.subject_id)
  return _s;
}
inline const std::string& NoteData::_internal_subject_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_id_.Get();
}
inline void NoteData::_internal_set_subject_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subject_id_.Set(value, GetArena());
}
inline std::string* NoteData::_internal_mutable_subject_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subject_id_.Mutable( GetArena());
}
inline std::string* NoteData::release_subject_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.NoteData.subject_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subject_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subject_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteData::set_allocated_subject_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subject_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_id_.IsDefault()) {
          _impl_.subject_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.NoteData.subject_id)
}

// required string title = 5;
inline bool NoteData::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NoteData::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NoteData::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteData::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.NoteData.title)
}
inline std::string* NoteData::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SDMS.NoteData.title)
  return _s;
}
inline const std::string& NoteData::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void NoteData::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* NoteData::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* NoteData::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.NoteData.title)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteData::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.NoteData.title)
}

// repeated .SDMS.NoteComment comment = 6;
inline int NoteData::_internal_comment_size() const {
  return _internal_comment().size();
}
inline int NoteData::comment_size() const {
  return _internal_comment_size();
}
inline void NoteData::clear_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_.Clear();
}
inline ::SDMS::NoteComment* NoteData::mutable_comment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.NoteData.comment)
  return _internal_mutable_comment()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::NoteComment>* NoteData::mutable_comment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.NoteData.comment)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_comment();
}
inline const ::SDMS::NoteComment& NoteData::comment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.comment)
  return _internal_comment().Get(index);
}
inline ::SDMS::NoteComment* NoteData::add_comment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::NoteComment* _add = _internal_mutable_comment()->Add();
  // @@protoc_insertion_point(field_add:SDMS.NoteData.comment)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::NoteComment>& NoteData::comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.NoteData.comment)
  return _internal_comment();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::NoteComment>&
NoteData::_internal_comment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comment_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::NoteComment>*
NoteData::_internal_mutable_comment() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.comment_;
}

// required uint32 ct = 7;
inline bool NoteData::has_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void NoteData::clear_ct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ct_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t NoteData::ct() const {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.ct)
  return _internal_ct();
}
inline void NoteData::set_ct(::uint32_t value) {
  _internal_set_ct(value);
  // @@protoc_insertion_point(field_set:SDMS.NoteData.ct)
}
inline ::uint32_t NoteData::_internal_ct() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ct_;
}
inline void NoteData::_internal_set_ct(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ct_ = value;
}

// required uint32 ut = 8;
inline bool NoteData::has_ut() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void NoteData::clear_ut() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ut_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t NoteData::ut() const {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.ut)
  return _internal_ut();
}
inline void NoteData::set_ut(::uint32_t value) {
  _internal_set_ut(value);
  // @@protoc_insertion_point(field_set:SDMS.NoteData.ut)
}
inline ::uint32_t NoteData::_internal_ut() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ut_;
}
inline void NoteData::_internal_set_ut(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ut_ = value;
}

// optional string parent_id = 9;
inline bool NoteData::has_parent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NoteData::clear_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NoteData::parent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.parent_id)
  return _internal_parent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteData::set_parent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.parent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.NoteData.parent_id)
}
inline std::string* NoteData::mutable_parent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:SDMS.NoteData.parent_id)
  return _s;
}
inline const std::string& NoteData::_internal_parent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_id_.Get();
}
inline void NoteData::_internal_set_parent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.parent_id_.Set(value, GetArena());
}
inline std::string* NoteData::_internal_mutable_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.parent_id_.Mutable( GetArena());
}
inline std::string* NoteData::release_parent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.NoteData.parent_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.parent_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NoteData::set_allocated_parent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.parent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_id_.IsDefault()) {
          _impl_.parent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.NoteData.parent_id)
}

// optional bool has_child = 10;
inline bool NoteData::has_has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void NoteData::clear_has_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_child_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool NoteData::has_child() const {
  // @@protoc_insertion_point(field_get:SDMS.NoteData.has_child)
  return _internal_has_child();
}
inline void NoteData::set_has_child(bool value) {
  _internal_set_has_child(value);
  // @@protoc_insertion_point(field_set:SDMS.NoteData.has_child)
}
inline bool NoteData::_internal_has_child() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_child_;
}
inline void NoteData::_internal_set_has_child(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.has_child_ = value;
}

// -------------------------------------------------------------------

// TaskData

// required string id = 1;
inline bool TaskData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TaskData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TaskData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TaskData.id)
}
inline std::string* TaskData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.TaskData.id)
  return _s;
}
inline const std::string& TaskData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void TaskData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* TaskData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* TaskData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TaskData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TaskData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TaskData.id)
}

// required .SDMS.TaskType type = 2;
inline bool TaskData::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TaskData::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::SDMS::TaskType TaskData::type() const {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.type)
  return _internal_type();
}
inline void TaskData::set_type(::SDMS::TaskType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SDMS.TaskData.type)
}
inline ::SDMS::TaskType TaskData::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::TaskType>(_impl_.type_);
}
inline void TaskData::_internal_set_type(::SDMS::TaskType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::TaskType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_ = value;
}

// required .SDMS.TaskStatus status = 3;
inline bool TaskData::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void TaskData::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::SDMS::TaskStatus TaskData::status() const {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.status)
  return _internal_status();
}
inline void TaskData::set_status(::SDMS::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:SDMS.TaskData.status)
}
inline ::SDMS::TaskStatus TaskData::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SDMS::TaskStatus>(_impl_.status_);
}
inline void TaskData::_internal_set_status(::SDMS::TaskStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SDMS::TaskStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.status_ = value;
}

// required string client = 4;
inline bool TaskData::has_client() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TaskData::clear_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TaskData::client() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.client)
  return _internal_client();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskData::set_client(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TaskData.client)
}
inline std::string* TaskData::mutable_client() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:SDMS.TaskData.client)
  return _s;
}
inline const std::string& TaskData::_internal_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_.Get();
}
inline void TaskData::_internal_set_client(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_.Set(value, GetArena());
}
inline std::string* TaskData::_internal_mutable_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.client_.Mutable( GetArena());
}
inline std::string* TaskData::release_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TaskData.client)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.client_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TaskData::set_allocated_client(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.client_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_.IsDefault()) {
          _impl_.client_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TaskData.client)
}

// required uint32 step = 5;
inline bool TaskData::has_step() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void TaskData::clear_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.step_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t TaskData::step() const {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.step)
  return _internal_step();
}
inline void TaskData::set_step(::uint32_t value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:SDMS.TaskData.step)
}
inline ::uint32_t TaskData::_internal_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.step_;
}
inline void TaskData::_internal_set_step(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.step_ = value;
}

// required uint32 steps = 6;
inline bool TaskData::has_steps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void TaskData::clear_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.steps_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t TaskData::steps() const {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.steps)
  return _internal_steps();
}
inline void TaskData::set_steps(::uint32_t value) {
  _internal_set_steps(value);
  // @@protoc_insertion_point(field_set:SDMS.TaskData.steps)
}
inline ::uint32_t TaskData::_internal_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steps_;
}
inline void TaskData::_internal_set_steps(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.steps_ = value;
}

// required string msg = 7;
inline bool TaskData::has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TaskData::clear_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TaskData::msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskData::set_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TaskData.msg)
}
inline std::string* TaskData::mutable_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:SDMS.TaskData.msg)
  return _s;
}
inline const std::string& TaskData::_internal_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msg_.Get();
}
inline void TaskData::_internal_set_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msg_.Set(value, GetArena());
}
inline std::string* TaskData::_internal_mutable_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.msg_.Mutable( GetArena());
}
inline std::string* TaskData::release_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TaskData.msg)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.msg_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.msg_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TaskData::set_allocated_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TaskData.msg)
}

// required uint32 ct = 8;
inline bool TaskData::has_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void TaskData::clear_ct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ct_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t TaskData::ct() const {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.ct)
  return _internal_ct();
}
inline void TaskData::set_ct(::uint32_t value) {
  _internal_set_ct(value);
  // @@protoc_insertion_point(field_set:SDMS.TaskData.ct)
}
inline ::uint32_t TaskData::_internal_ct() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ct_;
}
inline void TaskData::_internal_set_ct(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.ct_ = value;
}

// required uint32 ut = 9;
inline bool TaskData::has_ut() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void TaskData::clear_ut() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ut_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t TaskData::ut() const {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.ut)
  return _internal_ut();
}
inline void TaskData::set_ut(::uint32_t value) {
  _internal_set_ut(value);
  // @@protoc_insertion_point(field_set:SDMS.TaskData.ut)
}
inline ::uint32_t TaskData::_internal_ut() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ut_;
}
inline void TaskData::_internal_set_ut(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.ut_ = value;
}

// optional string source = 10;
inline bool TaskData::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TaskData::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TaskData::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskData::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TaskData.source)
}
inline std::string* TaskData::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:SDMS.TaskData.source)
  return _s;
}
inline const std::string& TaskData::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void TaskData::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.source_.Set(value, GetArena());
}
inline std::string* TaskData::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.source_.Mutable( GetArena());
}
inline std::string* TaskData::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TaskData.source)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TaskData::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.source_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TaskData.source)
}

// optional string dest = 11;
inline bool TaskData::has_dest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TaskData::clear_dest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TaskData::dest() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.TaskData.dest)
  return _internal_dest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskData::set_dest(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dest_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.TaskData.dest)
}
inline std::string* TaskData::mutable_dest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dest();
  // @@protoc_insertion_point(field_mutable:SDMS.TaskData.dest)
  return _s;
}
inline const std::string& TaskData::_internal_dest() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dest_.Get();
}
inline void TaskData::_internal_set_dest(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dest_.Set(value, GetArena());
}
inline std::string* TaskData::_internal_mutable_dest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.dest_.Mutable( GetArena());
}
inline std::string* TaskData::release_dest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.TaskData.dest)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.dest_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dest_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TaskData::set_allocated_dest(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.dest_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dest_.IsDefault()) {
          _impl_.dest_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.TaskData.dest)
}

// -------------------------------------------------------------------

// SchemaData

// required string id = 1;
inline bool SchemaData::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaData::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaData::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.id)
}
inline std::string* SchemaData::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SDMS.SchemaData.id)
  return _s;
}
inline const std::string& SchemaData::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void SchemaData::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SchemaData::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SchemaData::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.SchemaData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaData::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.SchemaData.id)
}

// required uint32 ver = 2;
inline bool SchemaData::has_ver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SchemaData::clear_ver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ver_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t SchemaData::ver() const {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.ver)
  return _internal_ver();
}
inline void SchemaData::set_ver(::uint32_t value) {
  _internal_set_ver(value);
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.ver)
}
inline ::uint32_t SchemaData::_internal_ver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ver_;
}
inline void SchemaData::_internal_set_ver(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ver_ = value;
}

// optional bool depr = 3;
inline bool SchemaData::has_depr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SchemaData::clear_depr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.depr_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool SchemaData::depr() const {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.depr)
  return _internal_depr();
}
inline void SchemaData::set_depr(bool value) {
  _internal_set_depr(value);
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.depr)
}
inline bool SchemaData::_internal_depr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.depr_;
}
inline void SchemaData::_internal_set_depr(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.depr_ = value;
}

// optional uint32 cnt = 4;
inline bool SchemaData::has_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SchemaData::clear_cnt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t SchemaData::cnt() const {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.cnt)
  return _internal_cnt();
}
inline void SchemaData::set_cnt(::uint32_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.cnt)
}
inline ::uint32_t SchemaData::_internal_cnt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cnt_;
}
inline void SchemaData::_internal_set_cnt(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.cnt_ = value;
}

// optional bool ref = 5;
inline bool SchemaData::has_ref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void SchemaData::clear_ref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ref_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool SchemaData::ref() const {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.ref)
  return _internal_ref();
}
inline void SchemaData::set_ref(bool value) {
  _internal_set_ref(value);
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.ref)
}
inline bool SchemaData::_internal_ref() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ref_;
}
inline void SchemaData::_internal_set_ref(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.ref_ = value;
}

// optional string own_id = 6;
inline bool SchemaData::has_own_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchemaData::clear_own_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.own_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaData::own_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.own_id)
  return _internal_own_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaData::set_own_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.own_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.own_id)
}
inline std::string* SchemaData::mutable_own_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_own_id();
  // @@protoc_insertion_point(field_mutable:SDMS.SchemaData.own_id)
  return _s;
}
inline const std::string& SchemaData::_internal_own_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.own_id_.Get();
}
inline void SchemaData::_internal_set_own_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.own_id_.Set(value, GetArena());
}
inline std::string* SchemaData::_internal_mutable_own_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.own_id_.Mutable( GetArena());
}
inline std::string* SchemaData::release_own_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.SchemaData.own_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.own_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.own_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaData::set_allocated_own_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.own_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.own_id_.IsDefault()) {
          _impl_.own_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.SchemaData.own_id)
}

// optional string own_nm = 7;
inline bool SchemaData::has_own_nm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchemaData::clear_own_nm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.own_nm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SchemaData::own_nm() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.own_nm)
  return _internal_own_nm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaData::set_own_nm(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.own_nm_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.own_nm)
}
inline std::string* SchemaData::mutable_own_nm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_own_nm();
  // @@protoc_insertion_point(field_mutable:SDMS.SchemaData.own_nm)
  return _s;
}
inline const std::string& SchemaData::_internal_own_nm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.own_nm_.Get();
}
inline void SchemaData::_internal_set_own_nm(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.own_nm_.Set(value, GetArena());
}
inline std::string* SchemaData::_internal_mutable_own_nm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.own_nm_.Mutable( GetArena());
}
inline std::string* SchemaData::release_own_nm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.SchemaData.own_nm)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.own_nm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.own_nm_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaData::set_allocated_own_nm(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.own_nm_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.own_nm_.IsDefault()) {
          _impl_.own_nm_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.SchemaData.own_nm)
}

// optional string desc = 8;
inline bool SchemaData::has_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchemaData::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SchemaData::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaData::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.desc)
}
inline std::string* SchemaData::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:SDMS.SchemaData.desc)
  return _s;
}
inline const std::string& SchemaData::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void SchemaData::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* SchemaData::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* SchemaData::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.SchemaData.desc)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.desc_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaData::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.SchemaData.desc)
}

// optional bool pub = 9;
inline bool SchemaData::has_pub() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void SchemaData::clear_pub() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pub_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool SchemaData::pub() const {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.pub)
  return _internal_pub();
}
inline void SchemaData::set_pub(bool value) {
  _internal_set_pub(value);
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.pub)
}
inline bool SchemaData::_internal_pub() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pub_;
}
inline void SchemaData::_internal_set_pub(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.pub_ = value;
}

// optional string def = 10;
inline bool SchemaData::has_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchemaData::clear_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.def_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SchemaData::def() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.def)
  return _internal_def();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaData::set_def(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.def_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SDMS.SchemaData.def)
}
inline std::string* SchemaData::mutable_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_def();
  // @@protoc_insertion_point(field_mutable:SDMS.SchemaData.def)
  return _s;
}
inline const std::string& SchemaData::_internal_def() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.def_.Get();
}
inline void SchemaData::_internal_set_def(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.def_.Set(value, GetArena());
}
inline std::string* SchemaData::_internal_mutable_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.def_.Mutable( GetArena());
}
inline std::string* SchemaData::release_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SDMS.SchemaData.def)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.def_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.def_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaData::set_allocated_def(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.def_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.def_.IsDefault()) {
          _impl_.def_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SDMS.SchemaData.def)
}

// repeated .SDMS.SchemaData uses = 11;
inline int SchemaData::_internal_uses_size() const {
  return _internal_uses().size();
}
inline int SchemaData::uses_size() const {
  return _internal_uses_size();
}
inline void SchemaData::clear_uses() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uses_.Clear();
}
inline ::SDMS::SchemaData* SchemaData::mutable_uses(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.SchemaData.uses)
  return _internal_mutable_uses()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>* SchemaData::mutable_uses()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.SchemaData.uses)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_uses();
}
inline const ::SDMS::SchemaData& SchemaData::uses(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.uses)
  return _internal_uses().Get(index);
}
inline ::SDMS::SchemaData* SchemaData::add_uses() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::SchemaData* _add = _internal_mutable_uses()->Add();
  // @@protoc_insertion_point(field_add:SDMS.SchemaData.uses)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>& SchemaData::uses() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.SchemaData.uses)
  return _internal_uses();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>&
SchemaData::_internal_uses() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uses_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>*
SchemaData::_internal_mutable_uses() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.uses_;
}

// repeated .SDMS.SchemaData used_by = 12;
inline int SchemaData::_internal_used_by_size() const {
  return _internal_used_by().size();
}
inline int SchemaData::used_by_size() const {
  return _internal_used_by_size();
}
inline void SchemaData::clear_used_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.used_by_.Clear();
}
inline ::SDMS::SchemaData* SchemaData::mutable_used_by(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SDMS.SchemaData.used_by)
  return _internal_mutable_used_by()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>* SchemaData::mutable_used_by()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SDMS.SchemaData.used_by)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_used_by();
}
inline const ::SDMS::SchemaData& SchemaData::used_by(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SDMS.SchemaData.used_by)
  return _internal_used_by().Get(index);
}
inline ::SDMS::SchemaData* SchemaData::add_used_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SDMS::SchemaData* _add = _internal_mutable_used_by()->Add();
  // @@protoc_insertion_point(field_add:SDMS.SchemaData.used_by)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>& SchemaData::used_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SDMS.SchemaData.used_by)
  return _internal_used_by();
}
inline const ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>&
SchemaData::_internal_used_by() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.used_by_;
}
inline ::google::protobuf::RepeatedPtrField<::SDMS::SchemaData>*
SchemaData::_internal_mutable_used_by() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.used_by_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace SDMS


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::SDMS::ErrorCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::ErrorCode>() {
  return ::SDMS::ErrorCode_descriptor();
}
template <>
struct is_proto_enum<::SDMS::ServiceStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::ServiceStatus>() {
  return ::SDMS::ServiceStatus_descriptor();
}
template <>
struct is_proto_enum<::SDMS::SearchMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::SearchMode>() {
  return ::SDMS::SearchMode_descriptor();
}
template <>
struct is_proto_enum<::SDMS::DependencyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::DependencyType>() {
  return ::SDMS::DependencyType_descriptor();
}
template <>
struct is_proto_enum<::SDMS::DependencyDir> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::DependencyDir>() {
  return ::SDMS::DependencyDir_descriptor();
}
template <>
struct is_proto_enum<::SDMS::SortOption> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::SortOption>() {
  return ::SDMS::SortOption_descriptor();
}
template <>
struct is_proto_enum<::SDMS::ProjectRole> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::ProjectRole>() {
  return ::SDMS::ProjectRole_descriptor();
}
template <>
struct is_proto_enum<::SDMS::NoteType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::NoteType>() {
  return ::SDMS::NoteType_descriptor();
}
template <>
struct is_proto_enum<::SDMS::NoteState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::NoteState>() {
  return ::SDMS::NoteState_descriptor();
}
template <>
struct is_proto_enum<::SDMS::TaskType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::TaskType>() {
  return ::SDMS::TaskType_descriptor();
}
template <>
struct is_proto_enum<::SDMS::TaskStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::TaskStatus>() {
  return ::SDMS::TaskStatus_descriptor();
}
template <>
struct is_proto_enum<::SDMS::TaskCommand> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::TaskCommand>() {
  return ::SDMS::TaskCommand_descriptor();
}
template <>
struct is_proto_enum<::SDMS::Encryption> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SDMS::Encryption>() {
  return ::SDMS::Encryption_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_SDMS_2eproto_2epb_2eh
